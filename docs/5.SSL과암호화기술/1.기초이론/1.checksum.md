### 체크섬(Checksum) - 데이터 무결성 검증의 출발점

체크섬은 **데이터의 오류 여부를 확인하는 방법**으로 사용됩니다. 하지만 이 체크섬은 **보안성이 없습니다**. 이 말은 **기밀성과 무결성을 보장할 수 없다**는 의미입니다.

이 체크섬은 **원본 데이터와 복사본 데이터가 완전히 동일한지 확인하는 비교 방법론**입니다.

```
📡 체크섬 동작 과정

송신측                                    수신측
┌──────────────┐                     ┌──────────────┐
│원본 데이터   │                     │복사본 데이터 │
│"HELLO WORLD" │                     │"HELLO WORLD" │
│              │                     │              │
│체크섬 계산   │    데이터 + 검사합   │체크섬 재계산 │
│결과: 247     │ ──────────────────→ │결과: 247     │
└──────────────┘                     └──────────────┘
                                             │
                                             ▼
                                    ┌──────────────┐
                                    │검사합 비교   │
                                    │247 == 247?   │
                                    │✓ 일치!      │
                                    │데이터 정상   │
                                    └──────────────┘
```

**데이터를 보낼 때 원본 데이터뿐만 아니라 검사합이라는 데이터도 함께 보냅니다**. 이때 **수신측에서도 복사본과 검사합을 받습니다**. 그래서 **수신측에서 동일한 방법으로 복사본 데이터를 계산한 후 이 전달받은 검사합과 비교합니다**. **일치하는 경우 데이터가 손상되지 않았다고 판단합니다**.

### 체크섬의 계산 방식

**일정 자릿수를 정하고 범위를 넘는 자리올림은 버려서 자릿수를 유지합니다**. 예를 들어 **5 + 7 = 12인데 이때 올림인 10의 자릿수를 버리면 2가 됩니다**. **이와 같이 일정한 자릿수를 유지합니다**.

```
🧮 체크섬 계산 원리

기본 예시:
5 + 7 = 12 → 자리올림 1 버림 → 결과: 2

실제 데이터 계산:
데이터: "HELLO" (ASCII 코드)
H=72, E=69, L=76, L=76, O=79

순차 계산 (10으로 나눈 나머지):
72 + 69 = 141 → 1 (10의 자리 버림)
1 + 76 = 77   → 7
7 + 76 = 83   → 3  
3 + 79 = 82   → 2

최종 체크섬: 2
```

### 체크섬의 치명적 보안 취약점

**근데 이 검사합이 보안성이 없다고 말하는 이유**는 **중간에 누군가 데이터를 가로채서 값을 변경시킨 후 검사합을 재계산해서 바꿔치기하면 수신측에서는 데이터가 중간에 조작되었어도 알 수 없기 때문**입니다.

```
🚨 체크섬 보안 취약점

정상 전송:
원본: "PAY $100" + 체크섬(45)
전송: "PAY $100" + "45"  
수신: 검증 성공 ✓

악의적 공격:
1. 공격자가 데이터 가로채기: "PAY $100" + "45"
2. 데이터 변조: "PAY $100" → "PAY $999"  
3. 검사합의 원본을 재계산: 새로운 체크섬 78 생성
4. 바꿔치기 전송: "PAY $999" + "78"
5. 수신측 검증: 78 == 78 ✓ (변조 탐지 실패!)

문제점: 공격자가 검사합까지 재계산하면 변조를 탐지할 수 없음
```

**그래서 이러한 문제를 해결하기 위해서 나온 것 중 하나가 Hash입니다**.

### 이름 궁합을 통한 단방향 함수의 이해

**이 체크섬을 이해할 때 가장 좋은 예시가 바로 이름 궁합입니다**. **두 사람의 이름의 획을 구해서 이를 더해나갈 때 올림자리를 자르고 계속해서 더하는 방식**입니다.

```
✏️ 이름 궁합 계산 과정

성 이 완 완 종 구 
5  2  7  7  6  4

단계별 계산:

5  2  7  7  6 4
  6  9  4  3 0
    6  3  7 3 
      9  0  0
       9   0
```

**여기서 7+9 = 16이다. 이때 자리올림 1을 버리면 결과가 6이다. 같은 원리로 3+7 = 10이지만 0이 된다**.

### 단방향 함수의 핵심 개념

**그래서 함수 f(x)가 있을 때 x에다 글자를 넣으면 획을 얻을 수 있는 단방향 함수입니다**. **여기서 단방향이라고 하면 성이라는 글자를 넣었을 때 획수가 5가 나올 때 이를 역계산했을 때 획이 5가 나오는 글자가 많기 때문에 글자를 특정할 수 없습니다**. **이러한 경우 이 함수가 단방향이라고 합니다**.

```
🔑 단방향 함수의 특성

정방향 계산 (쉬움):
글자 입력 → f(x) → 획수 출력
"성" → f(x) → 5 ✓

역방향 계산 (불가능):
획수 입력 → f⁻¹(x) → 글자 출력
5 → f⁻¹(x) → "성"? ❌

이유: 획이 5인 글자들이 다수 존재
- 성(5획), 본(5획), 민(5획), 
- 백(5획), 석(5획), 외(5획) 등...
→ 특정 글자를 복원할 수 없음!
```

### 해시 함수로의 연결고리

**이 결과를 가지고 인자를 추론할 수 없는 것이 Hash라는 관점에서 결국 이 이름 궁합의 최종 결과는 90입니다**. **90을 근거로 성이완완종구라는 원본 문자열을 복원하는 것은 불가능합니다(Hash)**. **획수를 알아도 원본 문자를 정확히 알 수 없습니다(hash)**.

```
🔄 체크섬에서 해시로의 발전 과정

이름 궁합 예시에서 확인되는 해시의 특성:
┌─────────────────────────────────────┐
│입력: "성이완완종구" (6글자)        │
│출력: "90" (고정 길이)              │
│                                    │
│해시 특성:                          │
│✅ 단방향성: 90 → 원본 복원 불가능  │
│✅ 결정론적: 동일 입력 → 동일 출력  │
│✅ 고정 출력: 입력 길이 무관        │
│✅ 눈사태 효과: 1글자 변경시 대폭변화│
└─────────────────────────────────────┘

체크섬의 한계 극복:
┌─────────────────────────────────────┐
│체크섬: 재계산 가능 → 보안 취약     │
│해시: 역계산 불가능 → 보안 강화     │
└─────────────────────────────────────┘
```

### 검사합의 기본 개념과 중요성

**이 검사합이라는 개념은 데이터에 문제가 생겼는지, 변조가 되었는지 확인하는 가장 기초적인 방식입니다**.

```
📋 체크섬의 역할과 한계

역할:
✅ 전송 오류 탐지 (네트워크 패킷 손실, 비트 오류)
✅ 저장 오류 탐지 (하드디스크 섹터 손상)
✅ 데이터 동일성 확인 (파일 복사 검증)

한계:
❌ 의도적 변조 탐지 불가능
❌ 송신자 신원 확인 불가능  
❌ 데이터 기밀성 보장 불가능
❌ 부인 방지 기능 없음

SSL/TLS에서 체크섬만으로는 부족한 이유:
┌─────────────────────────────────────┐
│웹 보안에서 필요한 요구사항:         │
│• 데이터 무결성 (변조 탐지)         │
│• 인증 (신원 확인)                  │
│• 기밀성 (암호화)                   │
│• 부인 방지 (디지털 서명)           │
│                                    │
│→ 체크섬으로는 첫 번째만 부분적 해결│
│→ 해시 함수 + 암호화 기술 필요      │
└─────────────────────────────────────┘
```

이렇게 **단순한 체크섬에서 시작된 데이터 무결성 검증 기술**이 **단방향 함수의 특성을 가진 해시 함수**로 발전하면서, 현대 SSL/TLS 프로토콜의 **핵심 보안 메커니즘**이 되었습니다. 이름 궁합이라는 친숙한 예시를 통해 **복잡한 암호학적 개념을 직관적으로 이해**할 수 있는 훌륭한 출발점이 됩니다.