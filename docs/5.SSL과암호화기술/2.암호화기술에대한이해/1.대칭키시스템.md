## 암호화 기술에 대한 이해 - 대칭키 시스템

**흔히 암호화 방식이라 하면 2가지가 있다. 하나는 대칭키(Symmetric Key) 다른 하나는 비대칭키(Asymmetric Key) 방식이 있다.**

**대칭키 방식은 키 하나로 암호화/복호화를 모두 수행하는 방식이다. 비대칭키 방식에 비해 효율적이다.**

```
 🔐 암호화 방식의 두 가지 분류

대칭키 (Symmetric Key):
┌─────────────────────────────────┐
│        동일한 키 1개            │
│    ┌────────┐  ┌────────┐      │
│    │ 암호화 │  │ 복호화 │      │
│    │   ↑    │  │   ↑    │      │
│    └────────┘  └────────┘      │
│         │           │          │
│    같은 키 K    같은 키 K       │
│                                │
│특징: 빠름, 효율적              │
└─────────────────────────────────┘

비대칭키 (Asymmetric Key):
┌─────────────────────────────────┐
│        서로 다른 키 2개         │
│    ┌────────┐  ┌────────┐      │
│    │ 암호화 │  │ 복호화 │      │
│    │   ↑    │  │   ↑    │      │
│    └────────┘  └────────┘      │
│         │           │          │
│    공개키      개인키           │
│                                │
│특징: 느림, 키 분배 안전        │
└─────────────────────────────────┘
```

**대칭키의 친숙한 예시**

**이 대칭키 방식은 매우 친숙한 방식이다. 예를 들어 우리가 자동차 키를 가지고 차를 잠그기도 하지만 잠겨진 차를 다시 해제하기도 한다.**

```
🚗 일상 생활 속 대칭키 개념

자동차 키:
┌─────────────────────────────────┐
│동일한 키로 두 가지 작업:        │
│                                │
│🔒 잠금 (암호화)                │
│차량 + 키 → 잠긴 상태           │
│                                │
│🔓 해제 (복호화)                │
│잠긴 차량 + 키 → 정상 사용      │
│                                │
│특징:                           │
│✅ 하나의 키로 양방향 작업       │
│✅ 키 분실 시 둘 다 불가능       │
│✅ 키 복사 = 동일한 권한 부여    │
└─────────────────────────────────┘

기타 유사 사례:
🏠 집 열쇠 (잠금/해제)
🔐 자물쇠 (잠금/해제)  
💾 암호화된 USB (암호화/복호화)
```

**대칭키 알고리즘의 종류**

**대표적으로는 DES, 3DES, SEED-128, ARIA, AES-128, AES-256 알고리즘이 유명하다.**

```
📋 주요 대칭키 알고리즘

구세대 알고리즘:
┌─────────────────────────────────┐
│DES (Data Encryption Standard)  │
│• 키 길이: 56비트               │
│• 개발: 1970년대 IBM/NSA        │
│• ❌ 현재 사용 금지 (취약)      │
│                                │
│3DES (Triple DES)               │
│• DES를 3번 적용                │
│• 키 길이: 112~168비트          │
│• ❌ 느림, 단계적 사용 중단     │
└─────────────────────────────────┘

현대 알고리즘:
┌─────────────────────────────────┐
│AES (Advanced Encryption Standard)│
│• AES-128: 128비트 키           │
│• AES-256: 256비트 키 ← 권장    │
│• 미국 표준 (2001년~)           │
│• ✅ 현재 가장 널리 사용        │
│                                │
│국산 알고리즘:                   │
│• SEED-128: 128비트 키          │
│• ARIA: 128/192/256비트 키      │
│• 한국 표준 암호 알고리즘        │
└─────────────────────────────────┘
```

**대칭키의 효율성**

**이 대칭키가 비대칭에 비해서 효율적이라고 했는데 만약 대칭과 비대칭 방식이 있을 때 어떤 방식을 선택할 수 있다면 둘 중 어느 것을 사용하기 위해 노력해야 되느냐 하면 바로 대칭키 방식이다. 무조건 효율을 얘기하면 대칭키의 승이다.**

```
⚡ 대칭키 vs 비대칭키 성능 비교

처리 속도:
┌─────────────────────────────────┐
│대칭키 (AES-256):               │
│• 소프트웨어: 수백 MB/s         │
│• 하드웨어 가속: 수 GB/s        │
│                                │
│비대칭키 (RSA-2048):            │
│• RSA 암호화: 수십 KB/s         │
│• RSA 복호화: 수백 byte/s       │
│                                │
│성능 차이: 1000~10000배 !!      │
└─────────────────────────────────┘

자원 사용량:
┌─────────────────────────────────┐
│대칭키:                         │
│✅ 낮은 CPU 사용률             │
│✅ 적은 메모리 요구량          │
│✅ 배터리 효율성 우수          │
│                               │
│비대칭키:                       │
│❌ 높은 CPU 사용률 (복잡한 연산)│
│❌ 많은 메모리 요구량          │
│❌ 전력 소모 큼                │
└─────────────────────────────────┘
```

**XOR 연산을 통한 대칭키 암호화 원리**

**이 암호화를 보안성을 부여한다라고도 한다.**

메모에서 제시한 XOR 연산 예시를 통해 대칭키 암호화의 기본 원리를 이해해보겠습니다:

```
🔢 XOR 연산을 통한 암호화 과정

1단계: 평문을 이진수로 변환
평문 'A' = ASCII 65 = 0x41 = 0100 0001

2단계: 키와 XOR 연산 (암호화)
평문:    0100 0001  (A)
키:      1101 0100  (임의의 키)
--------------------------- XOR 연산
암호문:  1001 0101  (0x95)

3단계: 암호문과 동일한 키로 XOR 연산 (복호화)
암호문:  1001 0101  (0x95)  
키:      1101 0100  (동일한 키)
---------------------------
평문:    0100 0001  (A) ← 원본 복구!
```

**지금까지 한 결과를 반대로 해보게 되면, 위에 2개를 가지고 XOR 연산을 했는데 아래 2개를 가지고 위의 값을 계산해보자. 다시 원래 정보로 돌아오는 것을 확인할 수 있다.**

```
🔄 XOR 연산의 핵심 특성

XOR의 가역성 (Reversible):
A ⊕ B = C  라면
C ⊕ B = A  (원본 복구 가능)

수학적 증명:
┌─────────────────────────────────┐
│A ⊕ K = C (암호화)              │
│C ⊕ K = A (복호화)              │
│                                │
│이유: (A ⊕ K) ⊕ K = A           │
│     결합 법칙에 의해            │
│     A ⊕ (K ⊕ K) = A ⊕ 0 = A    │
└─────────────────────────────────┘

실제 계산 예시:
┌─────────────────────────────────┐
│암호화: 01000001 ⊕ 11010100 = 10010101│
│복호화: 10010101 ⊕ 11010100 = 01000001│
│결과: 원본 'A' 완벽 복구 ✅     │
└─────────────────────────────────┘
```

**이때 가장 위에 있는 대문자 A를 평문이라고 한다. 그리고 중간에 어떤 값과 XOR 연산한 결과값을 암호문이라고 한다. 그러면 이 중간 정보를 Key라고 한다. 그래서 이 키를 가지고 암호화도 하고 복호화도 진행했다. 그래서 대칭키이다.실제 대칭키 암호화의 복잡성**
**물론 지금 예제처럼 간단하지는 않다. 하지만 어떤 대칭키든 결국 찾아 들어가 보면 항상 XOR 연산이 등장한다.**

```
🔧 실제 AES 알고리즘의 복잡성

단순 XOR vs 실제 AES:
┌─────────────────────────────────┐
│단순 XOR:                       │
│평문 ⊕ 키 = 암호문             │
│1단계 완료                      │
│                               │
│실제 AES-256:                   │
│1. SubBytes (바이트 치환)       │
│2. ShiftRows (행 이동)          │
│3. MixColumns (열 혼합)         │
│4. AddRoundKey (라운드키 XOR) ← │
│                               │
│위 4단계를 14라운드 반복!       │
│총 56단계의 복잡한 변환         │
└─────────────────────────────────┘

하지만 핵심은 XOR:
┌─────────────────────────────────┐
│각 라운드마다:                   │
│• 복잡한 치환과 순열 적용        │
│• 마지막에 라운드키와 XOR       │
│• XOR의 가역성으로 복호화 가능   │
│                                │
│결론: XOR = 대칭키의 수학적 기반 │
└─────────────────────────────────┘
```

### 키 길이와 보안성의 관계

**여기서 키의 길이에 대해 주목할 필요가 있다. 지금 위에서는 8비트로 표현했다. 그러면 2의 8제곱까지의 경우의 수가 있는 거고 이는 256가지뿐이다. 그래서 암호문만 있으면 이걸 가지고 와서 평문 정답이 뭔지 아는 상태에서 256번 Brute Force로 대입하면 언젠가는 값을 도출할 것이다. 너무 짧다.**

```
🔢 키 길이에 따른 보안성 변화

키 길이와 경우의 수:
┌─────────────────────────────────┐
│8비트 키:                       │
│• 2^8 = 256가지                │
│• 브루트 포스: 수초 내 완료     │
│• 보안성: ❌ 매우 취약          │
│                               │
│56비트 키 (DES):                │
│• 2^56 = 약 7천만 가지         │
│• 브루트 포스: 1990년대에 성공  │
│• 보안성: ❌ 취약               │
│                               │
│128비트 키 (AES-128):           │
│• 2^128 = 약 3.4 × 10^38가지   │
│• 브루트 포스: 현실적 불가능    │
│• 보안성: ✅ 안전               │
│                               │
│256비트 키 (AES-256):           │
│• 2^256 = 약 1.1 × 10^77가지   │
│• 브루트 포스: 우주 나이로도 부족│
│• 보안성: ✅ 최고 수준          │
└─────────────────────────────────┘
```

그래서 이 키라는 것의 길이가 길수록 보안성이 올라간다, 즉 길이와 보안성은 비례한다. 즉 길이가 길어진다는 것은 경우의 수가 증가한다는 의미이다.

```
📈 보안 강도 비교

브루트 포스 공격 소요 시간 (현대 컴퓨터 기준):
┌─────────────────────────────────┐
│40비트:   1초                   │
│56비트:   22시간 (DES 취약점)    │
│64비트:   1년                   │
│80비트:   70만 년               │
│128비트:  10^25년 (현재 우주 나이의│
│         10^15배)               │
│256비트:  10^60년 (실질적 무한대)│
└─────────────────────────────────┘

권장 키 길이 (2024년 기준):
✅ 대칭키: 최소 128비트, 권장 256비트
✅ 양자 컴퓨터 위협 고려: 256비트 이상
```

### 키의 본질과 저장

**이 키라는 게 물리적인 의미가 아니라 어떤 개념적인 의미이기 때문에 하드디스크에 저장 가능한 정보이다. 즉 키로써 활용되는 정보이다 정도로 이해하는 것이 좋다.**

```
💾 키의 본질과 형태

키의 실체:
┌─────────────────────────────────┐
│물리적 실체가 아닌 디지털 데이터:│
│                                │
│16진수 표현:                    │
│AES-256 키 예시:                │
│2B7E151628AED2A6ABF7158809CF4F3C│
│762E7160F38B4DA56A784D9045190CFC│
│                                │
│이진수 표현:                    │
│001010110111111000010101...     │
│                                │
│저장 형태:                      │
│• 파일로 저장 (key.dat)         │
│• 메모리에 임시 보관            │
│• 하드웨어 보안 모듈(HSM)       │
│• 암호화된 형태로 보관          │
└─────────────────────────────────┘

키 생성 방법:
┌─────────────────────────────────┐
│1️⃣ 진정한 난수 생성기 (TRNG)    │
│• 물리적 노이즈 활용            │
│• 방사성 붕괴, 열잡음 등        │
│                               │
│2️⃣ 의사 난수 생성기 (PRNG)     │
│• 수학적 알고리즘 기반          │
│• 충분한 엔트로피 필요          │
│                               │
│3️⃣ 패스워드 기반 키 유도       │
│• PBKDF2, scrypt, Argon2       │
│• 사용자 패스워드 → 암호화 키  │
└─────────────────────────────────┘
```

### 대칭키의 핵심 취약점: 키 관리

**이 키를 이야기할 때 항상 중요하게 언급되는 게 바로 안전하게 보관하는 방법이다. 이 키가 유출되면 끝이기 때문이다. 특히 대칭키는 키 하나로 암호화 및 복호화가 가능하기 때문에 노출되었을 때 보안성을 상실하게 된다.**

```
⚠️ 대칭키의 치명적 약점: 키 분배 문제

키 유출 시나리오:
┌─────────────────────────────────┐
│정상 상황:                      │
│송신자 ←─── 안전한 키 ───→ 수신자│
│   │                        │   │
│ 암호화                   복호화 │
│   ↓                        ↑   │
│암호문 ─────────────────→ 암호문│
│                               │
│공격자 개입:                    │
│   🕵️ 키 탈취 성공!            │
│   ↓                           │
│✅ 모든 암호문 해독 가능        │
│✅ 새로운 가짜 메시지 생성 가능 │
│✅ 통신 내용 완전 노출         │
└─────────────────────────────────┘

키 관리의 어려움:
┌─────────────────────────────────┐
│1️⃣ 키 배포 문제                 │
│• 안전한 채널로 키 전달 필요     │
│• 인터넷으로는 키 전달 위험      │
│• 물리적 전달: 비용/시간 과다   │
│                                │
│2️⃣ 키 저장 문제                 │
│• 메모리: 시스템 재시작 시 소멸  │
│• 파일: 해킹 시 노출 위험       │
│• 암호화 저장: 또 다른 키 필요  │
│                                │
│3️⃣ 키 갱신 문제                 │
│• 주기적 키 변경 필요           │
│• 갱신마다 안전한 배포 반복     │
│• 구 키와 신 키 동기화 문제     │
└─────────────────────────────────┘
```

대칭키의 장단점 정리

```
⚖️ 대칭키 암호화 종합 평가

장점:
┌─────────────────────────────────┐
│✅ 뛰어난 성능 (빠른 속도)       │
│✅ 낮은 자원 사용량             │
│✅ 간단한 구현                  │
│✅ 대용량 데이터 암호화 적합     │
│✅ 하드웨어 가속 지원 우수      │
│✅ 배터리 효율성 좋음           │
└─────────────────────────────────┘

단점:
┌─────────────────────────────────┐
│❌ 키 분배의 어려움 (가장 큰 문제)│
│❌ 키 관리 복잡성               │
│❌ 확장성 문제 (N명 통신시 N(N-1)/2개 키)│
│❌ 부인 방지 기능 없음          │
│❌ 키 타협 시 전체 보안 붕괴    │
└─────────────────────────────────┘

실제 활용:
┌─────────────────────────────────┐
│🔐 파일/디스크 암호화            │
│🌐 VPN 터널 암호화              │
│📱 SSL/TLS 세션 암호화 (키 교환 후)│
│💾 데이터베이스 암호화          │
│📡 무선 통신 암호화 (WPA3)      │
└─────────────────────────────────┘
```

이렇게 **대칭키 암호화는 뛰어난 성능과 효율성**을 제공하지만, **키 분배와 관리**라는 근본적인 문제를 가지고 있습니다. 이러한 한계를 극복하기 위해 **비대칭키 암호화와 결합한 하이브리드 방식**이 현대 암호학의 표준이 되었으며, 특히 **SSL/TLS에서는 비대칭키로 대칭키를 안전하게 교환한 후 실제 데이터는 대칭키로 암호화**하는 방식을 사용합니다.