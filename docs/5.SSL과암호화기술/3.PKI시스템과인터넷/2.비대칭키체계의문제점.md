## PKI 시스템과 인터넷 - 비대칭키 체계의 문제점

**공개키 신뢰성 문제**

**PC 입장에서는 항상 이 인터넷이라는 공간에 항상 착한 사람만 존재하지는 않는다. 악의적으로 누군가 작정하고 PC든 서버든 공격을 할 수가 있는데 그렇게 되면 서버에서 보내준 거라고 PC측에서 스스로 판단한다. 즉, 서버측에서 전달해준 Public Key를 내가 믿어도 되는가? 신뢰해도 되는가? 아무런 검증 없이 나랑 통신하는데 서버라고 날아온 퍼블릭 키를 믿고 세션키를 전달해도 되는 것일까?**

```
공개키 신뢰성의 근본적 딜레마

시나리오: PC가 은행 서버와 통신
┌─────────────────────────────────┐
│PC의 의문:                      │
│"이 공개키가 정말 우리은행 것일까?"│
│                                │
│받은 공개키 정보:               │
│- RSA 2048비트 키               │
│- 발행일: 2024.01.01           │
│- 만료일: 2025.01.01           │
│                               │
│문제:                          │
│❌ 발신자 신원 확인 불가        │
│❌ 키 유효성 검증 불가          │
│❌ 변조 여부 확인 불가          │
└─────────────────────────────────┘

이것이 바로 "Trust Anchor" 문제
→ 누구를 신뢰할 것인가?
```

**중간자 공격 (MITM: Man In The Middle)**

**이런 점들을 노리고 해커들이 MITM(Man In the Middle)이라는 중간자 공격을 한다.**

메모의 설명을 보완하여 MITM 공격 과정을 상세히 분석해보겠습니다:

```
중간자 공격 (MITM) 상세 분석

정상적인 통신:
PC ←─────── 직접 통신 ─────────→ 서버

중간자 공격 상황:
PC ←──── 해커 ────→ 해커 ←──── 서버
     (가짜 서버)      (가짜 PC)
```

**그래서 PC와 서버가 있다면 둘 간의 통신할 수 있는 경로가 있을 텐데 그 경로에 해커가 중간에 침입하여 해커를 거쳐서 통신하게끔 처리한다.**

```
MITM 공격의 단계별 과정

1단계: 네트워크 위치 점령
┌─────────────────────────────────┐
│해커의 네트워크 침투 방법:       │
│• ARP 스푸핑 (로컬 네트워크)     │
│• DNS 스푸핑 (도메인 변조)       │
│• 라우팅 테이블 조작            │
│• 악성 Wi-Fi 핫스팟 운영        │
│• BGP 하이재킹 (ISP 수준)       │
└─────────────────────────────────┘

2단계: 트래픽 가로채기
┌─────────────────────────────────┐
│PC의 요청: "bank.com 연결 원함"  │
│        ↓ (해커가 중간에서 가로채기) │
│해커 서버: "나는 bank.com이야"   │
│        ↓                       │
│PC: "아, bank.com이 응답했구나"  │
└─────────────────────────────────┘
```

**키 교환 과정에서의 공격**

**그래서 서버가 한 쌍의 키를 만들고 PC쪽에서 대칭키를 만들어서 서버의 공개키로 대칭키를 암호화해서 전달하려고 할 때 그 중간에서 해커 또한 한 쌍의 키를 만든다. 그래서 서버측이 공개키를 전달할 때 중간에서 자신이 만든 해커의 공개키를 대신 전달하고 서버측 공개키를 탈취한다.**

```
키 교환 공격 시나리오

정상적인 키 교환 과정:
┌─────────────────────────────────┐
│1. 서버가 키쌍 생성:             │
│   Server_Private, Server_Public │
│                                │
│2. 서버가 PC에 공개키 전송:      │
│   Server_Public → PC           │
│                                │
│3. PC가 대칭키 생성 및 암호화:   │
│   SessionKey + Server_Public → 암호문│
│                                │
│4. PC가 암호화된 세션키 전송:    │
│   암호문 → 서버                │
│                                │
│5. 서버가 세션키 복호화:         │
│   암호문 + Server_Private → SessionKey│
└─────────────────────────────────┘

해커의 개입 (MITM):
┌─────────────────────────────────┐
│1. 해커도 키쌍 생성:             │
│   Hacker_Private, Hacker_Public │
│                                │
│2. 해커가 서버 공개키 차단하고   │
│   자신의 공개키를 PC에 전송:    │
│   Hacker_Public → PC           │
│                                │
│3. PC는 해커 키를 서버 키로 착각: │
│   SessionKey + Hacker_Public → 암호문│
│                                │
│4. 해커가 세션키 탈취:           │
│   암호문 + Hacker_Private → SessionKey│
│                                │
│5. 해커가 서버에 재암호화 전송:  │
│   SessionKey + Server_Public → 서버│
└─────────────────────────────────┘
```

**그래서 PC측에서는 해커의 공개키를 마치 서버의 공개키라고 착각하게 된다. 아무런 검증 없이 세션키를 전달하게 되면 중간에 해커가 세션키를 탈취하고 다시 서버측 키로 암호화해서 서버에 전달한다.**

**MITM 공격의 결과**

```
공격 성공 후 해커의 능력

완전한 통신 통제:
┌─────────────────────────────────┐
│해커가 할 수 있는 것:           │
│                               │
│✅ 모든 통신 내용 도청          │
│• 패스워드, 개인정보, 기밀문서  │
│• 실시간 통신 내용 확인         │
│                               │
│✅ 통신 내용 변조              │
│• "입금 1만원" → "입금 100만원" │
│• 계약 조건 은밀하게 수정       │
│                               │
│✅ 가짜 정보 주입              │
│• 피싱 페이지로 리다이렉트      │
│• 악성코드 포함 파일 전송       │
│                               │
│✅ 세션 하이재킹               │
│• 사용자 권한으로 무단 행위     │
│• 금융 거래 무단 실행          │
└─────────────────────────────────┘

피해자의 관점:
┌─────────────────────────────────┐
│PC 사용자:                      │
│"모든 게 정상적으로 작동하는 것 같은데?"│
│→ 공격 사실을 전혀 인지 못함    │
│                               │
│서버 관리자:                    │
│"클라이언트와 정상 통신 중..."   │
│→ 역시 공격 사실을 인지 못함    │
│                               │
│결과: 완벽한 은밀 공격 성공     │
└─────────────────────────────────┘
```

**검증의 필요성**

**그래서 원격지에서 키를 보내면 PC측에서는 반드시 이를 검증해야 한다.**

```
공개키 검증의 필수 요소

검증해야 할 사항:
┌─────────────────────────────────┐
│1️⃣ 신원 확인 (Identity)         │
│"이 공개키의 소유자가 누구인가?" │
│                               │
│2️⃣ 무결성 확인 (Integrity)      │
│"이 공개키가 변조되지 않았는가?" │
│                               │
│3️⃣ 유효성 확인 (Validity)       │
│"이 공개키가 아직 유효한가?"    │
│                               │
│4️⃣ 권한 확인 (Authority)        │
│"이 공개키를 누가 보증하는가?"  │
└─────────────────────────────────┘

현실적인 문제:
┌─────────────────────────────────┐
│❌ PC 혼자서는 검증 불가능       │
│• 서버와 직접 만난 적 없음      │
│• 사전 공유된 정보 없음         │
│• 신뢰할 수 있는 기준점 부재    │
│                               │
│❌ 서버도 스스로 증명 불가능     │
│• "나는 진짜 은행이야!" 주장    │
│• 해커도 동일한 주장 가능       │
│• 자기 증명의 순환 논리         │
└─────────────────────────────────┘
```

### 해결책의 방향성

이러한 문제를 해결하기 위해 등장한 것이 바로 **디지털 인증서와 인증기관(CA) 시스템**입니다:

```
PKI 솔루션의 방향성

문제 해결 접근법:
┌─────────────────────────────────┐
│🏛️ 제3자 신뢰기관 도입           │
│• 인증기관 (Certificate Authority)│
│• 신뢰할 수 있는 중립적 기관    │
│• 정부, 국제기구, 유명 기업     │
│                               │
│📜 디지털 인증서 발급            │
│• 공개키 + 신원정보 + CA 서명   │
│• 변조 불가능한 증명서          │
│• 유효기간 및 용도 명시         │
│                               │
│🔗 신뢰 체인 구축               │
│• 루트 CA → 중간 CA → 최종 인증서│
│• 계층적 신뢰 구조              │
│• 브라우저/OS에 루트 CA 내장    │
└─────────────────────────────────┘
```

중간자 공격은 **비대칭키 암호화의 수학적 보안성과는 별개로 발생하는 "신뢰"의 문제**입니다. 아무리 강력한 암호화 알고리즘을 사용해도 **잘못된 상대방과 통신하면 모든 보안이 무의미**해집니다. 이것이 바로 **PKI 인프라와 디지털 인증서 시스템이 필수적인 이유**입니다.