## PKI 시스템과 인터넷 - 인터넷을 위한 비대칭 체계

**대칭키 시스템의 인터넷 환경 한계**

**이 대칭키 시스템은 인터넷 환경에서 심각한 문제가 있다. 이 Key라는 것도 단순한 정보이다. 그래서 네트워크로 송신할 수도 있고 수신할 수도 있고 USB 같은 데 저장할 수도 있다. 그래서 이 자체가 노출되면 안 되는데 대칭키와 같은 경우는 이 키 하나로 보안성을 부여하고 해제하는 것, 즉 암호화 복호화를 하나의 키로 하게 된다.**

```
대칭키의 인터넷 환경 딜레마

시나리오: PC가 서버와 비밀 통신 원함
┌─────────────────────────────────┐
│             public              │
│                                │
│PC -------- 인터넷 ------- 서버  │
│                                │
│문서 → 암호화 ────────→ 복호화   │
│        ↓                       │
│    Symmetric Key 필요!          │
└─────────────────────────────────┘

근본적 문제:
❌ 키를 어떻게 안전하게 전달할까?
❌ 인터넷 = 공개 네트워크 = 도청 가능
❌ 키 노출 = 전체 통신 보안 붕괴
❌ 사전에 물리적 키 교환 = 비현실적

결론: 인터넷 환경에서 대칭키만으로는 해결 불가능
```

**어떤 PC가 서버와 비밀 통신을 하고 싶다. 근데 이 인터넷이라는 구간은 퍼블릭한 곳이기 때문에 private한 정보가 인터넷에 노출되면 그건 보안 사고이다. 그래서 중요한 문서를 암호화해서 서버에 전달하는데 이때 어떻게 하면 이 키를 안전하게 전달할 수 있을까? 정답은 안전하게 보낼 수 있는 방법은 없다. 그래서 대칭키는 인터넷 환경에서 부적합하다라는 생각을 하게 되었다.**

**비대칭키 체계의 등장**

**그래서 이를 해결하기 위한 대안이 비대칭키 체계이다.**

```
비대칭키를 통한 문제 해결

                     public
PC ---------------  인터넷 ------------- 서버
PC Private                            Server Public
PC Public(공개)                        Server Private

      Server Public  <--- 키교환 --->  PC Public     
          암호화                        복호화
          
평문 ────→ 암호문 ── 터널 ─── 암호문 ────→ 평문
```

**PC와 서버가 비밀 통신을 한다고 했을 때 PC와 서버 각각 키를 생성한다.(Private Key와 Public Key) 그다음에 인터넷에서 이 키를 교환한다. 즉 상대방에게 공개키를 전송한다. 즉 PC는 서버에게 이 키가 내 공개키야라고 보내면 서버는 그래? 이 키는 서버측 공개키야 하고 PC에게 서버측 공개키를 보낸다.**

```
비대칭키 통신 과정 상세

1단계: 키 쌍 생성
┌─────────────────────────────────┐
│PC측:                           │
│• PC_Private (비공개, PC만 보관) │
│• PC_Public (공개 가능)          │
│                                │
│서버측:                         │
│• Server_Private (비공개, 서버만)│
│• Server_Public (공개 가능)      │
└─────────────────────────────────┘

2단계: 공개키 교환 (인터넷을 통해 안전하게 가능)
┌─────────────────────────────────┐
│PC → 서버: "내 공개키는 PC_Public"│
│서버 → PC: "내 공개키는 Server_Public"│
│                                │
│📡 인터넷으로 전송되어도 안전    │
│   (공개키니까 노출되어도 괜찮음) │
└─────────────────────────────────┘

3단계: 암호화 통신
┌─────────────────────────────────┐
│PC→서버 전송시:                 │
│평문 → Server_Public로 암호화    │
│     → 서버가 Server_Private로 복호화│
│                                │
│서버→PC 전송시:                 │
│평문 → PC_Public로 암호화        │
│     → PC가 PC_Private로 복호화  │
└─────────────────────────────────┘
```

**보안 터널의 형성**

**이때 터널링을 하려고 평문을 암호화해서 서버측에 전달하려고 할 때 무엇으로 암호화를 하느냐 하면 교환받은 서버측 공개키를 가지고 암호화를 진행한다. 그러면 서버는 Private Key를 가지고 암호문을 복호화해서 평문으로 만든다. 반대로 서버가 PC측으로 데이터를 보낼 때는 PC측에서 전달받은 공개키로 암호화를 진행한다.**

```
보안 터널 (Secure Tunnel) 형성

터널의 개념:
┌─────────────────────────────────┐
│        물리적 네트워크          │
│  PC ═══════════════════ 서버   │
│       (인터넷, 공개망)         │
│                                │
│        논리적 보안 터널         │
│  PC ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 서버   │
│      (암호화된 통신 채널)      │
└─────────────────────────────────┘

터널의 특성:
✅ 외부에서 내용 확인 불가능 (암호화)
✅ 양방향 보안 통신 가능
✅ 데이터 무결성 보장
✅ 송수신자 인증 가능
```

**그래서 암호화를 통해 비밀 통신을 한 구간을 비밀통신채널, 시큐어드 채널이 하나 만들어지는데 암호화로 서로 통신을 주고받는다는 의미에서 암호화 채널이라고 하면 좋은데 이를 터널이라고 명칭해서 부른다.**

**TCP/IP와 보안 세션**

**만약에 TCP/IP 통신을 하고 위와 같이 키 교환을 한 다음에 암호화 통신을 한다. 그때 TCP/IP 통신 세션을 시큐어드 세션 터널이라고 부른다.**

```
TCP/IP 보안 세션의 계층 구조

일반적인 TCP/IP 통신:
┌─────────────────────────────────┐
│응용 계층: HTTP, FTP, SMTP      │
├─────────────────────────────────┤
│전송 계층: TCP, UDP             │
├─────────────────────────────────┤
│네트워크 계층: IP               │
├─────────────────────────────────┤
│데이터링크 계층: Ethernet       │
└─────────────────────────────────┘

보안이 추가된 통신 (예: HTTPS):
┌─────────────────────────────────┐
│응용 계층: HTTP                 │
├─────────────────────────────────┤
│보안 계층: SSL/TLS ← 암호화 터널 │
├─────────────────────────────────┤
│전송 계층: TCP                  │
├─────────────────────────────────┤
│네트워크 계층: IP               │
├─────────────────────────────────┤
│데이터링크 계층: Ethernet       │
└─────────────────────────────────┘

보안 세션의 특징:
✅ 세션 단위 키 관리
✅ 연결 지향적 보안
✅ 상태 유지형 암호화
```

**비대칭키 체계의 한계와 고려사항**

**그래서 비대칭 체계는 대칭키 체계가 효율적이지만 인터넷 환경에서 사용하기에 적절하지 못하기 때문에 그것을 보완하기 위해서 만들어졌다. 여기서 생각해봐야 할 문제는 우리가 가장 처음에 한 Key 한 쌍을 생성하는 게 생각보다 시간이 오래 걸린다. 이 키를 생성할 때 CPU를 상당히 많이 사용한다. 키를 생성할 때마다 1초가 걸린다고 가정하면 여러 곳에서 비밀통신을 할 때마다 키를 생성하면 비효율적일 것이다.**

```
비대칭키의 성능 이슈

키 생성 비용:
┌─────────────────────────────────┐
│RSA-2048 키 쌍 생성:             │
│• 시간: 0.1~2초 (하드웨어 성능별)│
│• CPU 사용률: 90~100%            │
│• 복잡한 수학 연산 (소수 찾기)  │
│                                │
│문제점:                         │
│• 동접자 1000명 = 2000초 필요   │
│• 서버 부하 급증                │
│• 확장성 문제                   │
└─────────────────────────────────┘

암호화/복호화 성능:
┌─────────────────────────────────┐
│AES-256 (대칭키):               │
│• 속도: 수백 MB/s               │
│• 자원: 낮은 CPU 사용률         │
│                                │
│RSA-2048 (비대칭키):            │
│• 속도: 수십 KB/s               │
│• 자원: 높은 CPU 사용률         │
│                                │
│성능 차이: 1000배 이상!         │
└─────────────────────────────────┘
```

**보안상의 추가 고려사항**

**또한 이 공개키를 누군가 취득했을 때 이 공개키를 가지고 어느 정도 Private Key를 유추할 수 있다. 또한 보안에는 유효기간이 있기 때문에 이 기간 동안만 잘 보호하면 된다.**

```
공개키 기반 보안 위험 요소

1️⃣ 중간자 공격 (Man-in-the-Middle)
┌─────────────────────────────────┐
│정상: PC ←→ 서버                │
│공격: PC ←→ 해커 ←→ 서버        │
│                                │
│해커의 행동:                    │
│1. PC에게 가짜 서버 공개키 제공 │
│2. 서버에게 가짜 PC 공개키 제공 │
│3. 모든 통신 중계 및 도청       │
│                                │
│해결책: 인증서를 통한 신원 검증  │
└─────────────────────────────────┘

2️⃣ 키 유효기간 관리
┌─────────────────────────────────┐
│키 생명주기:                    │
│• 생성 → 배포 → 사용 → 갱신 → 폐기│
│                                │
│유효기간 설정 이유:             │
│• 키 노출 위험 최소화           │
│• 암호 기술 발전 대응           │
│• 규정 준수 (법적 요구사항)     │
│                                │
│일반적 유효기간:                │
│• 웹 서버 인증서: 1-2년         │
│• 코드 서명 인증서: 3년         │
│• 루트 CA: 10-30년              │
└─────────────────────────────────┘

3️⃣ 수학적 분석 위험
┌─────────────────────────────────┐
│공개키 분석을 통한 공격 시도:   │
│• 소인수분해 알고리즘 발전      │
│• 양자 컴퓨터 위협              │
│• 사이드 채널 공격              │
│                                │
│대응책:                         │
│• 충분히 긴 키 길이 사용        │
│• 주기적 키 갱신                │
│• 양자 내성 알고리즘 준비       │
└─────────────────────────────────┘
```

### 하이브리드 암호화의 등장

실제로는 비대칭키의 성능 문제를 해결하기 위해 **하이브리드 암호화 방식**이 사용됩니다:

```
하이브리드 암호화 시스템

실제 SSL/TLS에서 사용하는 방식:
┌─────────────────────────────────┐
│1단계: 키 교환 (비대칭키 사용)   │
│PC ←→ 서버: RSA로 세션키 교환    │
│시간: 수백ms (1회만)            │
│                                │
│2단계: 데이터 암호화 (대칭키 사용)│
│PC ←→ 서버: AES로 실제 데이터 암호화│
│시간: 매우 빠름 (지속적)        │
│                                │
│결과:                           │
│✅ 키 분배 문제 해결 (비대칭키) │
│✅ 고성능 암호화 달성 (대칭키)  │
└─────────────────────────────────┘

장점:
✅ 보안성: 비대칭키 수준
✅ 성능: 대칭키 수준
✅ 확장성: 인터넷 규모 지원
✅ 실용성: 현재 표준 방식
```

이렇게 **비대칭키 체계는 인터넷 환경에서 대칭키의 한계를 극복**하는 혁신적 해결책이지만, **성능상의 제약으로 인해 실제로는 하이브리드 방식으로 구현**됩니다. **SSL/TLS가 바로 이러한 원리**로 작동하여 현재 모든 웹 보안의 기반이 되고 있습니다.


### **PKI 시스템과 인터넷 - 혼합 사용으로 효율 극대화하이브리드 암호화 시스템의 구조**

```

			                     public
			PC ---------------  인터넷 ------------- 서버
			PC                                    Server Public
			Symmetric Key                        Server Private

                        터널
Symmetric Key     < -------------->
+ Server Publicy Key로 암호화
          
			평문 ────→ 암호문 ── 터널 ─── 암호문 ────→ 평문

```

### 하이브리드 암호화 과정의 정확한 이해

메모의 설명에서 일부 수정이 필요한 부분이 있습니다. 실제 과정을 정확히 설명하면:

```
실제 하이브리드 암호화 과정

1단계: 서버 키 쌍 준비
┌─────────────────────────────────┐
│서버측:                         │
│• Server_Private (서버만 보관)   │
│• Server_Public (인증서로 배포)  │
└─────────────────────────────────┘

2단계: 세션키 생성 및 교환
┌─────────────────────────────────┐
│실제 방식 (메모와 약간 다름):    │
│                                │
│1. PC가 임시 세션키 생성        │
│   (또는 키 교환 파라미터)      │
│                                │
│2. PC가 Server_Public으로       │
│   세션키 암호화해서 전송       │
│                                │
│3. 서버가 Server_Private으로    │
│   세션키 복호화               │
│                                │
│결과: 양측이 동일한 세션키 공유  │
└─────────────────────────────────┘

3단계: 대칭키로 실제 데이터 암호화
┌─────────────────────────────────┐
│PC → 서버: 세션키로 암호화      │
│서버 → PC: 동일 세션키로 복호화 │
│                                │
│양방향 모두 같은 세션키 사용    │
└─────────────────────────────────┘
```

**PC와 서버가 비밀 통신을 한다고 했을 때 서버측에서는 키 한쌍을 생성한다. 이때 PC쪽에서는 대칭키를 생성한다. 그래서 서버측 공개키, 보안성을 부여하는 키를 PC쪽에 보낸다. 이때 이 키라는 것도 일종의 정보이기 때문에 서버가 보내준 Public Key로 PC쪽 대칭키를 암호화시켜서 전달한다.**

### 세션키의 개념과 특성

**그러면 PC쪽에서 서버가 가진 Private Key로 암호화를 풀어서 PC쪽 대칭키를 추출할 수 있다. 대칭키는 효율이 좋다. 그래서 실제로 어떤 평문을 대칭키로 암호화한 후 서버측에 전달하면 서버측은 이전에 전달받은 대칭키로 평문을 복호화한다. 그래서 이때 PC에서 만든 대칭키를 Session Key라고도 한다.**

```
세션키(Session Key)의 특성

세션키 생성과 관리:
┌─────────────────────────────────┐
│세션키 생성:                    │
│• 연결마다 새로 생성            │
│• 임시적 사용 (세션 종료시 폐기)│
│• 고품질 난수로 생성            │
│                               │
│세션키 크기:                    │
│• AES-128: 128비트              │
│• AES-256: 256비트              │
│• ChaCha20: 256비트             │
└─────────────────────────────────┘

세션키 vs 마스터키:
┌─────────────────────────────────┐
│실제 SSL/TLS에서는:             │
│                               │
│1. 마스터 시크릿 생성           │
│2. 마스터 시크릿에서 여러 키 유도│
│   • 암호화 키 (양방향 각각)    │
│   • MAC 키 (무결성 검증)       │
│   • IV (초기화 벡터)           │
│                               │
│장점: 더 정교한 보안 관리       │
└─────────────────────────────────┘
```

### 다중 클라이언트 환경에서의 보안

**그래서 이 서버와 통신하는 여러 PC가 있고 이 PC마다 고유한 세션키가 있다면 보안성이 더 뛰어나진다.**

```
다중 클라이언트 세션 관리

서버 관점에서의 세션 관리:
┌─────────────────────────────────┐
│서버 (1대)                      │
│├─ 세션1: PC-A ↔ 세션키_A      │
│├─ 세션2: PC-B ↔ 세션키_B      │
│├─ 세션3: PC-C ↔ 세션키_C      │
│└─ ...                          │
│                               │
│각 세션키 특성:                 │
│• 완전히 독립적                │
│• 서로 다른 키값               │
│• 개별적 생명주기              │
└─────────────────────────────────┘

보안상 이점:
┌─────────────────────────────────┐
│1️⃣ 격리된 보안 (Isolated Security)│
│• PC-A 세션키 노출 ≠ PC-B 영향  │
│• 부분적 보안 침해 제한         │
│                               │
│2️⃣ 확장성 (Scalability)        │
│• 동시 접속자 수천명 지원       │
│• 각자 독립적 암호화 채널       │
│                               │
│3️⃣ 감사 추적 (Audit Trail)     │
│• 세션별 로그 관리              │
│• 개별 보안 사고 추적 가능      │
└─────────────────────────────────┘
```

### 하이브리드 암호화의 성능 이점

**이렇게 혼합 사용을 통해 효율을 극대화할 수 있다.**

```
성능 비교 분석

순수 비대칭키 vs 하이브리드:
┌─────────────────────────────────┐
│순수 RSA-2048 방식:             │
│• 1MB 파일 암호화: 30초~수분    │
│• CPU 사용률: 90~100%           │
│• 메모리: 높은 사용량           │
│• 배터리: 급속 소모             │
│                               │
│하이브리드 방식:                │
│• 키 교환: 100~500ms (1회)      │
│• 1MB 파일 암호화: 10~50ms      │
│• CPU 사용률: 5~15%             │
│• 메모리: 효율적 사용           │
│• 배터리: 최소 영향             │
└─────────────────────────────────┘

실제 측정 예시 (1GB 파일):
┌─────────────────────────────────┐
│순수 RSA: 수시간 소요           │
│하이브리드: 1~2초 소요          │
│                               │
│성능 향상: 1000배 이상!         │
└─────────────────────────────────┘
```

### SSL/TLS에서의 실제 구현

```
실제 HTTPS 연결 과정

1단계: TCP 연결 설정
Client ←→ Server: TCP 3-Way Handshake

2단계: SSL/TLS 핸드셰이크
┌─────────────────────────────────┐
│1. Client Hello                 │
│   • 지원 암호화 알고리즘 목록   │
│   • 임시 난수 값               │
│                               │
│2. Server Hello                │
│   • 선택된 암호화 알고리즘     │
│   • 서버 인증서 (공개키 포함)  │
│   • 서버 임시 난수 값          │
│                               │
│3. Key Exchange                │
│   • 클라이언트가 pre-master secret 생성│
│   • 서버 공개키로 암호화해서 전송│
│                               │
│4. Session Key 생성             │
│   • 양측이 동일한 세션키 계산   │
│   • pre-master + 난수값 조합    │
└─────────────────────────────────┘

3단계: 보안 데이터 통신
모든 HTTP 데이터를 세션키로 AES 암호화
```

### 하이브리드 방식의 추가 이점

```
보안과 효율성 외의 이점

1️⃣ 표준화와 호환성
┌─────────────────────────────────┐
│• SSL/TLS 국제 표준             │
│• 모든 브라우저 지원            │
│• 다양한 플랫폼 호환            │
└─────────────────────────────────┘

2️⃣ 유연성과 확장성
┌─────────────────────────────────┐
│• 암호화 알고리즘 교체 가능     │
│• Perfect Forward Secrecy 지원  │
│• 키 길이 조절 가능             │
└─────────────────────────────────┘

3️⃣ 비용 효율성
┌─────────────────────────────────┐
│• 서버 하드웨어 요구사항 절약   │
│• 네트워크 대역폭 효율적 사용   │
│• 클라우드 비용 절감            │
└─────────────────────────────────┘
```

### 보안 강화 기법

```
하이브리드 방식의 보안 강화

Perfect Forward Secrecy (PFS):
┌─────────────────────────────────┐
│• 세션마다 새로운 키 생성       │
│• 과거 세션키 노출되어도 안전   │
│• Ephemeral 키 교환 사용        │
│  (DHE, ECDHE)                 │
└─────────────────────────────────┘

인증서 체인 검증:
┌─────────────────────────────────┐
│• 서버 신원 확인                │
│• 중간자 공격 방지              │
│• CA 계층 구조 활용             │
└─────────────────────────────────┘
```

이렇게 **하이브리드 암호화는 비대칭키의 보안성과 대칭키의 효율성을 모두 얻는** 현실적인 해결책입니다. **현재 모든 웹 보안(HTTPS), VPN, 메신저 보안** 등이 이 원리로 작동하며, **인터넷 보안의 표준**이 되었습니다.