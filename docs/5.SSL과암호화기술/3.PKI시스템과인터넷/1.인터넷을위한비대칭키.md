## PKI 시스템과 인터넷 - 인터넷을 위한 비대칭 체계

**대칭키 시스템의 인터넷 환경 한계**

**이 대칭키 시스템은 인터넷 환경에서 심각한 문제가 있다. 이 Key라는 것도 단순한 정보이다. 그래서 네트워크로 송신할 수도 있고 수신할 수도 있고 USB 같은 데 저장할 수도 있다. 그래서 이 자체가 노출되면 안 되는데 대칭키와 같은 경우는 이 키 하나로 보안성을 부여하고 해제하는 것, 즉 암호화 복호화를 하나의 키로 하게 된다.**

```
대칭키의 인터넷 환경 딜레마

시나리오: PC가 서버와 비밀 통신 원함
┌─────────────────────────────────┐
│             public              │
│                                │
│PC -------- 인터넷 ------- 서버  │
│                                │
│문서 → 암호화 ────────→ 복호화   │
│        ↓                       │
│    Symmetric Key 필요!          │
└─────────────────────────────────┘

근본적 문제:
❌ 키를 어떻게 안전하게 전달할까?
❌ 인터넷 = 공개 네트워크 = 도청 가능
❌ 키 노출 = 전체 통신 보안 붕괴
❌ 사전에 물리적 키 교환 = 비현실적

결론: 인터넷 환경에서 대칭키만으로는 해결 불가능
```

**어떤 PC가 서버와 비밀 통신을 하고 싶다. 근데 이 인터넷이라는 구간은 퍼블릭한 곳이기 때문에 private한 정보가 인터넷에 노출되면 그건 보안 사고이다. 그래서 중요한 문서를 암호화해서 서버에 전달하는데 이때 어떻게 하면 이 키를 안전하게 전달할 수 있을까? 정답은 안전하게 보낼 수 있는 방법은 없다. 그래서 대칭키는 인터넷 환경에서 부적합하다라는 생각을 하게 되었다.**

**비대칭키 체계의 등장**

**그래서 이를 해결하기 위한 대안이 비대칭키 체계이다.**

```
비대칭키를 통한 문제 해결

                     public
PC ---------------  인터넷 ------------- 서버
PC Private                            Server Public
PC Public(공개)                        Server Private

      Server Public  <--- 키교환 --->  PC Public     
          암호화                        복호화
          
평문 ────→ 암호문 ── 터널 ─── 암호문 ────→ 평문
```

**PC와 서버가 비밀 통신을 한다고 했을 때 PC와 서버 각각 키를 생성한다.(Private Key와 Public Key) 그다음에 인터넷에서 이 키를 교환한다. 즉 상대방에게 공개키를 전송한다. 즉 PC는 서버에게 이 키가 내 공개키야라고 보내면 서버는 그래? 이 키는 서버측 공개키야 하고 PC에게 서버측 공개키를 보낸다.**

```
비대칭키 통신 과정 상세

1단계: 키 쌍 생성
┌─────────────────────────────────┐
│PC측:                           │
│• PC_Private (비공개, PC만 보관) │
│• PC_Public (공개 가능)          │
│                                │
│서버측:                         │
│• Server_Private (비공개, 서버만)│
│• Server_Public (공개 가능)      │
└─────────────────────────────────┘

2단계: 공개키 교환 (인터넷을 통해 안전하게 가능)
┌─────────────────────────────────┐
│PC → 서버: "내 공개키는 PC_Public"│
│서버 → PC: "내 공개키는 Server_Public"│
│                                │
│📡 인터넷으로 전송되어도 안전    │
│   (공개키니까 노출되어도 괜찮음) │
└─────────────────────────────────┘

3단계: 암호화 통신
┌─────────────────────────────────┐
│PC→서버 전송시:                 │
│평문 → Server_Public로 암호화    │
│     → 서버가 Server_Private로 복호화│
│                                │
│서버→PC 전송시:                 │
│평문 → PC_Public로 암호화        │
│     → PC가 PC_Private로 복호화  │
└─────────────────────────────────┘
```

**보안 터널의 형성**

**이때 터널링을 하려고 평문을 암호화해서 서버측에 전달하려고 할 때 무엇으로 암호화를 하느냐 하면 교환받은 서버측 공개키를 가지고 암호화를 진행한다. 그러면 서버는 Private Key를 가지고 암호문을 복호화해서 평문으로 만든다. 반대로 서버가 PC측으로 데이터를 보낼 때는 PC측에서 전달받은 공개키로 암호화를 진행한다.**

```
보안 터널 (Secure Tunnel) 형성

터널의 개념:
┌─────────────────────────────────┐
│        물리적 네트워크          │
│  PC ═══════════════════ 서버   │
│       (인터넷, 공개망)         │
│                                │
│        논리적 보안 터널         │
│  PC ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ 서버   │
│      (암호화된 통신 채널)      │
└─────────────────────────────────┘

터널의 특성:
✅ 외부에서 내용 확인 불가능 (암호화)
✅ 양방향 보안 통신 가능
✅ 데이터 무결성 보장
✅ 송수신자 인증 가능
```

**그래서 암호화를 통해 비밀 통신을 한 구간을 비밀통신채널, 시큐어드 채널이 하나 만들어지는데 암호화로 서로 통신을 주고받는다는 의미에서 암호화 채널이라고 하면 좋은데 이를 터널이라고 명칭해서 부른다.**

**TCP/IP와 보안 세션**

**만약에 TCP/IP 통신을 하고 위와 같이 키 교환을 한 다음에 암호화 통신을 한다. 그때 TCP/IP 통신 세션을 시큐어드 세션 터널이라고 부른다.**

```
TCP/IP 보안 세션의 계층 구조

일반적인 TCP/IP 통신:
┌─────────────────────────────────┐
│응용 계층: HTTP, FTP, SMTP      │
├─────────────────────────────────┤
│전송 계층: TCP, UDP             │
├─────────────────────────────────┤
│네트워크 계층: IP               │
├─────────────────────────────────┤
│데이터링크 계층: Ethernet       │
└─────────────────────────────────┘

보안이 추가된 통신 (예: HTTPS):
┌─────────────────────────────────┐
│응용 계층: HTTP                 │
├─────────────────────────────────┤
│보안 계층: SSL/TLS ← 암호화 터널 │
├─────────────────────────────────┤
│전송 계층: TCP                  │
├─────────────────────────────────┤
│네트워크 계층: IP               │
├─────────────────────────────────┤
│데이터링크 계층: Ethernet       │
└─────────────────────────────────┘

보안 세션의 특징:
✅ 세션 단위 키 관리
✅ 연결 지향적 보안
✅ 상태 유지형 암호화
```

**비대칭키 체계의 한계와 고려사항**

**그래서 비대칭 체계는 대칭키 체계가 효율적이지만 인터넷 환경에서 사용하기에 적절하지 못하기 때문에 그것을 보완하기 위해서 만들어졌다. 여기서 생각해봐야 할 문제는 우리가 가장 처음에 한 Key 한 쌍을 생성하는 게 생각보다 시간이 오래 걸린다. 이 키를 생성할 때 CPU를 상당히 많이 사용한다. 키를 생성할 때마다 1초가 걸린다고 가정하면 여러 곳에서 비밀통신을 할 때마다 키를 생성하면 비효율적일 것이다.**

```
비대칭키의 성능 이슈

키 생성 비용:
┌─────────────────────────────────┐
│RSA-2048 키 쌍 생성:             │
│• 시간: 0.1~2초 (하드웨어 성능별)│
│• CPU 사용률: 90~100%            │
│• 복잡한 수학 연산 (소수 찾기)  │
│                                │
│문제점:                         │
│• 동접자 1000명 = 2000초 필요   │
│• 서버 부하 급증                │
│• 확장성 문제                   │
└─────────────────────────────────┘

암호화/복호화 성능:
┌─────────────────────────────────┐
│AES-256 (대칭키):               │
│• 속도: 수백 MB/s               │
│• 자원: 낮은 CPU 사용률         │
│                                │
│RSA-2048 (비대칭키):            │
│• 속도: 수십 KB/s               │
│• 자원: 높은 CPU 사용률         │
│                                │
│성능 차이: 1000배 이상!         │
└─────────────────────────────────┘
```

**보안상의 추가 고려사항**

**또한 이 공개키를 누군가 취득했을 때 이 공개키를 가지고 어느 정도 Private Key를 유추할 수 있다. 또한 보안에는 유효기간이 있기 때문에 이 기간 동안만 잘 보호하면 된다.**

```
공개키 기반 보안 위험 요소

1️⃣ 중간자 공격 (Man-in-the-Middle)
┌─────────────────────────────────┐
│정상: PC ←→ 서버                │
│공격: PC ←→ 해커 ←→ 서버        │
│                                │
│해커의 행동:                    │
│1. PC에게 가짜 서버 공개키 제공 │
│2. 서버에게 가짜 PC 공개키 제공 │
│3. 모든 통신 중계 및 도청       │
│                                │
│해결책: 인증서를 통한 신원 검증  │
└─────────────────────────────────┘

2️⃣ 키 유효기간 관리
┌─────────────────────────────────┐
│키 생명주기:                    │
│• 생성 → 배포 → 사용 → 갱신 → 폐기│
│                                │
│유효기간 설정 이유:             │
│• 키 노출 위험 최소화           │
│• 암호 기술 발전 대응           │
│• 규정 준수 (법적 요구사항)     │
│                                │
│일반적 유효기간:                │
│• 웹 서버 인증서: 1-2년         │
│• 코드 서명 인증서: 3년         │
│• 루트 CA: 10-30년              │
└─────────────────────────────────┘

3️⃣ 수학적 분석 위험
┌─────────────────────────────────┐
│공개키 분석을 통한 공격 시도:   │
│• 소인수분해 알고리즘 발전      │
│• 양자 컴퓨터 위협              │
│• 사이드 채널 공격              │
│                                │
│대응책:                         │
│• 충분히 긴 키 길이 사용        │
│• 주기적 키 갱신                │
│• 양자 내성 알고리즘 준비       │
└─────────────────────────────────┘
```

### 하이브리드 암호화의 등장

실제로는 비대칭키의 성능 문제를 해결하기 위해 **하이브리드 암호화 방식**이 사용됩니다:

```
하이브리드 암호화 시스템

실제 SSL/TLS에서 사용하는 방식:
┌─────────────────────────────────┐
│1단계: 키 교환 (비대칭키 사용)   │
│PC ←→ 서버: RSA로 세션키 교환    │
│시간: 수백ms (1회만)            │
│                                │
│2단계: 데이터 암호화 (대칭키 사용)│
│PC ←→ 서버: AES로 실제 데이터 암호화│
│시간: 매우 빠름 (지속적)        │
│                                │
│결과:                           │
│✅ 키 분배 문제 해결 (비대칭키) │
│✅ 고성능 암호화 달성 (대칭키)  │
└─────────────────────────────────┘

장점:
✅ 보안성: 비대칭키 수준
✅ 성능: 대칭키 수준
✅ 확장성: 인터넷 규모 지원
✅ 실용성: 현재 표준 방식
```

이렇게 **비대칭키 체계는 인터넷 환경에서 대칭키의 한계를 극복**하는 혁신적 해결책이지만, **성능상의 제약으로 인해 실제로는 하이브리드 방식으로 구현**됩니다. **SSL/TLS가 바로 이러한 원리**로 작동하여 현재 모든 웹 보안의 기반이 되고 있습니다.