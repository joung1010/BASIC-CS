# TCP 연결이라는 착각

## 물리적 연결 vs 논리적 연결

TCP/IP로 연결해서 파일 다운로드 중 **LAN 케이블을 분리했다가 다시 연결하면 TCP 연결은 어떻게 될까???**

그러면 이때 연결이 지속되는 것일까 끊어지게 될 것인가에 대해 많은 생각과 고민이 되는 주제일 수도 있다.

```
              Process
                                     OSI 7 Layer
                                   ┌─────────────┐
                                   │Application  │ L7 응용 계층
                                   │Presentation │ L6 표현 계층        
User mode                          │Session      │ L5 세션 계층
─────────────────────────────────────────────────────────────
Kernel mode    ┌─────┐             │             │
               │ TCP │             │TransPort    │ L4 전송 계층
               └─────┘             │             │ 
               ┌─────┐             └─────────────┘
               │ IP  │             ┌─────────────┐
               └─────┘             │Net Work     │ L3 네트워크 계층
S/W            Driver              │             │ 
─────────────────────────────────────────────────────────────
H/W            NIC                 │Data Link    │ L2 데이터 링크 계층
                                   └─────────────┘ 
                                   ┌─────────────┐
                                   │Physical     │ L1 물리 계층
                                   └─────────────┘
```

여기서 연결을 끊었다라고 하면 이 **연결이라는 것은 L4 계층에서 TCP에서 연결**을 말한다. 근데 여기서 내가 **L1 수준에서 LAN 케이블 잠시 뽑은 거**다.

**결론적으로 말하면 TCP 연결은 유지된다**. 물론 이 랜선을 **얼마나 오랫동안 뽑았느냐에 관건**이 있다.

```
계층별 연결 상태 비교:

L1 (물리 계층): 케이블 단절 → 물리적 연결 끊어짐
L2 (데이터 링크): 링크 상태 변화 감지
L3 (네트워크): IP 라우팅 불가 상태
L4 (전송 계층): TCP 연결 상태는 여전히 ESTABLISHED

┌─────────────────────────────────────────────────┐
│ TCP 연결 상태: 논리적 가상 회선                  │
│ ┌─────────────────────────────────────────────┐ │
│ │ Client Socket ←→ Server Socket             │ │
│ │ (메모리에 연결 정보 유지)                   │ │
│ └─────────────────────────────────────────────┘ │
│                                                 │
│ 물리적 상태: 케이블 단절                        │
│ ┌─────────────────────────────────────────────┐ │
│ │ Client ←─ X ─→ Switch ←─ X ─→ Server       │ │
│ └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

## RFC 표준 vs 실제 구현

**RFC라는 표준 문서**가 있는데 거기서 나오는 내용들과 **실제 운영체제의 구현은 이와 다르게 동작**한다.

그래서 이 부분에 대한 **현실적인 판단이 필요**하다. 이러한 차이 때문에 위 상단 프로세스를 개발하는 **소켓 프로그래밍을 하시는 분들은 연결이 되어 있는가에 대해서 지속적으로 검사**를 한다. 3-way handshake로 연결이 이미 끝났을지라도 **계속해서 재차 확인**을 한다. 그래서 이 재확인을 다른 용어로 **Heart Beat**라고 한다.

```
RFC vs 실제 구현 차이:

RFC 표준:
┌─────────────────────────────────────────────────┐
│ • Keep-Alive 간격: 2시간 (7200초)               │
│ • 재전송 간격: 지수적 백오프                     │
│ • 연결 유지 시간: 상당히 긴 시간                 │
└─────────────────────────────────────────────────┘

실제 OS 구현:
┌─────────────────────────────────────────────────┐
│ Linux:                                          │
│ • tcp_keepalive_time: 7200초                    │
│ • tcp_keepalive_intvl: 75초                     │
│ • tcp_keepalive_probes: 9회                     │
│                                                 │
│ Windows:                                        │
│ • KeepAliveTime: 7200초                         │
│ • KeepAliveInterval: 1초                        │
│ • TcpMaxDataRetransmissions: 5회                │
└─────────────────────────────────────────────────┘
```

## Heart Beat의 필요성

그러면 이 **Heart Beat를 왜 하냐** 우리가 휴대폰으로 연결됐다고 하여 상대방과 나에 대한 의사소통이 지속적으로 유지되는 것이 아니기 때문에 이를 위해서 하게 된다.

그래서 가끔 전화가 끊어져도 끊어진 줄 모르고 대화를 하는 경우가 있다. 그래서 이 **연결이 끊어졌다 하여 나의 대화가 끝나지 않는 것처럼 연결은 일정시간 동안 유지**된다.

그래서 **RFC 문서를 보면 상당히 오래 유지가 된다고 말하는데 실제 운영체제에서는 그렇지 않다**.

## 재전송 타이머와 RTO

**재전송 타이머는 기본 근사 값은 대략 3초**이다. 하지만 **실제 대부분 운영체제들은 1초 미만**이다. 즉 서버에서 SYN+ACK를 보냈는데 클라이언트 측에서 ACK가 안 온다. 그러면 서버측에서는 "다시 보내?"라는 판단을 해야 되는데 **대부분 운영체제들은 1초 미만 안에 재전송**을 한다.

이 TCP는 **내부적으로 많은 타이머들이 있는데** RTT가 하는데 어떤 두 호스트 간의 연결 시간을 측정하는데 **3-way handshake를 할 때 이미 SRTT 값이라고 하는 걸 미리 계산해서 얼마나 대기할지에 대한 의사결정**을 할 때 참고하게 된다.

```
TCP 타이머 종류:

1. Retransmission Timer (재전송 타이머):
   ┌─────────────────────────────────────────────┐
   │ RTO = SRTT + 4 × RTTVAR                     │
   │ SRTT: Smoothed Round Trip Time              │
   │ RTTVAR: Round Trip Time Variation           │
   └─────────────────────────────────────────────┘

2. Keep-Alive Timer:
   ┌─────────────────────────────────────────────┐
   │ 연결 상태 확인용                             │
   │ 기본: 2시간 간격                            │
   └─────────────────────────────────────────────┘

3. TIME_WAIT Timer:
   ┌─────────────────────────────────────────────┐
   │ 연결 종료 후 소켓 회수 지연                  │
   │ 2 × MSL (Maximum Segment Lifetime)          │
   └─────────────────────────────────────────────┘

4. Delayed ACK Timer:
   ┌─────────────────────────────────────────────┐
   │ ACK 응답 지연으로 효율성 향상                │
   │ 일반적으로 200ms                            │
   └─────────────────────────────────────────────┘
```

그래서 **재전송 타이머가 만료 후에도 확인 응답을 받지 못한 경우 세그먼트를 재전송하고 RTO(Retransmission Time-Out) 값은 두 배로 증가**한다.

그래서 **LAN 케이블을 1초간 뽑았다가 다시 꼽으면 대부분 파일이 멈췄다가 다시 다운로드 받아진다**.

**L1에서 케이블이 연결되지 않아 이 연결이라는 것을 할 수 없는 상태이지만 L4의 논리적인 연결은 지속**된다.

## 충격 완화 메커니즘

그래서 이러한 상황을 **충격**이라고 하는데 이러한 **충격이 발생하더라도 서비스는 일정 시간동안 원활하게 동작해야만** 한다. 그래서 1초 동안 예를 들어 **IPTV라고 치면 사전에 5초 정도 재생할 수 있는 데이터를 미리 버퍼에 채워둔다**. 이러한 방식으로 **충격에 대한 완화 장치**를 마련한다.

**유선에서는 그렇게 자주 일어나지 않지만 무선에서는 늘상 발생**한다. 예를 들어 지하철을 여러 번 갈아타면 **LTE, 5G 중계기에 여러 번 붙었다가 떨어졌다를 반복해도 실제 우리가 실행하고 있는 동영상은 정상적으로 볼 수 있는 것이 위와 같은 이유** 때문이다.

```
네트워크 충격 완화 전략:

1. 버퍼링 (Buffering):
   ┌─────────────────────────────────────────────┐
   │ 스트리밍 서비스:                             │
   │ • 5-10초 분량 사전 다운로드                  │
   │ • 네트워크 단절 시 버퍼 데이터로 재생 지속   │
   │                                             │
   │ 파일 다운로드:                               │
   │ • 체크포인트 기반 재개                       │
   │ • 다운로드된 부분 보존                       │
   └─────────────────────────────────────────────┘

2. 모바일 환경 대응:
   ┌─────────────────────────────────────────────┐
   │ 기지국 변경 시나리오:                        │
   │ WiFi → LTE → 5G → WiFi 전환                  │
   │                                             │
   │ 대응 방법:                                   │
   │ • IP 주소 변경 감지                          │
   │ • 연결 재설정 자동화                         │
   │ • 세션 복구 메커니즘                         │
   └─────────────────────────────────────────────┘

3. Application Level 복구:
   ┌─────────────────────────────────────────────┐
   │ • 자동 재연결 로직                           │
   │ • 데이터 무결성 검증                         │
   │ • 사용자 경험 최적화                         │
   └─────────────────────────────────────────────┘
```

그래서 **RTO가 초기에 1초였다면 2초 > 4초 > 8초 > 16초 간격으로 재전송한다. 보통 최대 5회 재전송을 시도하고 5회 이상 모두 실패한 경우 전송 오류가 발생**한다.

이러한 **TCP의 재전송 메커니즘과 논리적 연결 특성**을 이해하면 **네트워크 불안정 환경에서도 안정적인 애플리케이션**을 설계할 수 있습니다.

## TCP 연결의 주관적 특성과 보안 한계

그래서 이 **연결은 사실 End-Point 간의 주관적 판단에 불과**하다. TCP 연결에서 **연결을 시작하는 주체와 종료하는 주체가 모두 일반적으로 클라이언트측**이다. 이는 연결의 주도권이 한쪽에 집중되어 있음을 의미한다.

그래서 **서버측에서 SYN+ACK를 전송하고 클라이언트로부터 응답을 받으면 그 순간 연결되었다고 믿게 된다**. 하지만 이는 단순한 추정일 뿐, 실제 상대방의 상태나 중간 네트워크 상황을 보장하지 않는다. 그래서 **TCP의 연결이라고 하는 것에는 근본적인 보안 취약점이 존재**한다고 말한다.

```
TCP 연결의 주관적 판단:

Client 관점:
┌─────────────────────────────────────────────────┐
│ SYN+ACK 수신 → "연결됨!" (주관적 판단)           │
│ 실제로는 서버 상태 확신 불가                     │
│ 중간 네트워크 상태 변화 감지 불가                │
└─────────────────────────────────────────────────┘

Server 관점:  
┌─────────────────────────────────────────────────┐
│ SYN 수신 → "연결 요청 받음!" (주관적 판단)       │
│ 클라이언트가 정말 존재하는지 확신 불가           │
│ 위조된 IP 주소일 가능성 배제 못함                │
└─────────────────────────────────────────────────┘

문제점:
- 양측 모두 상대방 상태를 추측할 뿐
- 실제 물리적/논리적 연결 상태와 무관
- 보안 검증 없이 신뢰 관계 형성
```

## 보안의 3대 요소와 TCP의 취약점

**보안의 3대 요소는 기밀성, 무결성, 가용성**을 말한다:

- **기밀성(Confidentiality)**: 누구나 네트워크 패킷을 도청할 수 있다
- **무결성(Integrity)**: 다른 사람이 송신자 신원을 쉽게 위조할 수 있다
- **가용성(Availability)**: 서비스 거부 공격으로 연결을 쉽게 차단할 수 있다

**이 세 가지 보안 요소가 모두 부족**하다. 그래서 사실 **이 연결이라는 것을 과도하게 신뢰해서는 안 된다**.

```
보안 3대 요소와 TCP 취약점:

1. 기밀성 (Confidentiality) 부족:
┌─────────────────────────────────────────────────┐
│ 문제점: 평문 전송                                │
│ • 패킷 스니핑으로 데이터 노출                    │
│ • 중간자 공격 (Man-in-the-Middle)               │
│                                                 │
│ 공격 예시:                                       │
│ Client ──데이터──→ [공격자 스니핑] ──→ Server    │
│ "사용자ID: admin, PW: 1234" 그대로 노출          │
│                                                 │
│ 대응: TLS/SSL 암호화 필수                        │
└─────────────────────────────────────────────────┘

2. 무결성 (Integrity) 부족:
┌─────────────────────────────────────────────────┐
│ 문제점: 신원 확인 불가                           │
│ • IP 스푸핑 (IP Spoofing)                       │
│ • 세션 하이재킹 (Session Hijacking)             │
│                                                 │
│ 공격 예시:                                       │
│ 공격자가 Client IP(192.168.0.10)로 위장         │
│ → Server가 정상 클라이언트로 오인                │
│ → 권한 없는 접근 허용                            │
│                                                 │
│ 대응: 인증서 기반 상호 인증                      │
└─────────────────────────────────────────────────┘

3. 가용성 (Availability) 부족:
┌─────────────────────────────────────────────────┐
│ 문제점: 서비스 거부 공격 취약                    │
│ • SYN Flooding Attack                           │
│ • Connection Exhaustion                         │
│                                                 │
│ 공격 예시:                                       │
│ 1초에 10,000개 SYN 패킷 전송                     │
│ → 서버 연결 테이블 고갈 (65,535개 한계)          │
│ → 정상 사용자 접속 불가                          │
│                                                 │
│ 대응: SYN Cookie, Rate Limiting                 │
└─────────────────────────────────────────────────┘
```

## 결론

```
TCP 연결의 현실적 이해:

핵심 교훈:
┌─────────────────────────────────────────────────┐
│ TCP 연결 ≠ 안전한 통신                           │
│                                                 │
│ TCP는 단순히 데이터 전달의 편의성을 제공하는     │
│ 추상화 계층일 뿐, 실제 보안과 안정성은           │
│ 상위 계층에서 별도로 보장해야 함                 │
│                                                 │
│ "연결되었다" ≠ "안전하다"                        │
│ "연결되었다" ≠ "신뢰할 수 있다"                  │
└─────────────────────────────────────────────────┘
```

이러한 **TCP 연결의 한계와 보안 취약점**을 이해하면 **방어적 프로그래밍과 다층 보안 설계**의 중요성을 깨닫고, **안전하고 신뢰성 있는 네트워크 애플리케이션**을 구축할 수 있습니다.