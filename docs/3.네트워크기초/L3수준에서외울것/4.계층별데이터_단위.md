## 계층별 데이터 단위

### 계층별 데이터 단위 정리

```
패킷 생성 과정과 데이터 단위:

                              Process(Chrome)
                                 │
                            Stream (무제한)
                                 ↓
User Mode              소켓 인터페이스 (TCP/IP 추상화)
─────────────────────────────────────────────────────
Kernel Mode                    TCP
                                 │
                    Segment [TCP Header][Data] (MSS: 1460 bytes)
                                 ↓  
                                IP
                                 │
              Packet [IP Header][TCP Header][Data] (MTU: 1500 bytes)
                                 ↓
S/W                           Driver
                                 │
     Frame [Frame Header][IP Header][TCP Header][Data] (1518 bytes)
─────────────────────────────────────────────────────
H/W                           NIC
                                 │
                          물리적 신호로 변환
```

### 스트림(Stream)의 특성과 의미

**예를 들어 크롬 브라우저가 인터넷을 통해 데이터를 송수신한다고 했을 때 L1~L2에서 다루는 데이터의 단위를 Frame, L3에서는 packet이고 L4에서는 segment 여기까지가 이제 운영체제 수준에서 관리되는 것이고 위에 이제 user mode에서의 application에서 보자면 가장 먼저 소켓 인터페이스 수준에서 처리하는 데이터의 단위는 스트림이라고 합니다. 우리가 흔히 스트리밍 서비스라고 할 때 사용하는 스트림이랑 같은 말입니다.**

### 스트림의 구체적 의미

```
스트림의 본질적 특성:

물의 흐름(Stream) 비유:
┌─────────────────────────────────────────┐
│ 강물: ～～～～～～～～～～～～～～～～～ │
│ • 시작점: 산에서 발원                   │
│ • 끝점: 바다 (언제 도달할지 모름)      │
│ • 특성: 연속적, 끊어짐 없이 흐름       │
└─────────────────────────────────────────┘

네트워크 스트림:
┌─────────────────────────────────────────┐
│ 데이터: ████████████████████████████… │
│ • 시작점: send() 호출                   │
│ • 끝점: close() 호출 (앱이 결정)        │
│ • 특성: 연속적, 바이트 단위 흐름       │
└─────────────────────────────────────────┘

스트리밍 서비스와의 공통점:
- YouTube 스트리밍: 동영상 데이터가 연속적으로 흐름
- TCP 스트림: 애플리케이션 데이터가 연속적으로 흐름
- 공통 특성: 경계가 없고, 실시간으로 처리됨
```

### 스트림의 크기 문제

**이 스트림은 시작은 존재하는데 그 끝이 언제인지를 정의할 수 없습니다. 그 끝을 정하는 것은 프로세스이고, 프로세스 수준에서 즉 애플리케이션 수준에서 정의해버리기 때문에 데이터를 송수신하는 운영체제 입장에서 이 스트림이라는 연속적으로 이어진 크기를 알 수 없는 큰 데이터입니다.**

### 애플리케이션 vs 운영체제 관점

```
스트림 크기에 대한 서로 다른 관점:

애플리케이션 관점:
┌─────────────────────────────────────────┐
│ Chrome: "10MB 이미지 전송하고 싶어"     │
│ • 전체 크기: 애플리케이션이 알고 있음   │
│ • 시작/끝: 애플리케이션이 결정          │
│ • 처리: send()로 한 번에 전달 가능      │
└─────────────────────────────────────────┘
           ↓ 소켓 인터페이스
┌─────────────────────────────────────────┐
│ 운영체제: "데이터가 들어오고 있네..."   │
│ • 전체 크기: 모름 (스트림이니까)        │
│ • 끝: 언제인지 모름 (앱이 정하는 것)    │
│ • 처리: 받는 대로 조금씩 처리해야 함    │
└─────────────────────────────────────────┘

실제 시나리오:
App: send(socket, image_data, 10MB)
OS:  "10MB? 그건 너무 커! 나눠서 보내야겠다"
```

### 크기 제약과 분할의 필요성

**그래서 소켓이라는 인터페이스에 스트림이라는 데이터 단위를 write하는 것인데 근데 이때 문제는 이 스트림이라는 단위 데이터가 그 끝을 알 수 없고 그 하위 인터넷 패킷에서는 MTU가(대개 1.4KB) 정해져 있습니다. 세그먼트 수준에서도 MSS(Maximum Segment Size 보통 1460 바이트)라고 해서 MTU와 같은 사이즈에 대한 개념이 존재합니다.**

### 크기 제약의 계층적 구조

```
크기 제약의 상하 관계:

Application Layer:
├─ Stream: 무제한 (수 GB도 가능)
└─ 예시: 영화 파일 (4GB), 대용량 첨부파일

Transport Layer (L4):
├─ MSS: 1460 bytes (일반적)
├─ 계산: MTU 1500 - IP Header 20 - TCP Header 20 = 1460
└─ TCP가 스트림을 MSS 단위로 분할

Network Layer (L3):  
├─ MTU: 1500 bytes (Ethernet 표준)
├─ IP Header: 20 bytes (최소)
└─ Payload: 최대 1480 bytes

Data Link Layer (L2):
├─ Frame: 1518 bytes (Ethernet 표준)
├─ Frame Header: 14 bytes + FCS: 4 bytes
└─ Payload: 최대 1500 bytes (= MTU)

크기 관계:
Frame > MTU > MSS
1518 > 1500 > 1460
```

### MSS와 MTU의 관계

```
MSS 계산 공식:

Ethernet Frame (1518 bytes):
┌──────┬────────────────────────────┬─────┐
│ Eth  │         Payload            │ FCS │
│Header│        (1500 bytes)        │     │
│(14)  │                            │ (4) │
└──────┴────────────────────────────┴─────┘

IP Packet (1500 bytes = MTU):
┌────────┬──────────────────────────┐
│   IP   │        Payload           │
│ Header │      (1480 bytes)        │
│  (20)  │                          │
└────────┴──────────────────────────┘

TCP Segment (1480 bytes):
┌────────┬──────────────────────────┐
│  TCP   │        Payload           │
│ Header │      (1460 bytes)        │
│  (20)  │        = MSS             │
└────────┴──────────────────────────┘

따라서: MSS = MTU - IP Header - TCP Header
       1460 = 1500 - 20 - 20
```

### 분할(Segmentation) 과정

**그러면 스트림의 데이터 크기는 당연하게도 이 둘보다 클 수도 있기 때문에 최대 크기보다 커지게 됩니다. 이러한 경우에는 이 스트림을 잘라서 분할합니다. 즉 소켓이 타고 내려와서 TCP를 만나 세그먼트화될 때 즉, segmentation이 될 때 분할이 일어납니다. 즉 스트림이라는 연속적인 데이터를 일정 단위 MSS로 잘라버립니다.**

### 실제 분할 과정

```
10KB 웹페이지 전송 예시:

Original Stream (10,240 bytes):
┌─────────────────────────────────────────┐
│ HTML + CSS + Images = 10,240 bytes     │
│ 하나의 연속된 스트림                    │
└─────────────────────────────────────────┘

TCP Segmentation (MSS = 1460):
Segment 1: [TCP Header][1460 bytes data] (SEQ: 0)
Segment 2: [TCP Header][1460 bytes data] (SEQ: 1460)  
Segment 3: [TCP Header][1460 bytes data] (SEQ: 2920)
Segment 4: [TCP Header][1460 bytes data] (SEQ: 4380)
Segment 5: [TCP Header][1460 bytes data] (SEQ: 5840)
Segment 6: [TCP Header][1460 bytes data] (SEQ: 7300)
Segment 7: [TCP Header][1460 bytes data] (SEQ: 8760)
Segment 8: [TCP Header][20 bytes data]   (SEQ: 10220)

총 8개 세그먼트로 분할:
- 7개 세그먼트: 풀 사이즈 (1460 bytes)
- 1개 세그먼트: 잔여 데이터 (20 bytes)
```

### 분할 후 패킷화

**그래서 그걸 MTU 사이즈에 맞춰서 인터넷 환경에 유통하는 것입니다.**

```
세그먼트 → 패킷 변환:

TCP Segment (1480 bytes):
┌────────┬─────────────────┐
│  TCP   │   1460 bytes    │
│ Header │      Data       │
│  (20)  │                 │
└────────┴─────────────────┘

IP Encapsulation:
┌────────┬────────┬─────────────────┐
│   IP   │  TCP   │   1460 bytes    │
│ Header │ Header │      Data       │
│  (20)  │  (20)  │                 │
└────────┴────────┴─────────────────┘
    Total: 1500 bytes (= MTU)

Ethernet Encapsulation:  
┌──────┬────────┬────────┬─────────────────┬─────┐
│ Eth  │   IP   │  TCP   │   1460 bytes    │ FCS │
│Header│ Header │ Header │      Data       │     │
│ (14) │  (20)  │  (20)  │                 │ (4) │
└──────┴────────┴────────┴─────────────────┴─────┘
    Total: 1518 bytes (Ethernet Frame)
```

### 수신 측에서의 재조립

```
수신 측 처리 과정:

1. Frame 수신 및 Decapsulation:
   [Eth Header] 제거 → IP Packet 추출

2. IP Packet 처리:
   [IP Header] 제거 → TCP Segment 추출

3. TCP Segment 버퍼링:
   SEQ 번호로 순서 확인 및 재조립 대기

4. 스트림 재구성:
   모든 세그먼트 도착 시 원본 스트림 복원

5. 애플리케이션 전달:
   복원된 10KB 웹페이지 데이터를 브라우저에 전달

TCP 재조립 버퍼:
┌─────────────────────────────────────────┐
│ SEQ 0: ✓     SEQ 1460: ✓    SEQ 2920: ✓ │
│ SEQ 4380: ✓  SEQ 5840: ✓    SEQ 7300: ✓ │  
│ SEQ 8760: ✓  SEQ 10220: ✓               │
│ → 모든 세그먼트 수신 완료 → 재조립 시작 │
└─────────────────────────────────────────┘
```

### 핵심 정리

```
계층별 데이터 단위와 크기 제약:

User Mode Application:
├─ 단위: Socket Stream
├─ 크기: 무제한 (애플리케이션이 결정)
└─ 특성: 연속적, 경계 없음

L4 (TCP):
├─ 단위: Segment  
├─ 크기: MSS (1460 bytes)
└─ 기능: 스트림을 MSS 단위로 분할

L3 (IP):
├─ 단위: Packet
├─ 크기: MTU (1500 bytes)  
└─ 기능: 세그먼트에 라우팅 정보 추가

L1~L2 (Ethernet):
├─ 단위: Frame
├─ 크기: 1518 bytes
└─ 기능: 패킷에 물리적 전송 정보 추가

핵심 원리:
- 상위 계층의 큰 데이터를 하위 계층의 제약에 맞춰 분할
- 각 계층은 자신의 책임 범위 내에서만 처리
- 수신 측에서 역순으로 재조립하여 원본 복원
```

이렇게 **계층별 데이터 단위와 크기 제약을 이해**하면, **왜 대용량 파일 전송 시 여러 패킷으로 나뉘어 전송되는지**, 그리고 **각 계층에서 어떤 역할을 담당하는지**를 명확하게 파악할 수 있습니다!