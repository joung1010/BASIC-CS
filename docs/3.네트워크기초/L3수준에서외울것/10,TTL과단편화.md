## TTL과 단편화

### 인터넷의 본질과 라우터

**인터넷은 라우터의 집합체라고 할 수 있는 논리적 네트워크입니다.**

**이 라우터하고 비교해서 생각해봐야 할 것이 L3 스위치입니다. 이 라우터가 L3 스위치의 일종으로 생각하는 경우도 있고 혹은 이 둘을 구분하는 것이 의미가 없다고 하는 사람도 있습니다. 반대로 L3 스위치가 라우터의 일종이다라고 하는 사람이 있습니다.**

```
라우터 vs L3 스위치 구분:

전통적 구분:
┌─────────────────┬─────────────────┐
│ 라우터          │ L3 스위치       │
├─────────────────┼─────────────────┤
│ WAN 연결 중심   │ LAN 연결 중심   │
│ 소프트웨어 기반 │ 하드웨어 기반   │
│ 유연한 기능     │ 고속 처리       │
│ 다양한 프로토콜 │ 주로 이더넷     │
│ 낮은 포트 밀도  │ 높은 포트 밀도  │
└─────────────────┴─────────────────┘

현대적 관점 (경계 모호):
- 멀티레이어 스위치: L2 + L3 + L4~L7 기능
- 소프트웨어 정의 네트워킹 (SDN)
- 클라우드 네이티브 라우팅
- 하드웨어 성능 향상으로 기능 통합
```

### 인터넷의 핵심 구성 요소

**어째든 이제 핵심이 되는 것은 인터넷이라는 네트워크를 이루는 그 핵심적인 구성 요소입니다. 그다음에 인터넷 환경에서 요즘 가장 많이 쓰는 통신 프로토콜인 HTTP입니다. 그래서 DNS라는 서비스 요소가 존재하는데 이 두 가지가 인터넷을 이루고 있는 가장 핵심적인 요소입니다(라우터와 DNS).**

```
인터넷 핵심 구성 요소:

물리적 인프라:
┌─────────────────────────────────────────┐
│ 라우터 (Router)                         │
│ • 패킷 전달 및 경로 결정                │
│ • 인터넷의 물류 센터 역할               │
│ • 글로벌 연결성 제공                    │
└─────────────────────────────────────────┘

논리적 서비스:
┌─────────────────────────────────────────┐
│ DNS (Domain Name System)                │
│ • 도메인 이름 → IP 주소 변환            │
│ • 인터넷의 전화번호부 역할              │
│ • 분산 데이터베이스 시스템              │
└─────────────────────────────────────────┘

응용 프로토콜:
┌─────────────────────────────────────────┐
│ HTTP/HTTPS                              │
│ • 웹 기반 통신의 표준                   │
│ • 현대 인터넷 서비스의 기반             │
│ • RESTful API, 웹 애플리케이션          │
└─────────────────────────────────────────┘
```

### 라우터의 역할과 패킷 중계

**그러면 라우터가 뭐냐 그러면 이 라우터는 택배 기사님이나 물류 센터 역할을 한다고 보면 됩니다.**

**이 라우터가 어떠한 정보 자체를 자신이 수집하는 게 아니라 거쳐가는 존재입니다. 즉 라우터를 거쳐서 다른 라우터로 최종적으로 목적지로 가는 것입니다.**

```
라우터의 중계 역할:

물류 센터 비유:
서울 창고 → 대전 물류센터 → 대구 물류센터 → 부산 창고
   │           │            │           │
발송지      중계점        중계점      목적지

네트워크 실제:
PC → 로컬 라우터 → ISP 라우터 → 백본 라우터 → 목적지 라우터 → 서버
│      │           │          │             │           │
출발   Gateway    지역 ISP   인터넷 백본    목적지 ISP   최종

라우터의 핵심 기능:
1. 패킷 수신 및 분석
2. 라우팅 테이블 검색
3. 최적 경로 결정
4. 다음 홉으로 전달
5. TTL 감소 처리
```

### TTL (Time To Live)의 개념과 동작

**이렇게 이동이 일어나고 통신이 가능한 구조가 됩니다. 이러다 보면 자연스럽게 이 이동의 단위와 함께 TTL(Time to Live)이라는 말이 나오게 됩니다.**

### TTL의 생물학적 비유

**TTL(Time To Live)는 세포의 텔로미어 같은 역할을 합니다. 패킷은 인터넷에서의 어떤 단위이고 이 패킷이 인터넷을 이리저리 돌아다니면서 결국 어떤 목적지까지 가야 됩니다.**

```
TTL의 생명주기 비유:

세포의 텔로미어:
┌─────────────────────────────────────────┐
│ 세포 분열 때마다 텔로미어 단축          │
│ 임계점 도달 시 세포 사멸               │
│ → 무한 증식 방지                       │
└─────────────────────────────────────────┘

패킷의 TTL:
┌─────────────────────────────────────────┐
│ 라우터 통과할 때마다 TTL 감소           │
│ 0 도달 시 패킷 폐기                    │
│ → 무한 순환 방지                       │
└─────────────────────────────────────────┘

공통점:
- 생명 주기 제한
- 무한 상태 방지
- 리소스 보호
- 시스템 안정성 확보
```

### TTL의 필요성과 좀비 패킷 방지

**근데 가끔 어떤 이유로 목적지까지 도달하는데 실패하는 경우가 있습니다. 이 실패했을 때 라우터를 타고 라우팅을 계속하면서 목적지를 찾아가다 끝내 찾지 못하는 경우인데 이럴 때는 무한정 라우팅을 하는 것이 아니라 빠르게 이 패킷을 폐기시키고 버려야지 그러지 않으면 좀비처럼 계속 살아남아 인터넷 세상을 끊임없이 돌아다닐 것입니다. 이러한 현상을 막는 것이 TTL입니다.**

```
TTL이 없다면 발생할 문제:

라우팅 루프 시나리오:
Router A → Router B → Router C → Router A (무한 순환)

좀비 패킷 문제:
┌─────────────────────────────────────────┐
│ 1. 목적지 불분명한 패킷 발생            │
│ 2. 라우터들 간 무한 순환                │
│ 3. 네트워크 자원 지속적 점유            │
│ 4. 대역폭 낭비 및 성능 저하             │
│ 5. 라우터 처리 능력 한계 도달           │
└─────────────────────────────────────────┘

실제 문제 상황:
- 라우팅 테이블 오류
- 네트워크 분할 (Network Partition)
- 라우터 설정 실수
- DDoS 공격으로 인한 경로 혼란
- 일시적 네트워크 장애
```

### Hop과 TTL 감소 메커니즘

**그래서 처음에 보통 128, 255 값으로 시작해서 라우터에서 다른 라우터로 이동할 때마다 그 길이를 Hop이라고 하는데 이 홉 단위로 지나갈 때마다 TTL의 값을 감소시킨 후 다음 라우터에 전송합니다.**

```
TTL 감소 과정:

128            127
R ------------ R
 <    Hop(깡총)  >
        1

전체 TTL 수명 주기:
송신측(TTL=64) → R1(TTL=63) → R2(TTL=62) → ... → 목적지

운영체제별 초기 TTL 값:
┌─────────────────┬─────────────────┐
│ 운영체제        │ 초기 TTL 값     │
├─────────────────┼─────────────────┤
│ Linux           │ 64              │
│ Windows         │ 128             │
│ macOS           │ 64              │
│ Cisco IOS       │ 255             │
│ BSD 계열        │ 64              │
└─────────────────┴─────────────────┘

TTL 기반 OS 핑거프린팅:
ping 응답의 TTL 값으로 원격 시스템 OS 추정 가능
```

### TTL 만료 시 처리

**그래서 이렇게 라우터를 거쳐 TTL 값을 전부 사용했을 때도 목적지에 도달하지 못했다면 결국 실패했다고 간주하고 라우터에서 해당 패킷을 폐기시킵니다. 이때 라우터가 이 패킷을 폐기시켰다는 걸 알려주기도 합니다.**

```
TTL 만료 처리 과정:

1. TTL 감소 확인:
   라우터가 패킷 수신 → TTL 값 1 감소 → TTL = 0?

2. TTL = 0인 경우:
   ┌─────────────────────────────────────────┐
   │ 1. 패킷 즉시 폐기                       │
   │ 2. ICMP Time Exceeded 메시지 생성       │
   │ 3. 원래 송신자에게 오류 통보            │
   └─────────────────────────────────────────┘

3. ICMP Time Exceeded 메시지:
   Type: 11 (Time Exceeded)
   Code: 0 (TTL expired in transit)
   포함 정보: 원본 패킷의 일부

traceroute 동작 원리:
TTL=1로 전송 → 첫 번째 라우터에서 Time Exceeded
TTL=2로 전송 → 두 번째 라우터에서 Time Exceeded
...
목적지까지 경로 추적
```

### 단편화(Fragmentation)의 개념

**그러면 이 TTL 이야기 나오면 반드시 따라 나오는 것이 단편화입니다.**

### MTU 차이로 인한 단편화

**이 단편화는 MTU 크기 차이로 발생합니다. 보통은 1500 bytes의 크기를 가지는데 가끔 이 MTU의 차이 때문에 문제가 발생하는데 예를 들어 수신 MTU 최대 용량이 1400인데 보내는 측에서 1500 bytes씩 계속 보내게 된다면 문제가 발생합니다. 수신 용량보다 큰 데이터가 계속 들어오게 되어서 데이터가 유실될 것입니다.**

### 단편화 발생 시나리오

**그래서 보내는 측에서 이걸 어떻게 보내야 받을까? 고민을 하다가 수신 측이 1400 byte밖에 안 되는 거야? 그럼 둘로 쪼개서 보내! 이렇게 되는 것입니다.**

**그래서 단편화라는 것은 안 그래도 작은 패킷 하나를 또 자르는 게 단편화입니다.**

```
단편화 발생 네트워크 경로:

1500
PC ──L2──│
         │──────────R A
                     │
                     └────────R B
                              │
                              │
                              R ────── R ──────→Server 1500
                              C        D 
                           (MTU 1400)
```

**이때 라우터 C의 MTU가 1400일 때 패킷이 라우터 A와 B까지는 잘 갔다가 C 라우터에 보내려고 보니까 A, B 라우터까지는 MTU 1500이었는데 그다음 D 역시 1500입니다. 근데 경로상에 있는 C가 1400이면 이때 단편화(Fragmentation)가 발생합니다.**

### 단편화 과정과 재조립

### 패킷 분할 과정

```
단편화 과정:

원본 패킷 (1500 bytes):
┌────────┬─────────────────────────────────────┐
│IP 헤더 │         Payload (1480 bytes)        │
└────────┴─────────────────────────────────────┘

단편화 후 (MTU 1400에 맞춤):
┌────────┬─────────────────────────┐
│IP 헤더 │   Payload-1 (1380)     │ Fragment 1
└────────┴─────────────────────────┘

┌────────┬───────────────────┐
│IP 헤더 │ Payload-2 (100)   │ Fragment 2  
└────────┴───────────────────┘

IP 헤더의 단편화 정보:
- Identification: 같은 원본 패킷 식별
- Flags: More Fragments (MF), Don't Fragment (DF)
- Fragment Offset: 원본에서의 위치 (8바이트 단위)
```

**그래서 하나의 패킷의 payload를 둘로 쪼갠 다음에 각각 헤더를 만들어서 붙인 다음 2개의 패킷으로 만듭니다.**

### 단편화 처리 주체

**이렇게 조각난 패킷은 1400보다 작기 때문에 처리할 수 있게 되는 것입니다. B 라우터가 패킷을 단편화하여 C에게 전달합니다. 그래서 A, B로 패킷을 보낼 때는 1개였던 것이 C에서 D로 보낼 때는 2개가 되는 것입니다.**

```
단편화 처리 흐름:

A → B: 1개 패킷 (1500 bytes)
B → C: 2개 패킷 (1400 bytes 이하로 분할)
C → D: 2개 패킷 (그대로 전달)
D → Server: 2개 패킷 (수신측에서 재조립)

단편화 책임:
┌─────────────────────────────────────────┐
│ • 송신측: 경로 MTU 발견 (PMTU Discovery)│
│ • 중간 라우터: 필요시 단편화 수행       │
│ • 수신측: 조각들을 재조립               │
└─────────────────────────────────────────┘

Don't Fragment (DF) 플래그:
- DF = 1: 단편화 금지
- MTU 초과 시 ICMP Fragmentation Needed 응답
- 송신측에서 패킷 크기 조정 필요
```

### 재조립 과정

**그리고 최종적으로 목적지인 서버가 이를 조립하는 것입니다. 이때 중간에 쪼개진 패킷을 다시 조립해주는 장치가 있긴 하지만 그런 게 없다면 수신측 엔드포인트의 IP 프로토콜 스택에서 조립을 하게 됩니다. 그래서 조립된 상태에서 세그먼트를 끄집어내서 TCP에서 데이터를 취합해서 프로세스가 받아서 처리하게 됩니다.**

```
재조립 과정:

수신측 IP 스택에서:
1. Fragment 수신 및 버퍼링:
   ┌─────────────────────────────────────────┐
   │ Identification으로 그룹화               │
   │ Fragment Offset으로 순서 정렬           │
   │ More Fragments 플래그 확인              │
   └─────────────────────────────────────────┘

2. 재조립 타이머:
   • 기본 60초 타임아웃
   • 시간 내 모든 조각 미수신 시 폐기
   • 메모리 누수 방지

3. 완전한 패킷 복원:
   Fragment 1 + Fragment 2 = Original Packet
   ↓
   TCP 계층으로 전달

재조립 문제점:
- 하나의 조각이라도 분실 시 전체 폐기
- 수신측 메모리 사용량 증가
- 처리 지연 시간 발생
- 보안 취약점 (Fragment 공격)
```

### 단편화의 비효율성과 최적화

**이 단편화는 매우 비효율적이기 때문에 최대한 발생하지 않는 것이 좋습니다. 위처럼 중간에 1400 MTU가 있고 이 네트워크가 매우 안정적이고 일정하다면 최초 출발지에서부터 1400으로 보내는 것이 좋습니다.**

```
단편화 비효율성:

성능 영향:
┌─────────────────────────────────────────┐
│ • 패킷 수 증가 → 오버헤드 증가          │
│ • 라우터 처리 부담 가중                 │
│ • 재조립 지연 시간 발생                 │
│ • 한 조각 분실 시 전체 재전송 필요      │
│ • 네트워크 대역폭 비효율적 사용         │
└─────────────────────────────────────────┘

최적화 방법:
1. Path MTU Discovery (PMTU):
   • 경로상 최소 MTU 발견
   • 송신측에서 적절한 크기로 전송

2. MSS Clamping:
   • TCP에서 최대 세그먼트 크기 조정
   • 라우터에서 TCP SYN 패킷 수정

3. Jumbo Frame 사용:
   • 고성능 네트워크에서 9000 bytes MTU
   • 서버-서버 간 대용량 전송 최적화
```

### 현대적 단편화 문제: VPN과 터널링

**근데 최근 PC 성능이 좋기 때문에 1500 밑으로 내려가는 경우는 거의 없습니다. 그러면 어느 경우에 이러한 상황이 발생하냐 하면 바로 VPN이라는 것이 적용됐을 때 특히 IPSec VPN이라는 게 적용되어서 터널링 기술이 적용되면 MTU 사이즈가 줄어드는 경우가 생깁니다.**

```
VPN 터널링과 MTU 축소:

일반 인터넷 연결:
┌────────┬─────────────────┐
│IP 헤더 │   Data (1480)   │ = 1500 bytes
└────────┴─────────────────┘

IPSec VPN 터널링:
┌────────┬─────────┬────────┬─────────────────┐
│새 IP   │IPSec    │원본 IP │   Data (1480)   │ = 1500+ bytes
│헤더    │헤더     │헤더    │                 │
└────────┴─────────┴────────┴─────────────────┘
                              ↑
                         실제 MTU 초과!

VPN 오버헤드:
┌─────────────────┬─────────────────┬─────────────────┐
│ VPN 유형        │ 추가 헤더 크기  │ 유효 MTU        │
├─────────────────┼─────────────────┼─────────────────┤
│ IPSec (ESP)     │ 50-60 bytes     │ 1440-1450       │
│ OpenVPN         │ 60-80 bytes     │ 1420-1440       │
│ WireGuard       │ 32 bytes        │ 1468            │
│ L2TP/IPSec      │ 100+ bytes      │ <1400           │
└─────────────────┴─────────────────┴─────────────────┘

VPN MTU 문제 해결:
1. MTU 조정:
   # 인터페이스 MTU 수동 설정
   ip link set dev tun0 mtu 1400

2. MSS Clamping:
   # iptables로 TCP MSS 조정
   iptables -A FORWARD -p tcp --tcp-flags SYN,RST SYN \
            -j TCPMSS --clamp-mss-to-pmtu

3. PMTU Discovery 활성화:
   # 자동 MTU 발견 기능
   echo 1 > /proc/sys/net/ipv4/ip_forward_use_pmtu
```

### 실무에서의 단편화 문제 해결

```
실제 환경에서의 단편화 트러블슈팅:

문제 진단:
1. 단편화 발생 확인:
   # 단편화 패킷 모니터링
   tcpdump -i any 'ip[6:2] & 0x3fff != 0'
   
2. MTU 크기 확인:
   # 인터페이스별 MTU 확인
   ip link show

3. 경로 MTU 테스트:
   # ping으로 MTU 테스트
   ping -M do -s 1472 target_ip

문제 해결:
1. 송신측 최적화:
   # 애플리케이션 레벨 MTU 설정
   setsockopt(sock, SOL_IP, IP_MTU_DISCOVER, &opt, sizeof(opt));

2. 네트워크 레벨 최적화:
   # 라우터에서 MSS 조정
   ip route add 192.168.1.0/24 via 10.0.0.1 advmss 1360

3. VPN 최적화:
   # OpenVPN 설정
   fragment 1300
   mssfix 1360

모니터링:
# 단편화 통계 확인
cat /proc/net/snmp | grep Frag
netstat -s | grep fragment
```

이렇게 **TTL과 단편화를 이해**하면, **인터넷 라우팅의 핵심 메커니즘을 파악**할 수 있고, **VPN 환경에서의 성능 문제나 MTU 관련 이슈를 효과적으로 해결**할 수 있습니다!