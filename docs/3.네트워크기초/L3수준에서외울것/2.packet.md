### Packet의 기본 개념

**Packet은 기본적으로 어떤 단위 데이터입니다. 즉 어떤 데이터를 감싸서 하나의 단위 데이터로 만들었다는 것이 핵심입니다.**

### 계층별 데이터 단위 구분

```
네트워크 계층별 데이터 단위:

L1 (Physical):   Bit/Signal
                 ├─ 전기 신호
                 ├─ 광 신호  
                 └─ 전자기파

L2 (Data Link):  Frame
                 ├─ 이더넷 프레임
                 ├─ 최대 1518바이트
                 └─ MAC 주소 기반

L3 (Network):    Packet ← 핵심!
                 ├─ IP 패킷
                 ├─ 최대 MTU 크기
                 └─ IP 주소 기반
```

**Packet이라는 말은 L3 IP packet으로 기억하자. 실제로는 packet이라고만 쓰는데 이 packet을 들었을 때 자동적으로 L3 네트워크 계층에 식별자는 IP, 전송 데이터는 packet이 떠올릴 수 있게.**

### Packet의 구조적 특성

### Header와 Payload의 상대적 관계

**이 packet은 크게 Header와 Payload로 나뉘며 이는 상대적인 분류입니다. 앞서 Frame도 이와 비슷한 형태이며 Frame과 다르게 packet은 이 크기가 매우 중요합니다.**

```
계층별 Header/Payload 관계:

상위 계층 관점:
┌─────────────────────────────────────┐
│         HTTP 메시지                 │ ← L7 데이터
└─────────────────────────────────────┘
                ↓ 캡슐화
┌─────────┬───────────────────────────┐
│TCP Header│    HTTP 메시지 (Payload)  │ ← L4에서 보는 관점
└─────────┴───────────────────────────┘
                ↓ 캡슐화  
┌─────────┬───────────────────────────┐
│IP Header│  TCP 전체 (Payload)       │ ← L3에서 보는 관점
└─────────┴───────────────────────────┘
                ↓ 캡슐화
┌─────────┬───────────────────────────┐
│Eth Header│   IP 전체 (Payload)      │ ← L2에서 보는 관점
└─────────┴───────────────────────────┘

상대적 특성:
- L3에서: IP Header + TCP+HTTP (Payload)
- L4에서: TCP Header + HTTP (Payload)  
- L7에서: HTTP Header + 실제 데이터 (Payload)
```

### MTU(Maximum Transmission Unit)의 중요성

**Packet의 최대 크기는 MTU(Maximum Transmission Unit)입니다. 기본적으로는 1500바이트(1.4KB) 정도입니다.**

### MTU 크기 제약과 현실

```
표준 MTU 크기:

Ethernet MTU: 1500 bytes
┌─────────┬───────────────────────────┐
│IP Header│         Payload           │
│(20 bytes)│      (1480 bytes)        │
└─────────┴───────────────────────────┘
<─────────── 1500 bytes ──────────────>

실제 IP 패킷 구조:
┌────┬────┬────┬────┬─────────────────┐
│Ver │IHL │ToS │Len │                 │
├────┼────┼────┼────┤    Payload      │
│ID  │Flags│Frag│TTL │   (1480 bytes)  │
├────┼────┼────┼────┤                 │
│Pro │Checksum│Src IP│                 │  
├────┴────────┴────┴─┤                 │
│   Destination IP   │                 │
└────────────────────┴─────────────────┘
    20 bytes Header      최대 1480 bytes

다양한 네트워크의 MTU:
├─ Ethernet: 1500 bytes (가장 일반적)
├─ PPPoE: 1492 bytes (ADSL 연결)  
├─ 점보 프레임: 9000 bytes (고성능 네트워크)
├─ Token Ring: 4464 bytes (레거시)
└─ 루프백: 65536 bytes (내부 통신)
```

**현재 사회에서 이 정도 크기로는 보낼 수 있는 데이터가 많지 않습니다. 그래서 이 packet을 전체 퍼즐의 하나의 조각 하나라고 생각하면 이해하기 쉽습니다.**

### 패킷 분할(Fragmentation)의 필요성

```
대용량 데이터 전송 시나리오:

10MB 이미지 파일 전송:
원본 파일: 10,485,760 bytes

MTU 1500 bytes로 분할:
┌─────────────────────────────────────┐
│ 패킷 수: 10,485,760 ÷ 1480 ≈ 7,084개 │
│                                     │
│ 패킷 1: [Header][1480 bytes 데이터] │
│ 패킷 2: [Header][1480 bytes 데이터] │
│ 패킷 3: [Header][1480 bytes 데이터] │
│   ...                               │
│ 패킷 7084: [Header][나머지 데이터]   │
└─────────────────────────────────────┘

퍼즐 조각 비유:
- 각 패킷 = 퍼즐 한 조각
- 순서 번호 = 조각 위치 정보
- 목적지에서 재조립 = 퍼즐 완성
- 하나라도 분실 = 전체 그림 깨짐
```

### Header와 Payload의 역할

**그래서 항상 이러한 단위 데이터는 header라고 하는 출발지 목적지 정보와 이 헤더가 실어 나르는 대상을 payload라고 합니다.**

### IP Header의 세부 구조

```
IPv4 Header 상세 분석 (20 bytes):

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├─────────────┬─────────────────┬───────────────────────────────────┤
│Version(4bit)│IHL(4bit)        │Type of Service(8bit)              │
├─────────────┴─────────────────┼───────────────────────────────────┤
│Total Length(16bit)            │Identification(16bit)              │
├───────────────────────────────┼─────────┬─────────────────────────┤
│Flags(3bit)                    │Fragment Offset(13bit)             │
├─────────────┬─────────────────┼─────────┴─────────────────────────┤
│TTL(8bit)    │Protocol(8bit)   │Header Checksum(16bit)             │
├─────────────┴─────────────────┼───────────────────────────────────┤
│Source IP Address(32bit)                                           │
├───────────────────────────────────────────────────────────────────┤
│Destination IP Address(32bit)                                      │
└───────────────────────────────────────────────────────────────────┘

주요 필드 설명:
- Version: IP 버전 (4 = IPv4, 6 = IPv6)
- IHL: Header 길이 (옵션 포함 시 가변)
- Total Length: 전체 패킷 크기 (Header + Payload)
- TTL: 생존 시간 (라우터 홉 제한)  
- Protocol: 상위 프로토콜 (6=TCP, 17=UDP)
- Source/Dest IP: 출발지/목적지 주소
```

### Payload의 다양한 내용

```
IP Payload의 종류:

TCP 세그먼트:
┌─────────┬─────────────────────┐
│IP Header│TCP Header + Data    │
└─────────┴─────────────────────┘
- 신뢰성 있는 연결 지향 통신
- HTTP, HTTPS, FTP, SSH 등

UDP 데이터그램:  
┌─────────┬─────────────────────┐
│IP Header│UDP Header + Data    │
└─────────┴─────────────────────┘
- 빠른 비연결 지향 통신
- DNS, DHCP, 스트리밍 등

ICMP 메시지:
┌─────────┬─────────────────────┐
│IP Header│ICMP Message         │
└─────────┴─────────────────────┘
- 네트워크 진단 및 오류 보고
- ping, traceroute 등

기타 프로토콜:
- GRE (터널링)
- IPSec (보안)  
- OSPF (라우팅)
```

### Wireshark를 통한 Packet 분석

**그러면 이 packet을 실제로 볼 수는 없을까? Wireshark라는 프로그램을 통해 packet을 감청할 수 있습니다.**

### Wireshark 활용법

```
Wireshark 패킷 캡처 예시:

실시간 패킷 모니터링:
┌─────────────────────────────────────────────────┐
│ No. │ Time   │ Source      │ Destination │ Info  │
├─────┼────────┼─────────────┼─────────────┼───────┤
│  1  │ 0.000  │ 192.168.1.10│ 8.8.8.8     │ DNS   │
│  2  │ 0.001  │ 8.8.8.8     │ 192.168.1.10│ DNS   │  
│  3  │ 0.010  │ 192.168.1.10│ 142.250.1.1 │ HTTP  │
│  4  │ 0.015  │ 142.250.1.1 │ 192.168.1.10│ HTTP  │
└─────┴────────┴─────────────┴─────────────┴───────┘

패킷 상세 분석:
Frame 85: 1514 bytes on wire
Ethernet II, Src: aa:bb:cc:dd:ee:ff, Dst: 11:22:33:44:55:66
Internet Protocol Version 4, Src: 192.168.1.10, Dst: 8.8.8.8
    Version: 4
    Header Length: 20 bytes  
    Total Length: 84
    Identification: 0x1234
    Time to live: 64
    Protocol: UDP (17)
User Datagram Protocol, Src Port: 53124, Dst Port: 53
Domain Name System (query)

실제 헥스 덤프:
0000   11 22 33 44 55 66 aa bb cc dd ee ff 08 00 45 00
0010   00 54 12 34 40 00 40 11 b1 e6 c0 a8 01 0a 08 08
0020   08 08 cf 44 00 35 00 40 fe 89 ...
```

### 패킷 분석의 실무 활용

```
네트워크 문제 해결:

1. 연결 문제 진단:
├─ TCP 3-way handshake 확인
├─ SYN, SYN-ACK, ACK 패킷 추적
└─ 연결 실패 원인 파악

2. 성능 문제 분석:
├─ RTT (Round Trip Time) 측정
├─ 패킷 손실률 계산  
├─ 재전송 패킷 확인
└─ 대역폭 사용률 분석

3. 보안 이슈 탐지:
├─ 비정상 트래픽 패턴 발견
├─ DDoS 공격 징후 포착
├─ 악성코드 통신 추적  
└─ 데이터 유출 모니터링

4. 프로토콜 학습:
├─ 실제 프로토콜 동작 관찰
├─ 헤더 구조 직접 확인
├─ 표준 vs 실제 구현 비교
└─ 네트워크 개념 이해 심화
```

### 패킷 캡처 시 주의사항

```
Wireshark 사용 시 고려사항:

법적/윤리적 측면:
├─ 자신의 네트워크에서만 사용
├─ 회사 정책 준수 필요
├─ 개인정보 보호 주의
└─ 패킷 캡처 권한 확인

기술적 측면:
├─ 프로미스큐어스 모드 필요
├─ 스위치 환경에서 제한적  
├─ TAP이나 포트 미러링 활용
└─ 암호화된 트래픽 분석 한계

성능 영향:
├─ 고속 네트워크에서 패킷 손실 가능
├─ 필터링으로 필요한 트래픽만 캡처
├─ 저장 공간 관리 필요
└─ CPU/메모리 사용량 주의
```

이렇게 **Packet은 네트워크 통신의 기본 단위**이며, **MTU 제약으로 인한 분할과 재조립**, 그리고 **Wireshark 같은 도구를 통한 실제 분석**을 통해 네트워크 동작을 깊이 있게 이해할 수 있습니다!


### Encapsulation (인캡슐레이션)

### Encapsulation의 기본 개념

**Packet에 대해 말할 때 항상 따라다니는 용어가 있습니다. 그게 Encapsulation(인캡슐레이션)입니다.**

**뭐 특별한 것은 아니고 우리가 택배를 보낼 때 택배 박스에 전달할 물건을 넣고 택배 박스를 포장합니다. 이러한 과정이 Encapsulation입니다. 마치 러시아 전통 목각 인형인 마트료시카 인형처럼 큰 인형 안에 작은 인형이 나오고 그 인형 안에 또 작은 인형이 나오는 것처럼.**

```
마트료시카 인형 vs 네트워크 Encapsulation:

마트료시카 인형:
┌─────────────────────────────────┐
│     가장 큰 인형 (L2)          │
│  ┌───────────────────────────┐  │
│  │    중간 인형 (L3)         │  │
│  │  ┌─────────────────────┐  │  │
│  │  │   작은 인형 (L4)    │  │  │
│  │  │  ┌───────────────┐  │  │  │
│  │  │  │ 가장 작은 인형│  │  │  │
│  │  │  │   (실제 데이터)│  │  │  │
│  │  │  └───────────────┘  │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘

네트워크 Encapsulation:
┌─────────────────────────────────┐
│      Frame (L2)                │
│  ┌───────────────────────────┐  │
│  │     IP Packet (L3)        │  │
│  │  ┌─────────────────────┐  │  │
│  │  │  TCP Segment (L4)   │  │  │
│  │  │  ┌───────────────┐  │  │  │
│  │  │  │   HTTP Data   │  │  │  │
│  │  │  │  (실제 웹페이지)│  │  │  │
│  │  │  └───────────────┘  │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

### Encapsulation의 보안적 의미

### 데이터 은닉 (Data Hiding)

**즉 이렇게 택배 박스로 포장을 했다는 것은 어떤 박스라는 단위로 데이터를 단위화했다는 것이고 이 포장을 통해서 이 보낼 물건이 어떤 물건일지 모르지만 예를 들어 책을 그냥 보내면 누구나 책인 줄 알지만 이걸 박스에 담아서 포장하면 해당 물건인 책이 실질적으로 보이지 않기 때문에 알 수 없습니다.**

```
택배 포장 vs 네트워크 Encapsulation 보안:

택배 예시:
포장 전: 📖 (누구나 책인 것을 알 수 있음)
    ↓ 포장
포장 후: 📦 (내용물을 알 수 없음)

네트워크 예시:
원본 데이터: "사용자 비밀번호: mypassword123"
    ↓ L7 → L4 (암호화)
SSL 암호화: "A$#kM9@xZq&8mN*vB2..."
    ↓ L4 → L3 (TCP 헤더 추가)
TCP 세그먼트: [TCP Header][암호화된 데이터]
    ↓ L3 → L2 (IP 헤더 추가)  
IP 패킷: [IP Header][TCP Header][암호화된 데이터]
    ↓ L2 → L1 (Ethernet 헤더 추가)
Ethernet 프레임: [Eth Header][IP Header][TCP Header][암호화된 데이터][FCS]

각 계층에서의 보안 효과:
- L2: MAC 주소만 보임, 상위 내용 숨겨짐
- L3: IP 주소만 보임, TCP 내용 숨겨짐  
- L4: 포트만 보임, 실제 데이터 숨겨짐
- L7: 암호화로 실제 내용 완전 보호
```

**이 포장이라는 행위가 보안적으로 봤을 때 실제 보이지 않습니다. 어떤 단위 안에 집어넣어서 보지 못하게 막는다라는 의도가 포함되어 있습니다.**

### 네트워크 Encapsulation 구조

### 계층별 Encapsulation 과정

**그래서 이 Encapsulation을 네트워크에서 보게 된다면:**

```
<─────────── Frame ─────────────────────────────────>
┌─────────┬─────────────────────────────────────────┐
│   L2    │                                         │
│ Header  │              Payload #1                 │
│         │  ┌───────────┬─────────────────────────┐ │
│         │  │    L3     │                         │ │
│         │  │ IP Header │       Payload #2        │ │
│         │  │           │  ┌─────────┬──────────┐ │ │
│         │  │           │  │   L4    │          │ │ │
│         │  │           │  │ Header  │Payload #3│ │ │
│         │  │           │  │         │          │ │ │
│         │  │           │  └─────────┴──────────┘ │ │
│         │  └───────────┴─────────────────────────┘ │
└─────────┴─────────────────────────────────────────┘
```

**그래서 가장 바깥에 있는 포장을 Frame이라고 합니다. 그래서 이 L2 Frame 안에 L3 IP packet이 오게 됩니다.**

### 포함 관계의 명확한 이해

**즉, L3 IP Packet 전체가 L2 Frame의 payload가 되는 것입니다. L2 헤더를 뜯어보면 L3 packet이 나오게 되고 이걸 다시 한 번 더 뜯어보면 L3 payload에 TCP 헤더와 payload가 들어있게 되는 것입니다.**

```
실제 데이터 전송 과정:

송신 측 (Encapsulation):
사용자 데이터: "Hello World"
    ↓ L7→L4 처리
TCP 세그먼트: [TCP Header]["Hello World"]
    ↓ L4→L3 처리  
IP 패킷: [IP Header][TCP Header]["Hello World"]
    ↓ L3→L2 처리
Ethernet 프레임: [Eth Header][IP Header][TCP Header]["Hello World"][FCS]
    ↓ L2→L1 처리
물리적 신호: 전기신호로 변환되어 케이블로 전송

수신 측 (Decapsulation):
물리적 신호 수신
    ↓ L1→L2 처리
Ethernet 프레임 해석: [Eth Header] 제거 → IP 패킷 추출
    ↓ L2→L3 처리
IP 패킷 해석: [IP Header] 제거 → TCP 세그먼트 추출
    ↓ L3→L4 처리
TCP 세그먼트 해석: [TCP Header] 제거 → 데이터 추출
    ↓ L4→L7 처리
최종 데이터: "Hello World" 복원
```

### 계층별 데이터 단위와 한계

### TCP 이후의 구조 변화

**이러한 구조이기 때문에 위에서 러시아 인형을 언급한 것입니다. (TCP의 단위 데이터는 segment입니다) 그러면 L7까지 계속 뜯으면 나오는 것인가 하면 그렇지는 않습니다. TCP를 넘어가면 그 뒤에는 스트림이라고 해서 다른 형식을 논하게 됩니다.**

```
계층별 데이터 단위 정리:

L1 (Physical):     Bit/Signal
L2 (Data Link):    Frame
L3 (Network):      Packet  
L4 (Transport):    Segment (TCP) / Datagram (UDP)
L5+ (Session~):    Stream / Message / Data

L4에서의 분기점:
┌─────────────────────────────────────────┐
│              L4 이후의 처리              │
├─────────────────┬───────────────────────┤
│ TCP 기반        │ UDP 기반              │
│ ├─ Stream 방식  │ ├─ Message 방식       │
│ ├─ 연속된 데이터│ ├─ 개별 메시지        │
│ ├─ HTTP, SSH    │ ├─ DNS, DHCP          │
│ └─ 순서 보장    │ └─ 독립적 전송        │
└─────────────────┴───────────────────────┘

TCP Stream의 특성:
- 바이트 스트림: 경계가 없는 연속된 데이터
- 순서 보장: 보낸 순서대로 도착
- 흐름 제어: 수신 속도에 맞춰 조절
- 오류 검출: 손실 패킷 재전송
```

### 실제 애플리케이션에서의 스트림 처리

```
HTTP 통신 예시:

클라이언트가 웹페이지 요청:
GET /index.html HTTP/1.1
Host: www.example.com
...

이 요청이 TCP 스트림으로 전송:
┌─────────────────────────────────────────┐
│  TCP Stream (연속된 바이트)             │
│  47 45 54 20 2F 69 6E 64 65 78 2E 68... │
│  G  E  T     /  i  n  d  e  x  .  h ... │
└─────────────────────────────────────────┘

TCP는 이를 여러 세그먼트로 분할:
Segment 1: [TCP Header][GET /index.ht]
Segment 2: [TCP Header][ml HTTP/1.1\r\n]  
Segment 3: [TCP Header][Host: www.exa]
...

수신 측에서 스트림 재조립:
각 세그먼트의 TCP 헤더 제거 → 순서대로 합쳐서 → 원본 HTTP 요청 복원
```

### Decapsulation (디캡슐레이션)

**그래서 이렇게 포장을 뜯는 행위를 Decapsulation(디캡슐레이션)이라고 합니다.**

### 라우터와 스위치에서의 Decapsulation

```
네트워크 장비별 처리 수준:

L2 스위치 (Switch):
수신: [Eth Header][IP Packet][FCS]
    ↓ L2 Decapsulation  
처리: Ethernet Header만 확인 (MAC 주소)
    ↓ L2 Encapsulation (다른 포트용)
송신: [새 Eth Header][IP Packet][새 FCS]

L3 라우터 (Router):  
수신: [Eth Header][IP Header][TCP Segment][FCS]
    ↓ L2 Decapsulation
처리 단계 1: Ethernet Header 제거
    ↓ L3 Decapsulation
처리 단계 2: IP Header 확인 (목적지 IP)
    ↓ 라우팅 테이블 검색
    ↓ L3 Encapsulation (새 네트워크용)
송신 준비: [새 IP Header][TCP Segment]
    ↓ L2 Encapsulation (출력 인터페이스용)
송신: [새 Eth Header][새 IP Header][TCP Segment][FCS]

L4 로드밸런서:
수신부터 L4까지 모든 헤더 확인 후 재캡슐화
```

### 종단간(End-to-End) 완전한 Decapsulation

```
최종 목적지에서의 완전한 처리:

웹서버에서 HTTP 요청 처리:
물리적 수신: 전기신호
    ↓ L1→L2
Ethernet 처리: MAC 주소 확인, 헤더 제거
    ↓ L2→L3  
IP 처리: 목적지 IP 확인, 헤더 제거
    ↓ L3→L4
TCP 처리: 포트 확인, 순서 재조립, 헤더 제거
    ↓ L4→L7
HTTP 처리: 실제 웹 요청 내용 파싱
    ↓
웹 애플리케이션: "GET /index.html" 요청 처리

응답도 역순으로 Encapsulation:
웹 애플리케이션: HTML 페이지 생성
    ↓ L7→L4
HTTP 응답: [HTTP Header][HTML Content]
    ↓ L4→L3  
TCP 캡슐화: [TCP Header][HTTP Response]
    ↓ L3→L2
IP 캡슐화: [IP Header][TCP Segment]
    ↓ L2→L1
Ethernet 캡슐화: [Eth Header][IP Packet][FCS]
```

이렇게 **Encapsulation과 Decapsulation은 네트워크 통신의 핵심 메커니즘**이며, **각 계층에서 필요한 정보만 확인하고 나머지는 상위/하위 계층에 위임**하는 **계층화된 설계의 핵심 원리**를 보여줍니다!