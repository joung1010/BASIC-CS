# TCP 연결 과정 (3-way handshaking)

## 3-way handshake 전체 과정

TCP에서 연결이라고 하는 것에 대해서 결론이 나게 되면 그 과정으로 등장하는 것이 **3-way handshaking**이다.

```
                           --------->
                                  RTT (50ms)
                           <--------
Client (192.168.0.10:3000)          Server (192.168.0.20:80)
         │                                    │
         │                                    │ (LISTEN 상태)
    ┌────┴────┐                          ┌────┴────┐
    │ socket()│                          │ socket()│
    │ connect │                          │ bind()  │
    └────┬────┘                          │ listen()│
         │                               │ accept()│
         │                               └────┬────┘
         │                                    │
SYN_SENT │ ①─SYN(seq=100)─────────────────→   │                   
         │                                    │ (SYN-RECEIVED)     
(ESTABLISHED) ←─②─SYN+ACK(seq=200,ack=101)──  │
         │                                    │
         │ ③─ACK(ack=201)────────────────→    │ (ESTABLISHED)       
         │                                    │
         │ ④─데이터(seq=101)───────────────→   │
         │                                    │
         │ ←─⑤─ACK(ack=501)─────────────────  │
         │                                    │
    Time line                              Time line
```

## RTT와 연결 시간

어떤 클라이언트가 있다면 접속 대기중인 서버에 접속을 할 것이다. 클라이언트가 어떤 시점에 서버에게 접속한다고 했을때 먼저 **RTT**이 있을 것이다. 이때 이게 50ms 정도 걸린다고 가정했을때 대략 클라이언트 입장에서 도착하는데 25ms, 다시 오는데 25ms정도 걸렸다는 말인데 이 **SYN부터 SYN+ACK까지의 RTT 시간이 50ms**라는 의미이다. (클라이언트에서 서버측을 갔다가 온 시간)

```
RTT (Round Trip Time) 구성:

Client ──25ms──→ Server
Client ←─25ms─── Server
총 RTT: 50ms

실제 연결 완료까지는 1.5 RTT 소요:
- SYN → SYN+ACK: 1 RTT
- ACK 전송: 0.5 RTT (단방향)
```

## 연결 과정의 세그먼트 구조

그러면 이때 통신되는 단위는 **segment**이다. 근데 이때 재미있는 점은 **연결과정에서 오가는 세그먼트에는 페이로드가 없다**.

```
연결 설정 시 세그먼트 구조:

┌─────────────┬─────────────┬─────────────┐
│ IP 헤더     │ TCP 헤더    │     X       │
│ (20 bytes)  │ (20+ bytes) │ (페이로드 없음)│
└─────────────┴─────────────┴─────────────┘

TCP 헤더 내용:
- Source/Destination Port
- Sequence Number
- Acknowledgment Number  
- Window Size
- MSS (Maximum Segment Size) 옵션
- 기타 TCP 옵션들
```

이런식의 **단순 내부 연결 관리 목적의 세그먼트**가 왔다 갔다 한다.

## 시퀀스 번호 교환 과정

이때 **SYN(Synchronization)** 연결하는 클라이언트 쪽에서 sequence number를 생성한다(랜덤). 그래서 이 시퀀스 번호를 서버 측에 보내고 서버측에서는 클라이언트에서 받은 시퀀스 넘버에 1을 증가시키고 서버측에서도 랜덤하게 시퀀스 넘버를 생성하여 클라이언트측에 같이 전송한다. 그러면 클라이언트가 그걸 수신해서 **ACK(acknowledgement)**를 한번 보내주는데 이때 서버측에서 받은 시퀀스에 1을 증가시켜서 보낸다.

```
시퀀스 번호 교환 상세:

1단계: SYN
Client → Server: SYN, seq=100 (임의의 랜덤값)

2단계: SYN+ACK  
Server → Client: SYN+ACK, seq=200 (서버의 랜덤값), ack=101 (100+1)

3단계: ACK
Client → Server: ACK, ack=201 (200+1)

결과:
- Client 시작 시퀀스: 100
- Server 시작 시퀀스: 200
- 양방향 시퀀스 번호 동기화 완료
```

## 연결 완료 시점의 비대칭성

중요한 것은 **1번에서 2번과 2번에서 3번의 시간차이가 존재**하는데 즉, 클라이언트가 SYN을 보내고 서버측에서 SYN+ACK를 받는 그 순간 **클라이언트는 서버와 연결됐다고 판단**한다. 하지만 그 시점에 **서버는 아직 연결이 완료되었다고 판단하지 않는다**. 최종 클라이언트한테 ACK를 받는 시점에 연결되었다고 판단한다.

```
연결 상태 변화의 비대칭성:

Time    Client State        Server State
 0      CLOSED             LISTEN
 ↓      
25ms    SYN_SENT           LISTEN
 ↓      (SYN 전송)
50ms    ESTABLISHED        SYN_RECEIVED
 ↓      (SYN+ACK 수신)     (SYN 수신)
75ms    ESTABLISHED        ESTABLISHED
        (ACK 전송)         (ACK 수신)

→ 클라이언트가 25ms 먼저 연결 완료 상태가 됨
→ 서버는 ACK 수신 후에야 연결 완료 확인
```

## MSS 협상과 정책 교환

그래서 TCP 연결은 **시퀀스 번호를 교환**한다. 해당 작업이 연결에서 일어나는 가장 중요한 작업이다. 그러면 이때 시퀀스만 교환하지는 않고 **추가적으로 정책들도 교환**한다. 이 정책에서 가장 중요한 정보는 바로 **MSS 값이 얼마인지**를 알려준다. 만약 MSS 1460이면 MTU가 1500이네 하고 정보를 보내는데 서버측에서 "나는 MSS가 1400이야" 그러면 클라이언트는 "확인! 내가 거기에 맞춰서 보내줄게"가 되는 것이다.

```
MSS (Maximum Segment Size) 협상:

Client MSS: 1460 bytes (MTU 1500 - IP헤더20 - TCP헤더20)
Server MSS: 1400 bytes (더 작은 MTU 환경)

협상 결과: min(1460, 1400) = 1400 bytes 사용

추가 협상 정보:
┌─────────────────────────────────────────────────┐
│ • Window Scale Factor (윈도우 크기 확장)        │
│ • Selective ACK (선택적 확인응답)               │
│ • Timestamp Option (지연시간 측정)              │
│ • TCP FastOpen (연결과 동시 데이터 전송)       │
└─────────────────────────────────────────────────┘
```

## 연결의 본질

그래서 **연결이라는 것은 이 프로토콜이 규정하는 관리적 정보를 교환하는 것**이다.

```
TCP 연결에서 교환되는 관리 정보:

필수 정보:
- 초기 시퀀스 번호 (보안 및 순서 관리)
- 윈도우 크기 (흐름 제어)
- MSS 값 (세그먼트 크기 제한)

선택 정보:
- 확장 윈도우 스케일링
- 타임스탬프 옵션  
- SACK (Selective Acknowledgment)
- TCP 압축 옵션

결과:
→ 논리적 가상 회선(Virtual Circuit) 생성
→ 양단간 통신 품질 및 정책 합의
→ 신뢰성 있는 데이터 전송 준비 완료
```

이러한 **3-way handshake 과정**을 통해 TCP는 **신뢰성 있는 연결 지향 통신**의 기반을 마련하게 됩니다.