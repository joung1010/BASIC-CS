## TCP와 UDP

인터넷에서 가장 중요한 프로토콜이라고 할 수 있다.

먼저 TCP하면 연관어로 연결이 항상 따라다닌다. 반대로 UDP는 그렇지 않다.

그러면 이 연결이라는 것은 한글 표기명이고 영문에서는 이 연결이라는 단어가 2가지가 혼재하는데 그게 바로 **Connection**과 **Session**이다.

결과적으로 TCP 연결이다 라고 번역은 되었는데 원문에는 TCP Connection 혹은 TCP Session이라는 말로 되어있을 수 있다. 이 연결이라는 것은 매우 논리적인데 인터넷 역시 논리 네트워크이고 이 논리적이라는 말은 Virtual이라는 말과 혼용되서 사용되고 그래서 이 TCP 연결이 **Virtual Circuit**이라고도 한다.

## TCP 순서번호 시스템

결과적으로 TCP 연결은 순서번호로 구현되어 있는데 만약 첫번째 세그먼트를 받고 그 세그먼트의 크기가 400byte라면 그다음 두번째 세그먼트는 **401번** 이런식으로 순서번호가 증가되어 있다.

```
TCP 순서번호 동작 예시:

첫 번째 세그먼트: 순서번호 1000, 데이터 400바이트
두 번째 세그먼트: 순서번호 1400 (1000 + 400)
세 번째 세그먼트: 순서번호 1700 (1400 + 300바이트 전송)

→ 순서번호는 바이트 단위로 누적 증가
→ 수신측에서 순서 확인 및 재조립 가능
```

## TCP 상태 전이

이 연결은 상태(전이)라는 개념을 동반한다. 간단하게 생각하면 전화를 생각하면 되는데 전화를 걸기전, 전화 수신중, 전화 연결(통화), 통화 종료와 같은 상태를 생각하면 이해하기 쉽다.

```
TCP 11가지 상태:

CLOSED → LISTEN → SYN-RECEIVED → ESTABLISHED → FIN-WAIT → CLOSED
   ↓         ↓           ↓              ↓           ↓
전화기 준비 → 대기 → 신호음 → 통화중 → 끊는 중 → 종료

3-Way Handshake (연결 설정):
Client: SYN → Server
Server: SYN+ACK → Client  
Client: ACK → Server (ESTABLISHED)

4-Way Handshake (연결 종료):
Client: FIN → Server
Server: ACK → Client
Server: FIN → Client
Client: ACK → Server
```

## TCP vs UDP 핵심 차이

TCP는 수신측에서 받을 공간이 부족하면 이를 알리고 송신측에서도 보내지 않는다. 반면 UDP는 일단 보내고 받을 수 있는지 없는지는 나중에 생각한다. 즉 비유적으로 TCP는 배려가 있고 UDP는 배려가 없는데 이 배려하는 것과 하지 않는 것의 내부 구조 차이는 엄청난 차이가 발생한다.

```
TCP의 "배려" 메커니즘:

1. 흐름 제어 (Flow Control):
   수신측 윈도우 크기 확인 → 그만큼만 전송

2. 혼잡 제어 (Congestion Control):
   네트워크 상황 파악 → 전송 속도 조절

3. 에러 제어 (Error Control):
   ACK 확인 → 손실 시 재전송

UDP의 "무배려" 특성:
- 일방적 전송 (Fire and Forget)
- 빠른 속도, 낮은 오버헤드
- 실시간 스트리밍에 적합
```

## 계층별 식별자와 데이터 단위

복습 차원에서 다시 언급한다. L2 수준에서 가장 중요한 식별자는 MAC 주소, L3에서는 IP 주소, 이제 L4로 올라가게 되면 Port가 중요한 식별자가 된다. 데이터 단위도 한번더 확인하고 넘어가자면 L2 수준에서는 Frame, L3는 Packet이고 L4는 TCP 기준으로 Segment이고 UDP는 Datagram이라고 한다.

## 소켓과 스트림

이제 user mode에서 TCP/IP를 추상화한 인터페이스가 **소켓**이 있고 이 소켓은 스트림 단위의 데이터를 처리하고 이 스트림의 특징은 시작은 있는데 그 끝을 계측하기가 어렵다.

```
소켓의 스트림 특성:

Application에서 보낸 메시지: "Hello World!"
TCP 스트림에서는: 연속된 바이트 흐름
수신측에서는: 언제 메시지가 끝나는지 모름

해결 방법:
1. 길이 정보 포함 (Length Prefix)
2. 구분자 사용 (Delimiter)  
3. 고정 길이 메시지
4. 애플리케이션 프로토콜 정의
```

## 포트 번호의 다층적 의미

그리고 이 포트번호는 L2 수준에서는 물리적 인터페이스 번호, L4 수준에서는 서비스의 식별자, Application에서는 프로세스의 식별자라고 한다.

```
포트 번호의 계층별 의미:

L2: 스위치/라우터의 물리적 포트 (1번, 2번 포트)
L4: 서비스 구분 (HTTP:80, HTTPS:443, SSH:22)
Application: 프로세스 식별 (PID와 매핑)

포트 번호 범위:
0-1023: Well-known ports (시스템 예약)
1024-49151: Registered ports  
49152-65535: Dynamic/Private ports (클라이언트 임시 사용)
```

## TCP 클라이언트-서버 구조

TCP는 기본적으로 Client/Server 구성되어 있다. Client는 연결을 하는 주체이고 서버는 이 연결을 기다리고 있다. 그래서 서버는 누군가 외부에서 접속을 할 것이기 때문에 연결을 대기하고 있다.

그래서 클라이언트 프로세스가 소켓을 오픈하는데, 즉 어떤 PID를 가지고 있는 프로세스가 소켓을 생성하고 오픈하면 운영체제는 이 소켓에 대해 TCP 포트 번호를 부여한다. 어떤 번호를 부여하는지는 OS에게 달려있다 - 남는 번호를 부여한다. 즉 연결을 하려는 입장에서는 그렇다.

```
클라이언트 소켓 생성 과정:

1. 프로세스(PID: 1234)가 socket() 시스템 콜 호출
2. OS가 소켓 디스크립터 생성 (예: fd=3)
3. connect() 호출 시 OS가 임시 포트 자동 할당
4. 사용 가능한 포트 중 하나 선택 (예: 35421번)
5. 소켓과 포트 번호 바인딩 완료

결과: 192.168.0.10:35421 → 192.168.0.20:80 연결
```

## 실제 통신 시나리오

```
🤝 TCP 3-Way Handshake + 데이터 전송 플로우

Client (192.168.0.10:3000)          Server (192.168.0.20:80)
         │                                    │
         │                                    │ (LISTEN 상태)
    ┌────┴────┐                          ┌────┴────┐
    │ socket()│                          │ socket()│
    │ connect│                          │ bind()  │
    └────┬────┘                          │ listen()│
         │                               │ accept()│
         │                               └────┬────┘
         │                                    │
         │ ①─SYN(seq=100)─────────────────→   │
         │                                    │ (SYN-RECEIVED)
         │ ←─②─SYN+ACK(seq=200,ack=101)──── │
         │                                    │
    (ESTABLISHED) ③─ACK(ack=201)────────────→│ (ESTABLISHED)
         │                                    │
         │ ④─데이터(seq=101)───────────────→   │
         │                                    │
         │ ←─⑤─ACK(ack=501)─────────────────   │
         │                                    │
         │ ⑥─FIN(seq=501)──────────────────→   │
         │                                    │
         │ ←─⑦─ACK(ack=502)─────────────────   │
         │                                    │
         │ ←─⑧─FIN(seq=300)─────────────────   │
         │                                    │
         │ ⑨─ACK(ack=301)──────────────────→   │
    (CLOSED)                              (CLOSED)
```

이때 client ip가 192.168.0.10이고 운영체제에서 3000번 포트를 소켓에게 부여했다. 서버측 IP가 192.168.0.20이라고 가정한다면 192.168.0.10의 TCP 3000번 포트를 열어서 192.168.0.20번 서버에 접속하는 것이다. 만약 이때 서버가 웹서버이면 기본적으로 TCP 80번 포트를 사용한다.

그래서 Client 측에서 연결을 시도하면 L2 스위치를 거쳐 라우터를 거쳐 gateway 가서 인터넷과 연결되고 목적지인 192.168.0.20인 TCP 80번 포트에 도착하게 될 것이다.

```
네트워크 통신 경로:

Client (192.168.0.10:3000)
    ↓
L2 스위치 (MAC 주소로 전달)
    ↓  
라우터/게이트웨이 (IP 라우팅)
    ↓
인터넷 (여러 라우터 경유)
    ↓
목적지 라우터
    ↓
Server (192.168.0.20:80)

각 홉에서:
- L2: MAC 주소 변경, IP는 유지
- L3: IP 라우팅 테이블 참조
- L4: 포트 번호로 최종 프로세스 식별
```

## 서버의 연결 대기

그래서 이 연결을 대기하는 서버측에서도 소켓을 생성하고 오픈한 다음에 연결을 대기(Listen)한다.

그래서 Listen 상태의 소켓을 열어서 대기하면서 프로세스가 "난 무조건 80번 포트로 열어야만 해"라고 OS에 요청을 하면 OS가 해당 포트가 사용가능하면 그 포트번호로 소켓이 열리고 대기하고 통신이 이루어지는 것이다.

```
서버 소켓 생성 과정:

1. socket() - 소켓 생성
2. bind(80) - 특정 포트에 바인딩 시도
3. listen() - 연결 대기 상태로 전환
4. accept() - 실제 클라이언트 연결 수락

Listen Queue:
- 동시 연결 대기 가능한 클라이언트 수 제한
- backlog 매개변수로 조절
- 큐가 가득 차면 새 연결 요청 거부
```

그래서 TCP/UDP 통신을 하려면 서버측의 IP와 포트를 알아야 연결을 시도해 볼 수 있다.

## 연결 실패 처리

근데 만약 client에서 연결을 요청했는데 서버측에는 프로세스도 없고 소켓도 열려 있지 않으면 서버측 TCP 스택에서 "우리는 지금 연결을 받아줄 수 있는 상태가 아닌데?"라는 응답을 client한테 보내게 된다.

```
연결 실패 시나리오:

상황: 클라이언트가 192.168.0.20:80에 연결 시도
문제: 서버에 웹서버 프로세스가 실행되지 않음

서버 응답:
1. TCP RST(Reset) 패킷 전송
2. "Connection refused" 에러 발생
3. 클라이언트는 즉시 연결 실패 인지

다른 실패 케이스:
- 타임아웃: 서버가 응답하지 않음
- 호스트 도달 불가: 네트워크 경로 문제
- 포트 필터링: 방화벽에서 차단
```
