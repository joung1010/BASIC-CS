# TCP, UDP 헤더 형식

## TCP 헤더 형식

```
TCP 헤더 구조 (20-60 bytes):

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 0 |          Source Port          |       Destination Port       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 4 |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 8 |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
12 |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
16 |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
20 |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

## 포트 번호 범위와 제약

출발지 포트가 **16비트** (2의 16승)이고 값의 범위로만 봤을 때 65535 정도가 된다. 근데 문제는 **포트번호 중에 0번과 65535번은 없다**. 그래서 포트 번호는 **0과 제일 큰 값을 제외하고 사용**하고 있다.

```
포트 번호 사용 범위:

실제 사용 가능: 1 ~ 65534 (총 65534개)
├─ 0번: 예약됨 (사용 불가)
└─ 65535번: 예약됨 (사용 불가)

분류별 포트 범위:
┌─────────────────────────────────────────────────┐
│ 0-1023: Well-Known Ports                       │
│ • HTTP: 80, HTTPS: 443, SSH: 22, FTP: 21      │
│ • Telnet: 23, SMTP: 25, DNS: 53               │
│ • POP3: 110, IMAP: 143, SNMP: 161             │
│                                                 │
│ 1024-49151: Registered Ports                   │
│ • MySQL: 3306, PostgreSQL: 5432               │
│ • Redis: 6379, MongoDB: 27017                 │
│                                                 │
│ 49152-65534: Dynamic/Private Ports             │
│ • 클라이언트 임시 포트 자동 할당                 │
└─────────────────────────────────────────────────┘
```

언급하지 않았지만 포트번호 중에 **well-known 포트**라고 있다. 이 포트번호가 나오면 이 포트번호를 사용하고 있는 소프트웨어가 있기 때문에 예를 들어 네이버에 접속한다고 했을 때 뒤에 **:80, :443과 같은 포트 번호를 별도로 적지 않는다**. 웹은 보통 **TCP 80번**을 사용한다. FTP는 몇 번이고 Telnet은 몇 번이고 이런 것들이 전부 정해져 있다.

## TCP 헤더 주요 필드 설명

그리고 **Sequence Number**는 이전에 3-way handshake 할 때 연결 시에 사용한다. 만약 옵션 말고 데이터를 보낸다고 했을 때 그 길이가 100byte라고 가정하면 이 **sequence는 1씩 증가하는 것이 아니라 데이터의 크기만큼 증가**한다. 따라서 **100이 증가**한다.

```
Sequence Number 동작 예시:

초기 연결 시: seq = 1000 (임의값)
첫 번째 데이터: 100 bytes 전송 → 다음 seq = 1100
두 번째 데이터: 200 bytes 전송 → 다음 seq = 1300
세 번째 데이터: 50 bytes 전송 → 다음 seq = 1350

→ 순서번호는 전송한 바이트 수만큼 증가
→ 수신측에서 순서 및 누락 데이터 확인 가능
```

Offset 다음에 **FLAG 값들**이 쭉 나오는데 **TCP의 상태를 결정할 때 사용**한다. SYN 간다, ACK 온다와 같은 상태에 관한 것이다.

```
TCP FLAG 비트 (6비트):

URG (Urgent): 긴급 데이터 포인터 유효
ACK (Acknowledgment): 확인응답 번호 유효  
PSH (Push): 즉시 상위 계층으로 전달
RST (Reset): 연결 리셋 (강제 종료)
SYN (Synchronize): 연결 설정
FIN (Finish): 연결 종료

주요 조합:
- SYN: 연결 요청
- SYN+ACK: 연결 수락 응답
- ACK: 데이터 확인응답
- FIN+ACK: 정상 종료 요청
- RST: 비정상 종료 (오류 발생)
```

- **FIN**(종료신호)
- **SYN**(연결 신호)
- **RST**(초기화): 뭔가 잘못되어서 연결을 끊자!
- **PUSH**: TCP 통신 시에 바로 즉시 통신하자
- **ACK**(응답 신호)

그 뒤 부분은 **혼잡제어할 때 사용되는 상태 값들**이다. 혼잡제어는 TCP 장애 유형 발생 시 (Loss, Re-Transmission, Duplication-ACK, Out of Order, Zero window) 네트워크가 혼잡하다라고 생각하여 그걸 통제할 때 사용하는 상태 값들이다.

```
TCP 혼잡제어 관련 필드:

Window Size (16비트):
├─ 수신 버퍼의 여유 공간 크기
├─ 흐름제어 (Flow Control)용
└─ 0이면 전송 중단 (Zero Window)

Checksum (16비트):
├─ 헤더 + 데이터 무결성 검사
└─ 오류 검출 시 세그먼트 폐기

Urgent Pointer (16비트):
├─ 긴급 데이터의 위치 지시
└─ URG 플래그와 함께 사용
```

## UDP 헤더 형식

너무 간단하다. **소스 포트, 목적지 포트, 길이와 체크섬이 끝**이다.

```
UDP 헤더 구조 (8 bytes):

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 0 |          Source Port          |       Destination Port       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 4 |            Length             |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

필드 설명:
- Source Port (16비트): 송신측 포트 번호
- Destination Port (16비트): 수신측 포트 번호  
- Length (16비트): UDP 헤더 + 데이터 총 길이
- Checksum (16비트): 오류 검출용 (선택적)
```

## UDP의 "무배려" 특성과 사용 이유

UDP는 **혼잡제어와 같은 것을 일절 하지 않는다**. 수신 측의 버퍼 윈도우 이런 거 신경 쓰지 않는다. 받든지 못받든지 상관하지 않고 서버에서 **일방적으로 보낸다**. 이렇게 **클라이언트 친화적이지 않은 프로토콜**인데 그러면 이렇게 사용해야 할 만한 상황이나 이유가 있는 것일까? 고민해 봐야 한다.

## UDP 사용 사례 1: IPTV 스트리밍

예를 들어 **IPTV**가 있는데 이 IPTV의 영상을 송출해주는 서버가 있다. 그러면 이 서버에 연결되어 있는 수많은 사용자 클라이언트가 있는데 누구는 속도가 빠르고 누구는 평균적이고 누구는 느리고 이러한 여러 다양한 상황일 것이다.

이때 **느린 사람을 기준으로 서버가 송출하게 되면 빠르게 송출받는 클라이언트는 손해**를 보게 될 것이다.

그래서 이러한 것들을 송출할 때는 **클라이언트를 고려하지 않고 빠르게 보내는 것이 좋다**. 오히려 **배려가 민폐**가 될 수 있다.

```
IPTV 스트리밍에서 TCP vs UDP:

TCP 사용 시:
┌─────────────────────────────────────────────────┐
│ 클라이언트 A: 100Mbps (빠름)                    │
│ 클라이언트 B: 50Mbps (보통)                     │
│ 클라이언트 C: 10Mbps (느림)                     │
│                                                 │
│ 결과: 모든 클라이언트가 10Mbps로 제한됨         │
│ → 하향 평준화 현상                              │
└─────────────────────────────────────────────────┘

UDP 사용 시:
┌─────────────────────────────────────────────────┐
│ 서버: 100Mbps로 일괄 전송                       │
│                                                 │
│ 클라이언트 A: 100Mbps 모두 수신 (고화질)        │
│ 클라이언트 B: 50Mbps만 수신 (중화질)            │
│ 클라이언트 C: 10Mbps만 수신 (저화질)            │
│                                                 │
│ 결과: 각자 능력에 맞는 품질로 시청               │
└─────────────────────────────────────────────────┘
```

## UDP 사용 사례 2: 온라인 게임

또 **게임서버**가 이에 해당한다. 만약에 TCP를 이용해서 동기화를 하게 되면 대부분 **하향 평준화**가 된다. 한 유저가 느려지면 전체가 느려질 수밖에 없다. 그래서 **UDP로 게임서버 구현을 많이** 한다.

가끔 게임에서 캐릭터가 이동하다가 중간에 끊기고 다른 지점으로 이동되고 하는 현상을 볼 수 있는데 그것이 왜 그러냐 하면 만약 TCP였다면 이동 거리 중간마다 계속 데이터를 보내고 주고받고 해야 되는데 **UDP는 일단 먼저 보낸다**.

```
온라인 게임에서 TCP vs UDP:

TCP 사용 시:
┌─────────────────────────────────────────────────┐
│ 플레이어 위치 동기화:                            │
│ 위치1 → ACK 대기 → 위치2 → ACK 대기 → 위치3     │
│                                                 │
│ 문제점:                                         │
│ • 느린 플레이어로 인한 전체 지연                 │
│ • 패킷 손실 시 재전송으로 더욱 지연              │
│ • 실시간성 저하                                 │
└─────────────────────────────────────────────────┘

UDP 사용 시:
┌─────────────────────────────────────────────────┐
│ 플레이어 위치 동기화:                            │
│ 위치1 → 위치2 → 위치3 (연속 전송)                │
│                                                 │
│ 특징:                                           │
│ • 즉시 전송, 응답 대기 없음                      │
│ • 일부 패킷 손실되어도 최신 정보로 보정          │
│ • 워프 현상: 중간 위치 손실 → 순간이동 효과      │
└─────────────────────────────────────────────────┘

추가 최적화:
- 중요한 데이터(아이템 획득): TCP 사용
- 실시간 데이터(위치, 채팅): UDP 사용
- 하이브리드 접근법으로 장점 결합
```

이러한 **TCP/UDP 헤더 구조와 특성**을 이해하면 **애플리케이션의 요구사항에 맞는 적절한 프로토콜 선택**과 **네트워크 성능 최적화**를 할 수 있습니다.