# TCP 연결 종료 과정 (4-way handshaking)

## 4-way handshake 전체 과정

당연하게도 연결과정이 있으면 종료과정도 존재한다. 연결보다는 살짝 조금 더 복잡하다. 이때 별다른 일이 없다면 **클라이언트의 행동이 ACTIVE**하다. 이 말은 **연결과 종료의 주체 모두 클라이언트**여야 한다. 만약 서버 측에서 연결을 종료한다고 요청이 온다면 조금 특수한 경우일 것이다.

```
                                   --------->
                                          RTT
                                   <--------
Client (192.168.0.10:3000)          Server (192.168.0.20:80)
         │                                    │
         │                                    │ (ESTABLISHED)
    ┌────┴────┐                          ┌────┴────┐
    │ close() │                          │         │
    └────┬────┘                          │         │
         │                               │         │
         │                               └────┬────┘
         │                                    │
ESTABLISHED │ ①─FIN+ACK─────────────────→     │ ESTABLISHED                    
  FIN_WAIT1 │                                 │ 
         │                                    │ CLOSE_WAIT
         │ ←─②─ACK─────────────────────       │
  FIN_WAIT2 │                                 │
         │ ←─③─FIN+ACK─────────────────       │ LAST_ACK
         │                                    │ 
  TIME_WAIT │ ④─ACK─────────────────────→     │ 
         │                                    │
    CLOSED │                                  │ CLOSED
         │                                    │
    Time line                             Time line
```

## 연결 종료 과정 상세

그래서 연결을 종료한다고 하는 클라이언트는 너무나 당연하게도 **이미 연결이 된 상태여야지만 연결을 끊자고 할 수 있다**.

이때 클라이언트 측에서 연결을 종료하자고 **FIN**을 보낸다.(이때 **ACK도 같이 보낸다**) 서버 측에서는 이를 수신한 다음에 "알았어 연결을 종료하자" 하고 **ACK**를 보낸다. 그다음에 클라이언트 측은 연결에 대한 종료인 FIN을 기다리게 된다. FIN을 기다리는 ACK가 와서 **FIN_WAIT1에서 FIN_WAIT2로 넘어간다**. 이때 넘어가면서 서버측의 **FIN+ACK를 기다린다**. 반대로 서버측에서도 ACK를 클라이언트측에 보냈으니 이에 대한 응답을 기다린다.(**LAST_ACK**)

```
각 단계별 상태 변화:

1단계: FIN 전송
Client: ESTABLISHED → FIN_WAIT1
Server: ESTABLISHED (변화 없음)

2단계: ACK 수신  
Client: FIN_WAIT1 → FIN_WAIT2
Server: ESTABLISHED → CLOSE_WAIT

3단계: FIN 수신
Client: FIN_WAIT2 → TIME_WAIT
Server: CLOSE_WAIT → LAST_ACK

4단계: 최종 ACK
Client: TIME_WAIT → (대기) → CLOSED
Server: LAST_ACK → CLOSED
```

## TIME_WAIT 상태의 중요성

그러면 이때 클라이언트 측에서 FIN+ACK를 받았으면 **TIME_WAIT가 발생**한다. 이 상태가 발생했다는 의미는 **클라이언트가 연결을 끊자고 하는 것**이다. 반대로 서버 측에서 TIME_WAIT가 발생한다면 **서버측에서 연결을 끊자고 하는 것**이다.

그렇게 서버측에서 클라이언트 측으로부터 마지막 ACK를 받으면 비로소 정상적으로 연결이 종료된다.

클라이언트 측에서 TIME_WAIT에서 일정시간이 지나서 CLOSED가 되면 이때 **소켓이 회수**된다.

```
TIME_WAIT가 필요한 이유:

1. 마지막 ACK 손실 대비:
   만약 마지막 ACK가 손실되면?
   → 서버가 FIN을 재전송할 수 있음
   → TIME_WAIT 상태에서 재전송된 FIN에 ACK 응답 가능

2. 지연된 패킷 처리:
   네트워크에서 지연되어 도착하는 패킷들이
   새로운 연결과 혼동되지 않도록 방지

TIME_WAIT 시간: 
일반적으로 2 × MSL (Maximum Segment Lifetime)
리눅스: 60초, 윈도우: 240초
```

## 소켓 자원 관리의 중요성

참고로 이 **소켓은 자원이다. 무한하지 않다**. 그래서 서버같은 경우에는 외부 연결을 많이 받아야 되는 입장에서 **서버가 연결을 끊게 되면 클라이언트 측에서는 TIME_WAIT에서 CLOSED 되는 시간에 대한 낭비가 발생**할 수 있다. 그래서 가급적 **서버는 자신이 연결을 끊는 것이 아니라 클라이언트한테 부탁을 해서 연결을 종료하는 형태로 Application 프로토콜을 설계**해야 한다. 여기서 Application 프로토콜이라고 하면 **L4 위의 소켓 수준에서의 처리**를 말한다.

```
소켓 자원 한계와 TIME_WAIT 문제:

서버에서 연결 종료 시:
┌─────────────────────────────────────────────────┐
│ 서버가 FIN 전송 → 서버에 TIME_WAIT 상태 발생    │
│                                                 │
│ 문제점:                                         │
│ • 서버 소켓이 60초간 TIME_WAIT 상태로 점유      │
│ • 동시 연결 수 제한 (보통 65535개)              │
│ • 새로운 클라이언트 연결 수락 능력 저하          │
└─────────────────────────────────────────────────┘

클라이언트에서 연결 종료 시:
┌─────────────────────────────────────────────────┐
│ 클라이언트가 FIN 전송 → 클라이언트에 TIME_WAIT  │
│                                                 │
│ 장점:                                           │
│ • 서버 소켓은 즉시 해제되어 재사용 가능          │
│ • 서버의 동시 연결 처리 능력 유지                │
│ • 클라이언트는 새 포트로 재연결 가능             │
└─────────────────────────────────────────────────┘
```

## Application 프로토콜 설계 가이드

```
올바른 연결 종료 설계 패턴:

HTTP 프로토콜 예시:
┌─────────────────────────────────────────────────┐
│ 1. 클라이언트가 요청 전송                        │
│ 2. 서버가 응답 전송                             │
│ 3. 서버가 "Connection: close" 헤더 전송         │
│    (종료 신호만 보냄, 실제 FIN은 보내지 않음)   │
│ 4. 클라이언트가 close() 호출 → FIN 전송         │
│ 5. 서버에서 FIN 수신 후 연결 종료 프로세스 시작  │
└─────────────────────────────────────────────────┘

장점:
✅ 서버에 TIME_WAIT 상태 없음
✅ 서버 소켓 자원 즉시 회수
✅ 높은 동시 연결 처리 능력 유지

다른 설계 패턴:
- Keep-Alive: 연결 재사용으로 종료 빈도 감소
- Connection Pooling: 클라이언트 측 연결 관리
- Graceful Shutdown: 점진적 서비스 종료
```

## TCP 연결 상태 다이어그램

```
TCP 상태 전이도 (연결 종료 중심):

    ESTABLISHED
         │
         │ (애플리케이션이 close() 호출)
         ▼
    FIN_WAIT1 ──────────────┐
         │                  │
         │ (ACK 수신)        │ (FIN+ACK 동시 수신)
         ▼                  │
    FIN_WAIT2               │
         │                  │
         │ (FIN 수신)        │
         ▼                  ▼
    TIME_WAIT ◄─────────────┘
         │
         │ (2MSL 타이머 만료)
         ▼
      CLOSED

서버 측:
    ESTABLISHED
         │
         │ (FIN 수신)
         ▼
    CLOSE_WAIT
         │
         │ (애플리케이션이 close() 호출)
         ▼
     LAST_ACK
         │
         │ (ACK 수신)
         ▼
      CLOSED
```

이러한 **4-way handshake 과정과 소켓 자원 관리**를 이해하면 **고성능 서버 애플리케이션 설계**에서 중요한 **연결 관리 전략**을 수립할 수 있습니다.