## IP 헤더 형식

### 기본 크기와 구조

**그래서 이 패킷은 보통 MTU가 1500 바이트이고 헤더 정보는 별다른 옵션이 존재하지 않는다면 20바이트 정도 됩니다. 그래서 payload의 크기는 1480 정도입니다.**

```
표준 MTU 크기:

Ethernet MTU: 1500 bytes
┌─────────┬───────────────────────────┐
│IP Header│         Payload           │
│(20 bytes)│      (1480 bytes)        │
└─────────┴───────────────────────────┘
<─────────── 1500 bytes ──────────────>

실제 IP 패킷 구조:
┌────┬────┬────┬────┬─────────────────┐
│Ver │IHL │ToS │Len │                 │
├────┼────┼────┼────┤    Payload      │
│ID  │Flags│Frag│TTL │   (1480 bytes)  │
├────┼────┼────┼────┤                 │
│Pro │Checksum│Src IP│                 │  
├────┴────────┴────┴─┤                 │
│   Destination IP   │                 │
└────────────────────┴─────────────────┘
    20 bytes Header      최대 1480 bytes
```

### IPv4 헤더 상세 구조

```
IPv4 Header 상세 분석 (20 bytes):

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
├─────────────┬─────────────────┬───────────────────────────────────┤
│Version(4bit)│IHL(4bit)        │Type of Service(8bit)              │
├─────────────┴─────────────────┼───────────────────────────────────┤
│Total Length(16bit)            │Identification(16bit)              │
├───────────────────────────────┼─────────┬─────────────────────────┤
│Flags(3bit)                    │Fragment Offset(13bit)             │
├─────────────┬─────────────────┼─────────┴─────────────────────────┤
│TTL(8bit)    │Protocol(8bit)   │Header Checksum(16bit)             │
├─────────────┴─────────────────┼───────────────────────────────────┤
│Source IP Address(32bit)                                           │
├───────────────────────────────────────────────────────────────────┤
│Destination IP Address(32bit)                                      │
└───────────────────────────────────────────────────────────────────┘
|                  Options (가변)                                   |
|                  Data                                              |
```

### 비트 단위와 진법 체계

**그래서 보통 위처럼 도식화된 그림은 32bit 단위로 데이터를 끊은 것이고, 그래서 8bit는 1byte이고 이 8bit를 4bit의 조합입니다. 4bit 총 2⁴승이다 보니 16가지의 경우가 있습니다. 그래서 16진수로 헤더의 패킷 데이터를 표기합니다.**

```
비트 단위와 진법 관계:

4bit 표현:
0000 = 0 (16진수)    1000 = 8 (16진수)
0001 = 1 (16진수)    1001 = 9 (16진수)  
0010 = 2 (16진수)    1010 = A (16진수)
0011 = 3 (16진수)    1011 = B (16진수)
0100 = 4 (16진수)    1100 = C (16진수)
0101 = 5 (16진수)    1101 = D (16진수)
0110 = 6 (16진수)    1110 = E (16진수)
0111 = 7 (16진수)    1111 = F (16진수)

8bit (1byte) 예시:
이진수: 1101 0011
16진수: D    3     = 0xD3
10진수: 13×16 + 3 = 211

실제 패킷 덤프:
45 00 00 3C 1C 46 40 00 40 06 B1 E6 AC 14 02 0C
│  │  │  │  │  │  │  │  │  │  │  │  │  │  │  │
│  └─ IHL+ToS    │  └─ Flags      │  └─ 출발지 IP
└─ Version       └─ Total Length  └─ Protocol
```

### 주요 헤더 필드 상세 설명

### Version과 IHL

**Version은 IP 버전을 말하는 것이고 IHL은 총 헤더의 길이를 말합니다.**

```
Version 필드 (4bit):
- 값 4: IPv4
- 값 6: IPv6
- 현재 대부분 IPv4 사용

IHL (Internet Header Length) 필드 (4bit):
- 단위: 32bit (4byte) 워드
- 최소값: 5 (5×4 = 20 bytes)
- 최대값: 15 (15×4 = 60 bytes)
- 옵션 필드 포함 시 길이 증가

IHL 계산 예시:
IHL = 5 → 헤더 길이 = 5×4 = 20 bytes (기본)
IHL = 6 → 헤더 길이 = 6×4 = 24 bytes (옵션 4bytes)
IHL = 15 → 헤더 길이 = 15×4 = 60 bytes (옵션 40bytes)
```

### Total Length와 최대 패킷 크기

**여기서 Total Length는 전체 패킷의 크기를 말합니다. 이때 이 Total Length가 16비트로 되어 있는데 나올 수 있는 경우의 수가 2¹⁶ = 65535의 경우의 수입니다. 그래서 IP 패킷은 이론상 헤더 포함해서 64KB가 가장 큰 수입니다.**

```
Total Length 필드 분석:

16bit = 65,536 가지 경우 (0~65535)
따라서 최대 패킷 크기: 65,535 bytes ≈ 64KB

실제 크기 제약:
┌─────────────────────────────────────────┐
│ 이론적 최대: 65,535 bytes               │
│ 실제 제약: MTU (보통 1,500 bytes)       │
│ 점보 프레임: 9,000 bytes (특수 환경)    │
└─────────────────────────────────────────┘

Total Length 계산:
Total Length = IP Header + Payload
1500 = 20 + 1480 (일반적인 경우)
9000 = 20 + 8980 (점보 프레임)
65535 = 20 + 65515 (이론적 최대)

실제 패킷에서:
Total Length: 0x003C (16진수) = 60 (10진수)
→ IP Header: 20 bytes + Payload: 40 bytes
```

### 단편화(Fragmentation) 관련 필드

**그다음 두 번째 행 Flags|Fragment Offset은 단편화와 관련이 있습니다. 단편화라 하면 예를 들어 지금 MTU가 1500 바이트인데 어느 네트워크에 갔더니 MTU가 1300밖에 안 될 수도 있는 것입니다. 그러면 패킷을 잘라야 됩니다. 이런 것이 단편화입니다.**

```
단편화 관련 필드:

Flags (3bit):
┌─────┬─────┬─────┐
│ Res │ DF  │ MF  │
└─────┴─────┴─────┘
- Res (Reserved): 사용 안 함
- DF (Don't Fragment): 단편화 금지
- MF (More Fragments): 추가 조각 존재

Fragment Offset (13bit):
- 단위: 8 bytes
- 원본 패킷에서의 위치 표시
- 수신 측에서 재조립 시 사용

단편화 시나리오:
원본 패킷: 1500 bytes (MTU)
목적지 MTU: 1300 bytes

1번 조각: [IP Header][1280 bytes data] MF=1, Offset=0
2번 조각: [IP Header][200 bytes data]  MF=0, Offset=160

Fragment Offset 계산:
1280 ÷ 8 = 160 → 두 번째 조각의 Offset
```

### 단편화 처리 과정

```
단편화 및 재조립 과정:

송신 측 라우터:
원본 (1500 bytes) → MTU 1300 체크 → 단편화 필요
├─ 조각 1: Header + 1280 bytes (MF=1, Offset=0)
└─ 조각 2: Header + 200 bytes (MF=0, Offset=160)

네트워크 전송:
조각들이 서로 다른 경로로 전송 가능
→ 순서 뒤바뀜 가능성

수신 측:
조각 수신 → Identification 필드로 그룹화
→ Fragment Offset으로 순서 확인
→ 모든 조각 수신 시 재조립
→ 원본 패킷 복원

주의사항:
- 하나라도 분실 시 전체 패킷 폐기
- 재조립 타임아웃 존재 (보통 60초)
- 성능 저하 원인 (피하는 것이 좋음)
```

### TTL (Time To Live)

**그다음 TTL(Time to Live)라고 8bit 값이 있는데 최대 크기는 255일 것이고 이 값이 0이 되면 패킷은 버려집니다. 이 TTL은 유통 과정에서 HOP이라는 것을 만날 때마다 감소하게 됩니다.**

```
TTL 동작 메커니즘:

8bit = 0~255 범위

TTL 감소 과정:
출발 (TTL=64) → Router1 (TTL=63) → Router2 (TTL=62) 
→ Router3 (TTL=61) → ... → 목적지

TTL=0 도달 시:
라우터에서 패킷 폐기 + ICMP Time Exceeded 메시지 전송

일반적인 TTL 초기값:
- Linux: 64
- Windows: 128  
- Cisco 라우터: 255
- 맥OS: 64

TTL 활용:
1. 무한 루프 방지 (라우팅 루프)
2. traceroute 도구 동작 원리
3. 네트워크 홉 수 측정

traceroute 예시:
TTL=1 → 첫 번째 라우터에서 응답
TTL=2 → 두 번째 라우터에서 응답
TTL=3 → 세 번째 라우터에서 응답
...목적지까지 경로 추적
```

### Protocol 필드

**그다음 Protocol은 이 payload 안에 또 다른 헤더가 존재할 수 있을 수도 있습니다. 그때 이 헤더를 어떤 형태로 해석해야 되는지가 프로토콜에 설명되어 있습니다. 그래서 TCP나 UDP 등에 대한 프로토콜 값이 옵니다.**

```
주요 Protocol 값 (8bit):

일반적인 프로토콜:
┌──────┬─────────────────────────────────┐
│ 값   │ 프로토콜                        │
├──────┼─────────────────────────────────┤
│  1   │ ICMP (Internet Control Message) │
│  6   │ TCP (Transmission Control)      │
│ 17   │ UDP (User Datagram)             │
│ 50   │ ESP (IPSec Encap Security)      │
│ 51   │ AH (IPSec Authentication)       │
│ 89   │ OSPF (Open Shortest Path First) │
│ 47   │ GRE (Generic Routing Encap)     │
└──────┴─────────────────────────────────┘

실제 사용 예시:
IP Header의 Protocol = 6
→ Payload는 TCP Header로 시작

IP Header의 Protocol = 17  
→ Payload는 UDP Header로 시작

프로토콜 스택:
[IP Header(Protocol=6)][TCP Header][HTTP Data]
[IP Header(Protocol=17)][UDP Header][DNS Data]
[IP Header(Protocol=1)][ICMP Message]
```

### Header Checksum

**그리고 Header Checksum이라는 것이 있는데 이는 검사합 값입니다. 네트워크가 송수신 과정에서 데이터의 손상이 발생할 수도 있기 때문에 이를 검사하는데 사용합니다.**

### 검사합(Checksum)의 상세 의미

```
Header Checksum의 동작 원리:

1. 송신 측 계산:
   ┌─────────────────────────────────────────┐
   │ IP Header의 모든 16bit 워드를 더함      │
   │ Checksum 필드는 0으로 설정              │
   │ 합계의 1의 보수(NOT 연산) 결과 저장     │
   └─────────────────────────────────────────┘

2. 수신 측 검증:
   ┌─────────────────────────────────────────┐
   │ IP Header의 모든 16bit 워드를 더함      │
   │ Checksum 필드 포함하여 계산             │
   │ 결과가 0xFFFF이면 정상, 아니면 오류     │
   └─────────────────────────────────────────┘

실제 계산 예시:
IP Header: 45 00 00 3C 1C 46 40 00 40 06 00 00 AC 14 02 0C
Checksum 위치를 0으로 설정 후 계산:
4500 + 003C + 1C46 + 4000 + 4006 + 0000 + AC14 + 020C = 1E9E2
캐리 추가: 1 + E9E2 = E9E3
1의 보수: ~E9E3 = 161C (Checksum 값)

오류 검출 한계:
- IP Header만 검사 (Payload는 별도)
- 단순한 오류만 검출 가능
- 2bit 이상 오류 시 검출 불가능한 경우 존재
- 현대에는 하위 계층에서 더 강력한 오류 검출 수행
```

### IP 헤더 옵션 필드

```
IP 옵션 (가변 길이):

기본 헤더: 20 bytes (옵션 없음)
최대 헤더: 60 bytes (옵션 40 bytes)

주요 옵션들:
┌─────────────────────────────────────────┐
│ Source Route: 경로 지정                 │
│ Record Route: 경로 기록                 │
│ Timestamp: 시간 정보 기록               │
│ Security: 보안 레벨 표시                │
└─────────────────────────────────────────┘

옵션 사용 시 고려사항:
- 헤더 크기 증가 → 성능 저하
- 일부 라우터에서 처리 안 함
- 보안상 차단되는 경우 많음
- 현대 네트워크에서는 거의 사용 안 함

옵션 형식:
┌────────┬────────┬──────────────────┐
│ Type   │ Length │ Data             │
│ (8bit) │ (8bit) │ (가변)           │
└────────┴────────┴──────────────────┘
```

### 실제 패킷 분석 예시

```
Wireshark 패킷 덤프 해석:

45 00 00 3C 1C 46 40 00 40 06 B1 E6 AC 14 02 0C 0A 00 00 01

45: Version(4) + IHL(5) → IPv4, 20 bytes 헤더
00: Type of Service → 일반 서비스
003C: Total Length → 60 bytes 전체 크기
1C46: Identification → 패킷 ID (단편화 시 그룹화)
4000: Flags(010) + Fragment Offset(0) → DF=1, 단편화 안함
40: TTL → 64 (Linux 기본값)
06: Protocol → TCP
B1E6: Header Checksum → 검사합 값
AC14020C: Source IP → 172.20.2.12
0A000001: Destination IP → 10.0.0.1

해석 결과:
IPv4 패킷, 헤더 20bytes, 전체 60bytes
172.20.2.12 → 10.0.0.1 TCP 통신
TTL 64, 단편화 금지, 검사합 정상
```

이렇게 **IP 헤더의 각 필드를 상세히 이해**하면, **패킷 분석 도구를 사용할 때 각 값의 의미를 정확히 파악**할 수 있고, **네트워크 문제 해결 시 어떤 부분에서 문제가 발생했는지 진단**할 수 있습니다!