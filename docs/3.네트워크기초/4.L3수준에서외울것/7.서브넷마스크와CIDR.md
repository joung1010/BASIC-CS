## 서브넷 마스크와 CIDR

### 서브넷 마스크의 기본 동작

```
IP 주소와 서브넷 마스크:

<──── Network ID ──────>   <Host ID>
192     .168        .0            .10

1100 0000 1010 1000 0000 0000 | 0000 1010  (IP 주소)
1111 1111 1111 1111 1111 1111 | 0000 0000  (서브넷 마스크)
─────────────────────────────────────────────────
1100 0000 1010 1000 0000 0000 | 0000 0000  (AND 연산 결과)
```

**cmd 창에 ipconfig 이렇게 입력해 보시면 네트워크 설정 정보에 서브넷 마스크라는 것을 확인해 볼 수 있습니다. 그러면 이 subnet mask는 뭐하는 녀석인가 하면 이 서브넷 마스크를 기준으로 네트워크 아이디와 호스트 아이디를 잘라냅니다.**

### AND 연산을 통한 네트워크 ID 추출

**그래서 위 서브넷 마스크인 1111 1111/1111 1111/1111 1111/0000 0000를 10진수로 표현해서 보면 255.255.255.0이 됩니다.**

```
AND 연산 상세 과정:

IP 주소: 192.168.0.10
이진수:  11000000.10101000.00000000.00001010

서브넷 마스크: 255.255.255.0  
이진수:       11111111.11111111.11111111.00000000

AND 연산:
11000000.10101000.00000000.00001010
11111111.11111111.11111111.00000000
─────────────────────────────────────
11000000.10101000.00000000.00000000

결과: 192.168.0.0 (네트워크 주소)

비트별 AND 연산 규칙:
0 AND 0 = 0
0 AND 1 = 0  
1 AND 0 = 0
1 AND 1 = 1

마스킹 효과:
- 1 비트: 해당 비트 값 유지 (네트워크 부분)
- 0 비트: 강제로 0 설정 (호스트 부분 제거)
```

### 네트워크 장비에서의 판단 과정

**그래서 결과를 보면 0하고 1하고 AND 연산한 결과인 것을 확인할 수 있습니다. 그래서 결과 값을 AND 한 결과를 확인해 보면 192.168.0.0의 결과 값을 확인할 수 있고 이는 네트워크 아이디와 일치한다는 것을 알 수 있습니다.**

**그래서 패킷이 오게 되면 네트워크 장비 같은 곳에서 서브넷 마스크와 주소 값을 AND 연산해서 이 네트워크 아이디가 나와 일치한다면 우리 네트워크로 유입되는 것이구나 하고 판단합니다.**

```
라우터/스위치의 패킷 처리 과정:

1. 패킷 수신: 목적지 IP = 192.168.0.50

2. 네트워크 판단:
   목적지 IP:    192.168.0.50
   서브넷 마스크: 255.255.255.0
   AND 연산:     192.168.0.0
   
3. 로컬 네트워크와 비교:
   로컬 네트워크: 192.168.0.0/24
   계산 결과:     192.168.0.0
   → 일치! 로컬 네트워크로 전달

4. 다른 네트워크 예시:
   목적지 IP:    10.0.1.100  
   AND 연산:     10.0.1.0
   로컬 네트워크: 192.168.0.0
   → 불일치! 라우터로 전달

실제 라우팅 테이블:
┌─────────────────┬──────────────┬─────────────┐
│ 네트워크        │ 서브넷 마스크│ 인터페이스  │
├─────────────────┼──────────────┼─────────────┤
│ 192.168.0.0     │ 255.255.255.0│ eth0 (로컬) │
│ 10.0.0.0        │ 255.0.0.0    │ eth1        │
│ 0.0.0.0         │ 0.0.0.0      │ eth2 (기본) │
└─────────────────┴──────────────┴─────────────┘
```

### Mask 연산의 본질

**그래서 이렇게 bit 연산을 통해 host 영역을 잘라내는 연산 작업을 Mask 연산이라고 합니다.**

```
Mask 연산의 다양한 활용:

네트워크 주소 계산:
IP & Subnet Mask = Network Address
192.168.0.10 & 255.255.255.0 = 192.168.0.0

브로드캐스트 주소 계산:  
Network Address | (NOT Subnet Mask) = Broadcast
192.168.0.0 | 0.0.0.255 = 192.168.0.255

호스트 개수 계산:
Host bits = 32 - Network bits
192.168.0.0/24 → Host bits = 32-24 = 8bits
가능한 호스트 = 2⁸ - 2 = 254개
(네트워크 주소와 브로드캐스트 주소 제외)

서브넷 분할:
192.168.0.0/24 → 2개 서브넷으로 분할
192.168.0.0/25 (192.168.0.1~126)
192.168.0.128/25 (192.168.0.129~254)
```

### 클래스풀 주소 체계 (과거)

**그래서 이 네트워크 아이디가 192면 A 클래스, 192.168까지면 B 클래스, 192.168.0까지면 C 클래스**

**그래서 이 주소에다가 클래스라는 개념을 도입해서 등급을 매겼었는데 이때 서브넷 마스크가 이를 잘라내기 위한 방법을 사용되었습니다. 그래서 특정 값이 같다 아니다를 마스크 연산을 통해 비교했었습니다.**

```
클래스풀 주소 체계 (1980년대~1990년대):

Class A:
┌─────────────────────────────────────────┐
│ 범위: 1.0.0.0 ~ 126.0.0.0              │
│ 서브넷 마스크: 255.0.0.0 (/8)          │
│ 네트워크: 8bit, 호스트: 24bit           │
│ 네트워크 수: 126개                      │
│ 호스트/네트워크: 16,777,214개           │
│ 용도: 매우 큰 조직 (IBM, MIT 등)        │
└─────────────────────────────────────────┘

Class B:  
┌─────────────────────────────────────────┐
│ 범위: 128.0.0.0 ~ 191.255.0.0           │
│ 서브넷 마스크: 255.255.0.0 (/16)        │
│ 네트워크: 16bit, 호스트: 16bit           │
│ 네트워크 수: 16,384개                   │
│ 호스트/네트워크: 65,534개               │
│ 용도: 중간 규모 조직 (대학, 기업)       │
└─────────────────────────────────────────┘

Class C:
┌─────────────────────────────────────────┐
│ 범위: 192.0.0.0 ~ 223.255.255.0         │
│ 서브넷 마스크: 255.255.255.0 (/24)      │
│ 네트워크: 24bit, 호스트: 8bit            │
│ 네트워크 수: 2,097,152개                │
│ 호스트/네트워크: 254개                  │
│ 용도: 소규모 조직 (소기업, 지점)        │
└─────────────────────────────────────────┘

클래스 식별 방법:
첫 번째 옥텟의 이진수 패턴:
- Class A: 0xxxxxxx (1-126)
- Class B: 10xxxxxx (128-191)  
- Class C: 110xxxxx (192-223)
- Class D: 1110xxxx (224-239, 멀티캐스트)
- Class E: 1111xxxx (240-255, 실험용)
```

### 클래스풀 시스템의 한계

**근데 요즘은 이 컴퓨터가 성능이 너무 좋아지다 보니 해당 방식이 불편하고 오히려 비효율적이다 보니 요즘은 이 클래스라는 방식을 사용하지 않습니다.**

```
클래스풀 시스템의 문제점:

1. 주소 낭비:
┌─────────────────────────────────────────┐
│ 500명 회사가 Class B 할당받은 경우      │
│ 필요: 500개 주소                        │
│ 할당: 65,534개 주소                     │
│ 낭비: 65,034개 주소 (99.2% 낭비!)       │
└─────────────────────────────────────────┘

2. 유연성 부족:
- 고정된 경계선 (8, 16, 24bit)
- 조직 크기에 맞지 않는 할당
- 성장에 따른 재할당 어려움

3. 라우팅 테이블 폭증:
- 각 네트워크마다 별도 엔트리
- 인터넷 성장에 따른 테이블 크기 급증
- 라우터 성능 저하

4. 급속한 주소 고갈:
- 1990년대 초 IPv4 주소 고갈 예상
- 비효율적 할당으로 가속화
```

### CIDR (Classless Inter-Domain Routing)

**클래스 개념이 없이 말해보자 해서 나온 개념이 CIDR(Classless Inter-Domain Routing) 사이더입니다.**

### CIDR 표기법

```
CIDR 표기법 예시:

192.168.0.10/24

기존 표기:
IP 주소:      192.168.0.10
서브넷 마스크: 255.255.255.0

CIDR 표기:
192.168.0.10/24
```

**/다음에 24비트 그니까 왼쪽부터 24비트를 network ID로 간주할게라는 뜻입니다.**

### CIDR의 장점과 동작

**그래서 기존처럼 2줄로 표시하거나 아니면 이제 한 줄로 표기하거나입니다. 이 CIDR이 좀 더 깔끔하고 이 / 기준으로 값을 자르는 건데 예전에는 이를 마스크 연산으로 처리했다면 이제는 그만큼만 잘라서 관계연산으로 같은지 다른지만 비교해서 찾아낼 수 있습니다.**

```
CIDR의 혁신적 개선:

1. 가변 길이 서브넷 마스크 (VLSM):
┌─────────────────────────────────────────┐
│ /25: 255.255.255.128 (128개 호스트)     │
│ /26: 255.255.255.192 (64개 호스트)      │
│ /27: 255.255.255.224 (32개 호스트)      │
│ /28: 255.255.255.240 (16개 호스트)      │
│ /29: 255.255.255.248 (8개 호스트)       │
│ /30: 255.255.255.252 (4개 호스트)       │
└─────────────────────────────────────────┘

2. 효율적인 주소 할당:
기업 A (100명): 192.168.1.0/25 (126개 호스트)
기업 B (50명):  192.168.1.128/26 (62개 호스트)  
기업 C (30명):  192.168.1.192/27 (30개 호스트)
기업 D (14명):  192.168.1.224/28 (14개 호스트)

3. 라우트 집약 (Route Aggregation):
개별 라우트:
192.168.0.0/24
192.168.1.0/24  
192.168.2.0/24
192.168.3.0/24

집약된 라우트:
192.168.0.0/22 (하나의 엔트리로 통합)
```

### CIDR 비트 연산 vs 관계 연산

```
전통적 마스크 연산 (과거):

def is_same_network_old(ip1, ip2, subnet_mask):
    network1 = ip1 & subnet_mask
    network2 = ip2 & subnet_mask  
    return network1 == network2

# 예시:
ip1 = 192.168.1.10
ip2 = 192.168.1.50
mask = 255.255.255.0
# AND 연산 후 비교

현대적 CIDR 연산:

def is_same_network_new(ip1, ip2, prefix_length):
    shift = 32 - prefix_length
    network1 = ip1 >> shift
    network2 = ip2 >> shift
    return network1 == network2

# 예시:  
ip1 = 192.168.1.10
ip2 = 192.168.1.50
prefix = 24
# 비트 시프트 후 비교 (더 빠름)

성능 비교:
- 마스크 연산: AND + 비교 (2단계)
- CIDR 연산: 시프트 + 비교 (1단계, 더 빠름)
```

### 실제 CIDR 활용 예시

```
회사 네트워크 설계:

전체 할당: 192.168.0.0/22 (1024개 주소)

부서별 서브넷 분할:
┌─────────────────────────────────────────┐
│ 본사 (200명):    192.168.0.0/24         │
│ 개발팀 (100명):  192.168.1.0/25         │
│ 마케팅팀 (50명): 192.168.1.128/26       │
│ 서버실 (30개):   192.168.2.0/27         │
│ 게스트 (14명):   192.168.2.32/28        │
│ DMZ (6개):       192.168.2.48/29        │
│ 관리용 (2개):    192.168.2.56/30        │
└─────────────────────────────────────────┘

ISP에서의 라우트 집약:
개별 고객사들:
192.168.0.0/22 (고객사 A)
192.168.4.0/22 (고객사 B)
192.168.8.0/22 (고객사 C)
192.168.12.0/22 (고객사 D)

상위 ISP로 광고:
192.168.0.0/20 (16개 /22 네트워크 통합)

장점:
- 라우팅 테이블 크기 1/16 감소
- 라우터 성능 향상
- 네트워크 확장성 증대
```

### CIDR와 현대 네트워킹

```
CIDR의 현재 활용:

1. IPv4 주소 고갈 완화:
- 효율적 주소 할당으로 수명 연장
- NAT와 결합하여 사설 네트워크 활용

2. 클라우드 컴퓨팅:
- AWS VPC: 사용자 정의 CIDR 블록
- 마이크로서비스: 세밀한 네트워크 분할

3. SDN (Software Defined Network):
- 프로그래밍 가능한 라우팅
- 동적 서브넷 할당

4. IPv6로의 전환:
- IPv6도 CIDR 개념 유지 (/64, /48 등)
- 더 큰 주소 공간에서 효율적 관리

실무 도구:
- ipcalc: CIDR 계산 도구
- sipcalc: 서브넷 계산기  
- 온라인 CIDR 계산기들
```

이렇게 **서브넷 마스크의 AND 연산 원리부터 CIDR의 현대적 접근법까지** 이해하면, **네트워크 설계와 라우팅 최적화에 필수적인 지식**을 갖추게 되고, **실무에서 효율적인 IP 주소 관리와 네트워크 분할**을 수행할 수 있습니다!