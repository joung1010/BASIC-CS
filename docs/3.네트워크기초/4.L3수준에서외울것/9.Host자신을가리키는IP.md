## Host 자신을 가리키는 IP주소

### Loopback Address의 기본 개념

```
Loopback Address: 127.0.0.1
```

**인터넷은 다른 컴퓨터와 통신하기 위한 거다. 내가 어떤 PC가 있다면 이 컴퓨터에도 IP 주소가 있을 것이고 라우터를 거쳐서 다른 서버와 통신을 할 것이다.**

```
일반적인 네트워크 통신:

PC ──→│──────R───── 인터넷 ─────R──────│
      │                               │──────→ Server
    Gateway                        목적지 라우터
```

**그래서 목적지 IP 주소를 알아서 통신하는 것이 일반적입니다. 그동안 우리가 언급했던 주소는 원격 remote 주소입니다(수신자 입장에서).**

### 자기 자신과의 통신 필요성

**근데 내가 나에게 접근하는 경우 또한 존재합니다. 인터넷에 연결된 host가 내가 나에게 접속해야만 하는 경우를 생각해 봤을 때 그 주체는 프로세스입니다. 인터넷을 사용하는 것은 컴퓨터가 아니고 이 컴퓨터에서 실행 중인 어떤 프로세스입니다.**

### 프로세스 간 통신의 필요성

```
같은 컴퓨터 내 프로세스 통신 시나리오:

1. 웹 서버와 데이터베이스:
   ┌─────────────┐    ┌─────────────┐
   │ Apache      │◄──►│ MySQL       │
   │ (Port 80)   │    │ (Port 3306) │
   └─────────────┘    └─────────────┘

2. 마이크로서비스 아키텍처:
   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
   │ User Service│◄──►│Auth Service │◄──►│ DB Service  │
   │ (Port 8001) │    │ (Port 8002) │    │ (Port 8003) │
   └─────────────┘    └─────────────┘    └─────────────┘

3. 개발 환경 테스트:
   ┌─────────────┐    ┌─────────────┐
   │ 클라이언트  │◄──►│ 로컬 서버   │
   │ 테스트 코드 │    │ (개발용)    │
   └─────────────┘    └─────────────┘

4. 시스템 모니터링:
   ┌─────────────┐    ┌─────────────┐
   │ 모니터링    │◄──►│ 시스템      │
   │ 에이전트    │    │ 메트릭 수집 │
   └─────────────┘    └─────────────┘
```

### Loopback 주소의 활용

**내 PC에서 동작하는 프로세스들 중에서 다른 프로세스들에게 통신을 해야 될 때가 있습니다. 그래서 그때 사용할 수 있는 IP 주소가 바로 127.0.0.1입니다. 그래서 이런 주소를 Loop Back Address라고 합니다.**

```
Loopback 주소 범위:

127.0.0.0/8 전체 범위가 Loopback:
- 127.0.0.1: 가장 일반적으로 사용
- 127.0.0.2~127.255.255.254: 모두 loopback
- 127.0.0.0: 네트워크 주소 (사용 불가)
- 127.255.255.255: 브로드캐스트 주소 (사용 불가)

별칭(Alias):
- localhost: 127.0.0.1의 도메인 이름
- ::1: IPv6의 loopback 주소

운영체제별 확인:
Windows: ping 127.0.0.1
Linux:   ping localhost
macOS:   ping6 ::1
```

### 내부 프로세스 간 통신 구조

```
프로세스 간 Loopback 통신:

                      Client               Server
                     ProcessA             ProcessB
                         │                    │
User Mode              소켓                  소켓
                         │                    │
─────────────────────────────────────────────────────────────
Kernel Mode             TCP                  TCP
                         │                    │
                    IP (127.0.0.1) ◄────────►IP
                         │                    │
                     Loopback Interface
                         │                    │
S/W                   Driver              Driver
─────────────────────────────────────────────────────────────
H/W                     NIC                  NIC
                         │                    │
                   (물리적 전송 없음)
```

**이렇게 프로세스 2개가 소켓을 열어서 통신 중인데 프로세스 B는 수신을 대기하고 있습니다. 그러면 기본적으로 이 서버 프로세스는 컴퓨터 바깥에서 뭔가 연결이 와서 이를 받아주는 역할을 합니다.**

### 내부 vs 외부 접근의 차이

**근데 이게 외부를 통해서 서버로 도착할 수도 있지만 위에서처럼 프로세스 A가 소켓을 통해 TCP/IP를 거쳐 바로 프로세스 B로 데이터가 이동할 수 있습니다. 그래서 이때 물론 192.168.0.10이 192.168.0.10번으로 접속해도 가능하지만 이때 굳이 IP 주소를 특정하지 말고 127.0.0.1한테 연결해야지가 동일한 의미입니다.**

```
접속 방법 비교:

실제 IP 주소 사용:
Client → 192.168.0.10:8080 → Server
- 네트워크 인터페이스 통과
- 실제 IP 주소에 의존
- IP 변경 시 문제 발생 가능

Loopback 주소 사용:  
Client → 127.0.0.1:8080 → Server
- 내부 루프백 인터페이스 사용
- IP 주소 변경과 무관
- 항상 자기 자신을 의미

코드 예시:
// 실제 IP 사용 (문제 가능성)
connect("192.168.0.10", 8080);

// Loopback 사용 (안정적)
connect("127.0.0.1", 8080);
connect("localhost", 8080);  // 동일한 의미
```

### IP 주소 변경에 대한 독립성

**이 IP 주소가 변경될 수 있는데 이 127.0.0.1이라고 하게 되면 원래 IP 주소가 어떻게 되든 항상 자기 자신과 통신이 이루어집니다.**

```
IP 주소 변경 시나리오:

상황 1: 고정 IP → DHCP 변경
기존: 192.168.0.10 (고정)
변경: 192.168.0.157 (DHCP 할당)

실제 IP 사용 시:
connect("192.168.0.10", 8080);  // ❌ 연결 실패!

Loopback 사용 시:
connect("127.0.0.1", 8080);     // ✅ 정상 동작

상황 2: 네트워크 환경 이동
사무실: 192.168.1.100
집:     10.0.0.50
카페:   172.16.5.200

Loopback은 항상 동일하게 동작: 127.0.0.1

상황 3: 다중 네트워크 인터페이스
Ethernet: 192.168.1.100
Wi-Fi:    192.168.1.101
VPN:      10.8.0.5

어떤 인터페이스를 사용할지 모호함
→ Loopback이 명확하고 안정적
```

### 물리 계층 우회의 중요성

**이때 중요한 것은 이 패킷이 L1, L2 수준까지 내려가지 않습니다.**

```
일반적인 네트워크 스택 vs Loopback:

일반 네트워크 통신:
Application → Socket → TCP → IP → Driver → NIC → Physical Media

Loopback 통신:
Application → Socket → TCP → IP → Loopback Interface (여기서 끝!)
                                  ↓
                                Internal Routing
                                  ↓
Application ← Socket ← TCP ← IP ← Loopback Interface

Loopback의 장점:
┌─────────────────────────────────────────┐
│ • 물리적 네트워크 불필요                │
│ • 네트워크 카드 상태와 무관             │
│ • 최고 성능 (메모리 복사만)             │
│ • 네트워크 혼잡과 무관                  │
│ • 보안 (외부 스니핑 불가능)             │
└─────────────────────────────────────────┘

성능 비교:
Loopback:     지연시간 < 1ms, 대역폭 ~수십 Gbps
실제 네트워크: 지연시간 1-100ms, 대역폭 1Gbps
```

### IPC (Inter Process Communication) 구현

**그래서 IPC(Inter Process Communication)을 구현할 때 보통 이런 식으로 소켓을 이용해서 내가 나한테 접속하는 방식으로 이루어지도록 지원할 수 있습니다.**

```
다양한 IPC 방법과 Loopback 소켓:

1. Unix Domain Socket (가장 빠름):
   • 파일 시스템 기반 (/tmp/socket)
   • 같은 머신에서만 사용 가능
   • TCP/IP 오버헤드 없음

2. Loopback Socket (네트워크 호환):
   • TCP/IP 스택 사용 (127.0.0.1)
   • 원격 접속과 동일한 인터페이스
   • 포트 번호로 서비스 구분

3. Named Pipe (Windows):
   • \\.\pipe\name 형식
   • Windows 전용

4. Shared Memory:
   • 가장 빠른 대용량 전송
   • 동기화 복잡

Loopback 소켓의 장점:
- 네트워크 프로그래밍 표준 사용
- 원격/로컬 투명한 전환 가능
- 방화벽 설정 동일하게 적용
- 디버깅 도구 활용 가능
```

### 실제 활용 사례

```
개발 환경에서의 Loopback 활용:

1. 웹 개발:
   Frontend (React) → http://localhost:3000
   Backend (Node.js) → http://localhost:8080
   Database → localhost:3306

2. 마이크로서비스:
   services:
     - api-gateway:    localhost:3000
     - user-service:   localhost:3001  
     - order-service:  localhost:3002
     - payment-service: localhost:3003

3. 데이터베이스 연결:
   # MySQL
   mysql -h localhost -u root -p
   
   # PostgreSQL  
   psql -h 127.0.0.1 -U postgres
   
   # Redis
   redis-cli -h 127.0.0.1 -p 6379

4. API 테스트:
   curl http://localhost:8080/api/users
   wget http://127.0.0.1:3000/health

보안 설정 예시:
# 방화벽에서 loopback 허용
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# 외부 접속 차단, 내부만 허용
bind-address = 127.0.0.1  # MySQL 설정
```

### Loopback 인터페이스 관리

```
운영체제별 Loopback 인터페이스:

Linux:
$ ip addr show lo
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536
    inet 127.0.0.1/8 scope host lo

Windows:
> ipconfig
Windows IP Configuration
Ethernet adapter Loopback Pseudo-Interface 1:
   Connection-specific DNS Suffix:
   IPv4 Address: 127.0.0.1
   Subnet Mask:  255.0.0.0

macOS:
$ ifconfig lo0
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
     inet 127.0.0.1 netmask 0xff000000

트러블슈팅:
# Loopback 인터페이스 활성화
ip link set lo up           # Linux
netsh interface set interface "Loopback Pseudo-Interface 1" enable  # Windows

# 연결 테스트
ping 127.0.0.1
telnet localhost 80
netstat -an | grep 127.0.0.1
```

이렇게 **Loopback 주소를 이해**하면, **로컬 개발 환경 구성, 마이크로서비스 아키텍처 설계, 그리고 효율적인 프로세스 간 통신 구현**에 필수적인 지식을 갖추게 되며, **네트워크 독립적인 안정적인 애플리케이션**을 개발할 수 있습니다!