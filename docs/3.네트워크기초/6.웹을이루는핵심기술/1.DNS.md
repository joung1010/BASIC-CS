# DNS (Domain Name System)

## DNS의 인프라적 성격

우리가 앞서 **L1~L4까지는 인프라스트럭처**라고 볼 만하다. 사실은 **5층부터 등장하는 Application들을 위해 인프라가 존재**하는 것이다. 인터넷을 이루고 있는 각종 서비스, 실제 우리가 체감할 수 있는 것들은 대다수가 **애플리케이션 계층**에 존재한다.

근데 이 **애플리케이션 수준에서 존재하는 서비스 중에서 인프라에 해당하는 것들이 있는데** 그중에서 가장 대표적인 것이 **DNS(Domain Name System)**이다. 이 서비스는 다른 게 아니라 우리가 **[www.naver.com**을](http://www.naver.xn--com%2A%2A-tn92b/) 주소창에 치고 엔터를 누르면 이 네이버까지 **TCP/IP 연결을 해야 되는데** 그러려면 **IP 주소를 당연하게도 알아야 하는데** 이 **IP 주소를 알고 있는 데이터베이스가 존재**한다.

```
DNS의 역할:

사용자 관점:
┌─────────────────────────────────────────────────┐
│ 브라우저에 "www.naver.com" 입력                  │
│            ↓                                    │
│ 사람이 기억하기 쉬운 이름                        │
└─────────────────────────────────────────────────┘

DNS 변환:
┌─────────────────────────────────────────────────┐
│ www.naver.com → 223.130.195.200                 │
│            ↓                                    │
│ 컴퓨터가 이해하는 IP 주소                        │
└─────────────────────────────────────────────────┘

최종 연결:
┌─────────────────────────────────────────────────┐
│ 브라우저가 223.130.195.200:443으로 HTTPS 연결   │
└─────────────────────────────────────────────────┘
```

우리가 친구에게 전화할 때 핸드폰번호를 전부 입력하는 경우도 있지만 **주소록에서 친구 이름을 검색해서 전화를 하게 되면** 그 **이름에 매핑되어 있는 번호로 전화연결**을 한다. 이처럼 이 **이름으로 IPv4 주소를 검색해서 그 결과를 알려주는 서비스가 DNS**이다.

## DNS의 분산 데이터베이스 구조

그래서 이 데이터베이스를 조금 더 깊게 들어가보면 **분산형 데이터베이스 형태**로 되어있다.

### 분산형 데이터베이스 특징

- **데이터베이스 시스템(DNS 네임 서버)의 분산 구성**
- **데이터 영역별 구분(Domain Zone) 및 분산 관리**
- **도메인의 네임서버 및 도메인 데이터는 해당 관리 주체에 의해 독립적으로 관리**된다.

### 계층적 트리 구조

대부분 **트리 구조 형태의 계층적 구조**로 되어있다:

- **트리 구조의 도메인 네임(Domain Name) 체계**
    - **Domain**: 영역, 영토를 의미
    - **도메인 네임의 자율적 생성**
    - **생성된 도메인 네임은 언제나 유일(Unique)하도록 네임 체계 구성**

```
DNS 계층 구조:

                    Root (.)
                       │
        ┌──────────────┼──────────────┐
        │              │              │
       com            org            kr
        │              │              │
    ┌───┼───┐          │          ┌───┼───┐
    │   │   │          │          │   │   │
  naver google yahoo wikipedia   go  co  ac
    │       │                     │   │   │
   www     www                   kr  kr  kr
                                  │
                              ┌───┼───┐
                              │   │   │
                           naver samsung lg

도메인 읽는 방향: 오른쪽에서 왼쪽 (작은 단위 → 큰 단위)
www.naver.com = www + naver + com + (root)
```

## 도메인 네임 vs 호스트 네임

먼저 앞서 이 **도메인**이라는 것에 대해 한번 알아보고 가자면 [**www.naver.com**](http://www.naver.com/)

이 **www는 네이버 안에 속해 있는 것**이다. 다시 이 **네이버는 com 안에 속해 있는 구조**이다.

```
도메인 구조 분석:

www.naver.com
│   │     │
│   │     └── Top Level Domain (TLD)
│   └────── Second Level Domain (SLD)  
└────────── Subdomain (Host Name)

구체적 분류:
┌─────────────────────────────────────────────────┐
│ 도메인 네임: naver.com                          │
│ 호스트 네임: www                                │
│ 전체 주소(FQDN): www.naver.com                  │
└─────────────────────────────────────────────────┘
```

우리나라 주소 체계는 보통 **큰 단위에서 작은 단위로** 예를 들어 "서울시 강남구" 이런 식으로 되지만 **서양은 작은 개념에서 큰 개념의 주소체계**를 가지고 있다. 그래서 **도메인 네임이라고 하면 naver.com 이렇게까지가 도메인 네임**이다. 그러면 이 **도메인에 속해 있는 www는 무엇이냐 하면 이것이 호스트 네임**이다.

그래서 **[www.naver.com**이라는](http://www.naver.xn--com%2A%2A-of68az84auv0c/) 건 무엇이냐면 **네이버 닷 컴(naver.com) 도메인 안에 속한 이름이 www인 호스트를 찾는 거**다. 그래서 전체적으로 [**www.naver.com은](http://www.naver.xn--com-7e0o/) URL이나 혹은 URI라고 부른다**. 통상적인 경우 **URL이라는 표현을 더 많이 사용**한다. 그래서 **URL 주소라고 하는 것은 호스트네임과 도메인 네임으로 나뉘어져 있다**.

```
용어 정리:

FQDN (Fully Qualified Domain Name):
├─ www.naver.com (완전한 도메인 주소)
├─ mail.google.com  
└─ blog.example.org

URL (Uniform Resource Locator):
├─ https://www.naver.com/search?q=DNS
├─ ftp://files.example.com/downloads/
└─ mailto:admin@naver.com

URI (Uniform Resource Identifier):
├─ URL을 포함하는 더 넓은 개념
├─ urn:isbn:1234567890 (책 식별자)
└─ tel:+82-10-1234-5678 (전화번호)
```

## DNS 동작 과정

그러면 왜 이러한 형태가 **분산구조 형태**라고 말하는지에 대해 알아보자.

```
네트워크 구성도:

PC ──→ Router ──→ ISP ──→ Internet
                   │
                   ├── DNS Server (168.126.63.1)
                   └── Other ISPs ──→ PCs
```

만약에 **KT 같은 곳에서 인터넷을 쓴다고 했을 때** 사용자가 주소창에 **[https://www.naver.com**이라고](https://www.naver.xn--com%2A%2A-ji47auz3eub4b/) 검색을 한다고 했을 때 **해당 PC의 IP 설정에 반드시 DNS 서버 주소가 포함**되어 있다. (KT 기준으로 **168.126.63.1 또는 168.126.63.2**) 그러면 **운영체제 내부에서 DNS 주소에게** "나 지금 네이버에 접속하려고 하는데 [**www.naver.com](http://www.naver.com/) IP주소 좀 알려줘**" 그러면 **DNS 서버가 해당 도메인에 대한 IP 주소를 알려준다**. 그러면 그 주소를 보고 접속하게 된다. 그다음에 이제 **HTTPS 통신**을 하게 될 것이다.

```
DNS 조회 과정 (Recursive Query):

1단계: Local DNS Cache 확인
PC → 내부 캐시 확인 → Cache Hit/Miss

2단계: DNS 서버 조회
PC → ISP DNS (168.126.63.1)
"www.naver.com의 IP 주소는?"

3단계: 재귀적 조회 (DNS 서버가 대신 조회)
ISP DNS → Root DNS → ".com" DNS → "naver.com" DNS

4단계: 응답 반환
naver.com DNS → "223.130.195.200" → ISP DNS → PC

5단계: 연결 시도
PC → 223.130.195.200:443 (HTTPS)
```

이 **설정된 DNS 주소는 보통 ISP에서 정해준 것을 사용**한다. 그리고 이 **DNS 서버가 느려지면 전체 인터넷 속도가 느려지는 현상이 발생**한다. (구글 DNS **8.8.8.8** 사용 시 개선 가능)

## DNS 캐싱 메커니즘

근데 이때 **PC가 한 번이라도 DNS에게 어떠한 도메인에 대한 문의를 했다면** PC는 **DNS에서 받아온 IP 주소를 메모리에다가 저장해서 갖고 있다**. 이런 것을 **DNS Cache**라고 한다. 그래서 **명령 프롬프트에다가 "ipconfig /displaydns"라고 쳐보면 내용을 확인**할 수 있다. 이렇게 **캐시에 저장되어 있으면 DNS에 물어보지 않고 캐시에 있는 값을 가지고 바로 접속**한다.

한 가지 더, **DNS에서 IP 주소를 응답받을 때 유효기간(TTL)을 함께 받아서 관리**되고 있다.

```
DNS 캐싱 계층:

1. 브라우저 캐시 (수 분):
   ┌─────────────────────────────────────────────┐
   │ Chrome, Firefox 등 브라우저 내부 캐시        │
   │ 가장 빠른 응답, 짧은 TTL                    │
   └─────────────────────────────────────────────┘

2. OS 캐시 (수십 분 ~ 수 시간):
   ┌─────────────────────────────────────────────┐
   │ Windows: DNS Client Service                 │
   │ Linux: systemd-resolved                     │
   │ 명령어: ipconfig /displaydns (Windows)      │
   │        systemd-resolve --statistics (Linux) │
   └─────────────────────────────────────────────┘

3. 라우터 캐시 (수 시간):
   ┌─────────────────────────────────────────────┐
   │ 가정용 공유기나 기업 라우터의 DNS 캐시       │
   └─────────────────────────────────────────────┘

4. ISP DNS 캐시 (수 시간 ~ 하루):
   ┌─────────────────────────────────────────────┐
   │ 통신사 DNS 서버의 캐시                      │
   │ 가장 큰 용량, 많은 사용자 공유              │
   └─────────────────────────────────────────────┘
```

## DNS 보안 이슈

근데 이런 일은 발생하지 않겠지만 만약 **DNS가 잘못된 IP주소를 준다면** 어떻게 될까? 나는 네이버의 IP 주소를 물어봤는데 **응답으로 다음 IP주소가 온다면 브라우저 화면에는 다음 화면이 보이게** 된다.

이러한 **DNS의 분산 구조와 동작 원리, 보안 이슈**를 이해하면 **네트워크 통신의 첫 단계인 이름 해석 과정**을 깊이 있게 파악할 수 있고, **안전한 인터넷 사용**을 위한 기초 지식을 갖출 수 있습니다


## DNS 조회 우선순위

PC 입장에서는 **DNS 캐시**가 있다. 윈도우 기준으로 **hosts 파일**이라는 것이 존재한다. 만약에 해당 파일에 **도메인과 IP 정보가 있다면 DNS에게 묻지 않는다**. **hosts 파일에 쓰인 대로 동작**한다.

```
DNS 조회 우선순위 (Windows 기준):

1순위: hosts 파일
┌─────────────────────────────────────────────────┐
│ 위치: C:\Windows\System32\drivers\etc\hosts     │
│                                                 │
│ 내용 예시:                                       │
│ 127.0.0.1    localhost                         │
│ 192.168.1.100 myserver.local                   │
│ 1.2.3.4    www.example.com                     │
│                                                 │
│ 특징:                                           │
│ • 최우선 조회                                    │
│ • 관리자 권한으로만 수정 가능                    │
│ • 캐시나 DNS 서버보다 우선                       │
└─────────────────────────────────────────────────┘

2순위: DNS 캐시
┌─────────────────────────────────────────────────┐
│ 브라우저 캐시 → OS 캐시 → 라우터 캐시           │
│ 명령어: ipconfig /displaydns                    │
│ 캐시 삭제: ipconfig /flushdns                   │
└─────────────────────────────────────────────────┘

3순위: DNS 서버 조회
┌─────────────────────────────────────────────────┐
│ 설정된 DNS 서버에 실제 질의                      │
│ ISP DNS → 공개 DNS → Root DNS                   │
└─────────────────────────────────────────────────┘
```

## 공유기의 DNS 포워딩 기능

간혹 **DNS 주소가 공유기 주소와 동일할 수도 있는데** 근데 **공유기는 DNS가 아니다**. 그러면 이 **공유기가 실제 DNS를 포워딩하는 기능으로써 공유기가 DNS 역할을 약간 대행해 주는 방식으로도 동작**하기도 한다.

```
공유기 DNS 포워딩:

사용자 설정:
┌─────────────────────────────────────────────────┐
│ PC DNS 설정: 192.168.1.1 (공유기 IP)            │
└─────────────────────────────────────────────────┘

공유기 동작:
┌─────────────────────────────────────────────────┐
│ 1. PC → 공유기: "www.naver.com IP 주소는?"      │
│ 2. 공유기 내부 캐시 확인                         │
│ 3. 캐시 없음 → 실제 DNS 서버로 포워딩            │
│ 4. 공유기 → ISP DNS: "www.naver.com IP는?"      │
│ 5. ISP DNS → 공유기: "223.130.195.200"         │
│ 6. 공유기 → PC: "223.130.195.200"              │
│ 7. 공유기가 결과를 내부 캐시에 저장              │
└─────────────────────────────────────────────────┘

장점:
- 가정 내 여러 기기가 같은 캐시 공유
- 공유기 레벨에서 악성 도메인 차단 가능
- 네트워크 트래픽 감소

단점:
- 공유기 성능에 따른 지연 가능성
- 공유기 재시작 시 캐시 초기화
```

## DNS 캐싱 시스템 정리

그래서 **항상 DNS에게 묻는 것이 아니라** 공유기가 **포워딩 기능을 통해 DNS를 대신하기도 하고** **hosts 파일에 정보를 기술해두면 DNS에 묻지 않고 해당 정보로 접속을 시도**하고 **DNS 캐시는 DNS한테 한 번 물어보면 유효기간이 만료될 때까지 캐시의 정보를 이용**하게 된다.

```
전체 DNS 조회 흐름:

PC에서 www.naver.com 접속 시도
        ↓
┌─────────────────┐
│ 1. hosts 파일   │ → 있으면 즉시 해당 IP 사용
└─────────────────┘
        ↓ (없으면)
┌─────────────────┐
│ 2. 브라우저     │ → 있으면 캐시된 IP 사용
│    캐시 확인    │
└─────────────────┘
        ↓ (없으면)
┌─────────────────┐
│ 3. OS DNS       │ → 있으면 캐시된 IP 사용
│    캐시 확인    │
└─────────────────┘
        ↓ (없으면)
┌─────────────────┐
│ 4. 공유기에     │ → 있으면 캐시된 IP 사용
│    DNS 질의     │
└─────────────────┘
        ↓ (없으면)
┌─────────────────┐
│ 5. ISP DNS에    │ → 실제 DNS 조회 시작
│    질의         │
└─────────────────┘
```

## DNS 계층 구조와 Root DNS

근데 만약에 **네이버에 대한 IP를 DNS한테 문의했는데 어느 누구도 해당 도메인에 대한 문의가 한 번도 없었다면** 어떻게 될까? 사실 지금 우리가 요청하는 이 **DNS도 사실은 캐시 DNS 서버**이고 이 **전 세계 여러 DNS의 정점에 있는 것이 Root DNS 서버**가 있다. **(대략 13대)** 이 **Root DNS 주소도 iana.org에 들어가보면 알아낼 수 있다** 참고적으로 알아두면 된다.

```
DNS 계층 구조:

Root DNS Servers (13대):
┌─────────────────────────────────────────────────┐
│ a.root-servers.net  (198.41.0.4)               │
│ b.root-servers.net  (199.9.14.201)             │
│ c.root-servers.net  (192.33.4.12)              │
│ ...                                             │
│ m.root-servers.net  (202.12.27.33)             │
│                                                 │
│ 역할: TLD 네임서버 정보 제공                     │
│ 위치: 전 세계 분산 (애니캐스트)                  │
└─────────────────────────────────────────────────┘

TLD (Top Level Domain) Servers:
┌─────────────────────────────────────────────────┐
│ .com TLD 서버들                                 │
│ .org TLD 서버들                                 │
│ .kr TLD 서버들                                  │
│ .edu TLD 서버들                                 │
│                                                 │
│ 역할: 각 도메인별 권한 있는 네임서버 정보 제공    │
└─────────────────────────────────────────────────┘

Authoritative Name Servers:
┌─────────────────────────────────────────────────┐
│ naver.com 권한 서버 (ns1.naver.com)             │
│ google.com 권한 서버 (ns1.google.com)           │
│                                                 │
│ 역할: 실제 도메인의 IP 주소 정보 제공            │
└─────────────────────────────────────────────────┘
```

## 재귀적 DNS 조회 과정

그래서 **다시 한 번도 요청받은 적 없는 도메인에 대해서는 캐시 DNS 서버가 Root DNS한테 문의**를 하게 된다. 즉 **Root DNS라고 하면 DNS들을 위한 DNS**인 것이다. 그러면 **Root DNS가 .com 쪽 DNS를 담당하는 DNS 서버들의 IP 목록을 응답**받게 된다. 그렇게 **전달받은 목록들에게 한 번씩 요청하여 해당 네이버라는 도메인을 아는 네임서버를 찾고** 그 **네임서버들 중에서 호스트 이름이 www인 것을 찾아서 IP를 알려준다**.

```
재귀적 DNS 조회 과정 (www.naver.com 예시):

1단계: 캐시 DNS → Root DNS
┌─────────────────────────────────────────────────┐
│ 질의: "www.naver.com의 IP는?"                    │
│ 응답: ".com은 이 서버들이 담당해"                │
│       (a.gtld-servers.net, b.gtld-servers.net)  │
└─────────────────────────────────────────────────┘

2단계: 캐시 DNS → .com TLD 서버
┌─────────────────────────────────────────────────┐
│ 질의: "www.naver.com의 IP는?"                    │
│ 응답: "naver.com은 이 서버들이 담당해"           │
│       (ns1.naver.com, ns2.naver.com)            │
└─────────────────────────────────────────────────┘

3단계: 캐시 DNS → naver.com 권한 서버
┌─────────────────────────────────────────────────┐
│ 질의: "www.naver.com의 IP는?"                    │
│ 응답: "223.130.195.200"                        │
│ TTL: 300초                                      │
└─────────────────────────────────────────────────┘

4단계: 결과 반환 및 캐싱
┌─────────────────────────────────────────────────┐
│ 캐시 DNS → PC: "223.130.195.200"               │
│ 캐시 DNS가 결과를 300초간 캐싱                   │
│ 다음 동일 질의 시 캐시에서 즉시 응답             │
└─────────────────────────────────────────────────┘
```

이러한 **DNS의 계층적 조회 시스템과 캐싱 메커니즘**을 이해하면 **네트워크 성능 최적화와 보안 강화**에 도움이 되는 실무 지식을 갖출 수 있습니다.