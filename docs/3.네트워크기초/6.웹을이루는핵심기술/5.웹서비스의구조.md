# 웹 서비스 구조

## 기본 웹 통신 구조

```
Web Client                Web Server

       TCP/IP 연결 및 HTTP 세션 생성
           ------->
       HTML 문서 전송 요청(GET)    
          ------->
    서버에서 HTML 문서를 수신하고 연결 종료
          <------
```

**기본적으로 웹에서 사용하는 통신 프로토콜은 HTTP**이다. **이때 HTTP의 연결은 TCP 연결 그다음에 존재**한다.

**HTTP 트래픽이라고 하면 소켓 수준에서 만들어지는 것이고, 따라서 스트림의 형태 즉, 끝을 알기 어려운 데이터의 처리**를 말한다.

**문제는 네트워크로 무엇인가를 보낼 때는 여기 TCP/IP에서 MTU가 1500바이트뿐이니 이 스트림 데이터를 세그먼트 단위로 쪼개서 패킷에 담아(인캡슐레이션) 전송**한다.

그래서 **웹에 대해서는 패킷이니 세그먼트이니 이런 단위는 나오지 않는다. 바로 스트림 수준에서 이야기**한다. 특히 **송수신 프로토콜인 HTTP는 문자열로 되어있어서 간단한 구조를 가지고 있으며 항상 핵심은 문서의 요청과 요청받은 문서를 수신하는 것**이다.

**웹이라고 하는 기술의 가장 근간이 되는 두 가지 기술은 HTML과 HTTP**이다. **즉 문서와 그걸 실어 나르는 방법**이다.

```
프로토콜 스택과 웹 통신:

응용 계층 (L7): HTTP (HyperText Transfer Protocol)
┌─────────────────────────────────────────────────┐
│ • 텍스트 기반 프로토콜                           │
│ • 요청-응답 모델                                │
│ • 무상태(Stateless) 특성                       │
└─────────────────────────────────────────────────┘
                        ↓
전송 계층 (L4): TCP (Transmission Control Protocol)
┌─────────────────────────────────────────────────┐
│ • 연결 지향, 신뢰성 보장                         │
│ • 스트림 데이터 처리                            │
│ • 3-Way Handshake 연결 설정                    │
└─────────────────────────────────────────────────┘
                        ↓
네트워크 계층 (L3): IP (Internet Protocol)
┌─────────────────────────────────────────────────┐
│ • 패킷 단위 전송 (MTU 1500 bytes 제한)          │
│ • 라우팅 및 주소 지정                           │
│ • 큰 데이터는 분할 전송 후 재조립                │
└─────────────────────────────────────────────────┘
```

## TCP vs HTTP의 상태 관리

```
					PC ────→ 인터넷 ──→ Web Server
					(웹 클라이언트)                    │
					   브라우저                        │
					    │          HTTP              │ HTML 문서
					    │    ←─ TCP/IP ─→            │ 리소스
					    │                            │
					    │ http://request, method=GET  │
					    │      ────────→             │
		브라우저  │    HTML Response           │
	http://get  │   ←────────────           │
	요청 문서   │                            │
						   │                            │
```

이 **웹 기술이라는 것은 HTML과 HTTP 구현**이 된다고 하지만 **기본적으로 웹 클라이언트와 웹 서버 간에 TCP 연결을 기반으로 HTTP 통신이 이루어지는 것**이다. **TCP/IP 연결을 할 때 상태에 관해서 말을 하는데 반면에 HTTP가 가지고 있는 매우 중요한 특징은 바로 Stateless 무상태**이다. **즉 상태라는 개념이 없다**.

**연결이라는 개념은 TCP에 있는 것이고 HTTP는 그런 개념이 존재하지 않는다**.

```
TCP vs HTTP 상태 관리 비교:

TCP 계층 (연결 지향):
┌─────────────────────────────────────────────────┐
│ • Connection State: ESTABLISHED, FIN-WAIT 등    │
│ • 순서번호, 윈도우 크기 관리                     │
│ • 연결 유지 상태 추적                           │
│ • 세션 정보 유지                                │
└─────────────────────────────────────────────────┘

HTTP 계층 (무상태):
┌─────────────────────────────────────────────────┐
│ • 각 요청은 독립적                              │
│ • 이전 요청 정보 기억하지 않음                   │
│ • 서버는 클라이언트 상태 모름                    │
│ • 확장성과 단순성 제공                          │
└─────────────────────────────────────────────────┘

문제점과 해결책:
┌─────────────────────────────────────────────────┐
│ 문제: 사용자 인증, 장바구니 등 상태 필요         │
│ 해결: 쿠키, 세션, 토큰 등으로 상태 관리          │
└─────────────────────────────────────────────────┘
```

## 초기 웹의 단순한 구조

**팀 버너스 리가 초기에 웹을 만들었을 때 HTML 문서를 주고받는 것**이었고 따라서 이 **클라이언트에 해당되는 브라우저의 본질적인 역할은 문서 뷰어**였다. 근데 **이제 다른 뷰어들과의 차이점은 인터넷 어딘가 웹서버에 저장되어 있는 문서(리소스)를 가져오는 데에 있어서 차이**가 있었다.

**이것이 초창기 웹의 형태**이다.

```
초기 웹 아키텍처 (1990년대 초):

Client (브라우저)          Server (웹서버)
┌─────────────────┐      ┌─────────────────┐
│ • 문서 뷰어     │      │ • 정적 HTML     │
│ • HTML 파싱     │ ←──→ │   파일 저장     │
│ • 텍스트 표시   │      │ • 파일 전송     │
└─────────────────┘      └─────────────────┘

특징:
- 단순한 요청-응답 모델
- 정적 컨텐츠만 제공
- 사용자 상호작용 없음
- 읽기 전용 웹
```

## MVC 패턴의 필요성

**개발 시 UI, 데이터 영역, 제어체계(MVC) 이 3가지를 꼭 분리시켜라를 기본**으로 하고 있고 **좋은 설계라고 하면 결국 유지보수하기 용이한 설계**를 말하는데 그렇다면 **왜 MVC가 유지보수하기 효율적인가 하면 만약 UI와 데이터가 한곳에 있으면 데이터를 수정하면 반드시 화면도 같이 수정해야만 한다. 혹은 화면을 수정하는데 자료구조도 같이 변경되거나 하는 문제가 발생**한다.

```
MVC 패턴의 필요성:

문제가 되는 구조 (UI + Data 결합):
┌─────────────────────────────────────────────────┐
│ HTML + 데이터 로직이 한 파일에 모두 존재         │
│                                                 │
│ 문제점:                                         │
│ • 데이터 변경 → UI 수정 필수                    │
│ • UI 변경 → 데이터 로직 영향                    │
│ • 코드 재사용 어려움                            │
│ • 테스트 복잡함                                 │
│ • 협업 시 충돌 발생                             │
└─────────────────────────────────────────────────┘

MVC 패턴 적용:
┌─────────────────────────────────────────────────┐
│ Model (데이터 + 비즈니스 로직)                   │
│ • 데이터 구조 정의                              │
│ • 비즈니스 규칙 처리                            │
│ • 데이터베이스 연동                             │
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│ Controller (제어 로직)                          │
│ • 사용자 입력 처리                              │
│ • Model과 View 조정                            │
│ • 비즈니스 흐름 제어                            │
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│ View (사용자 인터페이스)                        │
│ • 데이터 표시                                   │
│ • 사용자 입력 인터페이스                        │
│ • 화면 레이아웃                                 │
└─────────────────────────────────────────────────┘
```

## 웹 기술의 발전 과정

### 1단계: HTML 문서의 스타일링 (CSS 등장)

**위의 내용을 상기한 채로 이 웹이 어떤 식으로 발전을 했느냐 하면 처음에는 문서 요청하고 그 문서를 받아서 처리하는 것만으로도 좋았는데 하다 보니까 이 문서를 좀 예쁘게 꾸밀 필요가 생겼다**. 그래서 이 **HTML 문서에 좀 더 이쁘게 보이게끔 하는 문법을 추가**한다. 그러면 **지금 한 문서에 데이터와 UI가 공존하게 됐는데** 간단하게 생각해서 **문서를 꾸미겠다고 논문을 뜯어고치면 될까? 당연히 말도 안 된다**. 그래서 **그 둘을 분리하게 된다**.

**HTML 안에 한 번에 기술할 수 있었지만 이를 분리시킨다. 그렇게 해서 문서와 이를 꾸미기 위한 문법이 분리된다. 그것이 CSS 스타일시트라는 게 필요해진 것**이다.

```
			`PC ────→ 인터넷 ──→ Web Server
			(웹 클라이언트)                    │
			   브라우저                        │
			    │          HTTP              │ HTML 문서 + CSS
			    │    ←─ TCP/IP ─→            │ 리소스
			    │                            │
			    │ http://request, method=GET  │
			    │      ────────→             │
브라우저   │    HTML + CSS              │
http://get │   ←───────────────         │
요청 문서   │                            │
			     │                            │`
```

```

`HTML + CSS 분리의 장점:

분리 전 (HTML 내 스타일 포함):
┌─────────────────────────────────────────────────┐
│ <p style="color:red; font-size:14px;">텍스트</p> │
│ <p style="color:red; font-size:14px;">텍스트2</p>│
│                                                 │
│ 문제점:                                         │
│ • 스타일 중복                                   │
│ • 유지보수 어려움                               │
│ • 파일 크기 증가                                │
└─────────────────────────────────────────────────┘

분리 후 (CSS 파일 분리):
┌─────────────────────────────────────────────────┐
│ HTML: <p class="text">텍스트</p>                 │
│ CSS:  .text { color:red; font-size:14px; }      │
│                                                 │
│ 장점:                                           │
│ • 재사용성 향상                                 │
│ • 유지보수 용이                                 │
│ • 캐싱 효율성                                   │
│ • 역할 분담 가능 (디자이너 vs 개발자)            │
└─────────────────────────────────────────────────┘`
```

### 2단계: 동적 요소 추가 (JavaScript 등장)

**이렇게 발전해 오다가 1990년 중반으로 넘어오고 새로운 문서 뷰어가 나오게 되는데 그것이 넷스케이프 내비게이터**다. 이 **문서, 즉 정적인 문서 책이나 신문 같은 문서와 유사한데 이 정적인 문서에 어떤 움직임을 넣어준다거나 문서의 내용이 그때그때 바뀔 수 있는 어떤 동적인 제어가 가능한 무언가를 만들려고 노력**을 했다.

**즉 예전에는 그냥 문서만 받고 끝이었다면 이제는 문서를 받고 그 문서에 어떤 움직임을 추가하게 된 것**이다.

그래서 이 **문서 뷰어에 동적인 요소를 반영하려고 한 것**이다. 당연히 이 **동적 움직임에는 특정한 규칙이 필요하고 그 규칙을 따라야만 했고 그 규칙이라는 것을 스크립트 형태로 기술하게 된다**. 그래서 **탄생한 최초의 스크립트가 Mocha Script**였다. 그다음에 **몇 달 후에 LiveScript라는 이름으로 명칭을 변경**한다.

그리고 **최종적으로 JavaScript라는 이름을 쓰게 된다**.

```
				`PC ────→ 인터넷 ──→ Web Server
				(웹 클라이언트)                        │
				   브라우저                            │
				    │          HTTP                   │ HTML + CSS + JavaScript
				    │    ←─ TCP/IP ─→                 │ + JPG 리소스
				    │                                 │
				    │ http://request, method=GET      │
				    │      ────────→                  │
브라우저    │    HTML + CSS + JavaScript      │
http://get  │   ←──────────────────────       │
요청 문서   │                                 │
	꾸밈      │                                 │
움직임     │                                  │`

```

```

`JavaScript 발전사:

1995년 5월: Mocha Script (넷스케이프)
┌─────────────────────────────────────────────────┐
│ • 브랜든 아이크가 10일 만에 개발                 │
│ • 간단한 스크립팅 언어로 설계                    │
└─────────────────────────────────────────────────┘

1995년 9월: LiveScript
┌─────────────────────────────────────────────────┐
│ • 베타 버전에서 LiveScript로 명명                │
│ • 동적 웹페이지 구현을 위한 목적                 │
└─────────────────────────────────────────────────┘

1995년 12월: JavaScript
┌─────────────────────────────────────────────────┐
│ • 선 마이크로시스템즈와 파트너십                 │
│ • Java 인기에 편승한 마케팅적 네이밍             │
│ • 실제로는 Java와 다른 언어                     │
└─────────────────────────────────────────────────┘

JavaScript의 역할:
┌─────────────────────────────────────────────────┐
│ • DOM 조작 (요소 생성, 수정, 삭제)               │
│ • 이벤트 처리 (클릭, 입력, 스크롤 등)            │
│ • 애니메이션 효과                               │
│ • 동적 콘텐츠 생성                              │
│ • 사용자 상호작용 처리                          │
└─────────────────────────────────────────────────┘`
```

## 브라우저의 진화

그러니 **이제 HTML 문서를 렌더링을 해야 되는데** 그 전에 생각해보면 **예전에는 단순한 텍스트밖에 없었는데 이제는 움직임과 꾸밈이 추가되면서 구문 분석이라는 것을 하게 된 것**이다. 이 **구문 분석이라고 하면 태그와 텍스트를 분리해서 해당 태그를 해석해서 거기에 맞게 화면을 만들어(렌더링) 주게 되는 것**이다.

그래서 **이제 브라우저의 역할이 구문을 분석해야 되고 그 분석된 구문을 기반으로 화면을 렌더링해야 되기 때문에 파서와 렌더링 엔진이 포함되기 시작했다. 여기에 움직임까지 추가되면서 JavaScript 엔진까지 추가되게 된 것**이다.

**결국 이 JavaScript도 코드이기 때문에 결국 서버에 위치하게 된다. 그래서 결국 문서를 포함한 이러한 요소들이 HTTP 요청에 대한 응답이 되는 것**이다.

그래서 **현대에 들어서는 정적인 동적 문서의 형태로 발전하게 된 것**이다.

```
브라우저 엔진의 진화:

초기 브라우저 (텍스트 뷰어):
┌─────────────────────────────────────────────────┐
│ • 단순 텍스트 파싱                              │
│ • 기본적인 HTML 태그 해석                       │
│ • 링크 클릭 기능                                │
└─────────────────────────────────────────────────┘

HTML + CSS 시대:
┌─────────────────────────────────────────────────┐
│ HTML Parser: 구조 분석                          │
│ CSS Parser: 스타일 규칙 해석                     │
│ Rendering Engine: 레이아웃 계산 및 화면 그리기   │
└─────────────────────────────────────────────────┘

현대 브라우저 (JavaScript 추가):
┌─────────────────────────────────────────────────┐
│ HTML Parser: DOM 트리 생성                      │
│ CSS Parser: CSSOM 트리 생성                     │
│ JavaScript Engine: V8, SpiderMonkey 등         │
│ Rendering Engine: 레이아웃, 페인팅, 컴포지팅     │
│ Event System: 사용자 상호작용 처리              │
└─────────────────────────────────────────────────┘

브라우저 렌더링 과정:
┌─────────────────────────────────────────────────┐
│ 1. HTML 파싱 → DOM 트리 생성                    │
│ 2. CSS 파싱 → CSSOM 트리 생성                   │
│ 3. DOM + CSSOM → 렌더 트리 생성                 │
│ 4. 레이아웃 (Reflow) → 요소 위치 계산           │
│ 5. 페인팅 (Repaint) → 픽셀 그리기               │
│ 6. 컴포지팅 → 레이어 합성                       │
└─────────────────────────────────────────────────┘
```

## 양방향 상호작용의 필요성 (POST 등장)

그래서 **GET은 다운로드의 성격이 강하다 (주세요!). 그래서 이 문서를 요청하고 받는다. 딱 여기까지만 보자면 단방향 작용**이다. **양방향 상호작용이 아닌 것**이다. **초창기에는 단순히 문서를 받는 데에만 그쳤기 때문에 어떤 이 문서에 대해 개입할 방법이 전혀 없었다**.

그래서 **이러한 단방향적인 관계를 어떻게 해결할 것인가에 대한 많은 고민이 이루어졌다**. 그래서 **이 메서드가 GET 이외에 다른 메서드가 등장했는데 그것이 POST**이다.

그래서 **우리가 대표적으로 로그인 아이디와 비밀번호를 입력하고 로그인 버튼을 눌렀을 때를 생각해보면 이해하기 쉽다**. **즉 GET은 서버로부터 일방적으로 문서를 요청하고 받았다면 POST는 반대로 서버에게 특정한 데이터를 등록해달라고 요청할 수 있게 됨으로써 양방향 상호작용을 하게 된 것**이다.

```
웹 상호작용의 진화:

1세대: 읽기 전용 웹 (GET only)
┌─────────────────────────────────────────────────┐
│ 사용자 → [문서 요청] → 서버                      │
│ 사용자 ← [문서 응답] ← 서버                      │
│                                                 │
│ 특징:                                           │
│ • 단방향 정보 소비                              │
│ • 정적 콘텐츠만 제공                            │
│ • 사용자 개인화 불가                            │
└─────────────────────────────────────────────────┘

2세대: 상호작용 웹 (GET + POST)
┌─────────────────────────────────────────────────┐
│ 사용자 → [로그인 정보] → 서버                    │
│ 사용자 ← [개인화된 페이지] ← 서버                │
│                                                 │
│ 가능해진 기능:                                   │
│ • 사용자 인증/로그인                            │
│ • 게시판 글 작성                                │
│ • 온라인 쇼핑                                   │
│ • 사용자별 맞춤 콘텐츠                          │
└─────────────────────────────────────────────────┘

현대: RESTful 웹 (다양한 HTTP 메서드)
┌─────────────────────────────────────────────────┐
│ GET: 조회    PUT: 전체 수정                     │
│ POST: 생성   DELETE: 삭제                       │
│ PATCH: 부분 수정                                │
└─────────────────────────────────────────────────┘
```

## 상태 관리의 필요성

근데 **여기서 문제가 발생하게 되는데 이 어떠한 상호작용을 하게 된다는 것은 어떤 문맥 등의 상태가 전이하는 게 발생한다. 그런데 HTTP는 무상태**이다.

그러니까 **클라이언트와 웹서버 간에 어떠한 작업을 했다. 예를 들어 어제 누군가 만나서 대화를 하고 다음날 다시 대화를 한다고 했을 때 이전에 했던 대화가 이어져야 한다. 이와 같이 이 어떤 작업에 대한 특정한 상태를 어디간에 저장해 두지 않으면 알 수 없다**.

그래서 **필연적으로 따라오게 된 것이 이 상태에 대해서 어디간에 기억을 시켜야 될 필요가 생긴 것**이다.

근데 **그 기억은 상대방도 하고 나도 해야 되는 것처럼 클라이언트도 하고 서버도 해야 되는 것**이다.

그래서 **이 기억이라는 것을 클라이언트 쪽에서도 구현하게 되고 서버쪽에서 구현하게 된 것**이다.

**이 기억이라는 것은 똑같은 내용을 양쪽이 같이 해야 되는 것**이다.

**이때 서버측은 기억해야 될 사람이 많을 것이다. 반대로 손님은 자기 혼자만 기억하면 되는 것**이고,

그래서 **클라이언트 측에서는 이 기억을 쿠키의 형태로 구현되게 되었다. 서버는 기억해야 될 것이 너무나 많기 때문에 데이터베이스의 형태로 만들게 되었다**.

```
상태 관리 솔루션:

HTTP의 무상태 문제:
┌─────────────────────────────────────────────────┐
│ 요청 1: 로그인 성공                             │
│ 요청 2: 장바구니 추가 ← 누가 로그인했는지 모름   │
│ 요청 3: 결제 시도 ← 장바구니가 누구 것인지 모름  │
└─────────────────────────────────────────────────┘

해결책 1: 쿠키 (클라이언트 측 저장)
┌─────────────────────────────────────────────────┐
│ 서버 → 클라이언트: Set-Cookie: sessionId=abc123  │
│ 클라이언트 → 서버: Cookie: sessionId=abc123      │
│                                                 │
│ 특징:                                           │
│ • 클라이언트 브라우저에 저장                     │
│ • 자동으로 요청에 포함됨                        │
│ • 용량 제한 (4KB)                              │
│ • 보안 위험 (XSS, CSRF)                        │
└─────────────────────────────────────────────────┘

해결책 2: 세션 (서버 측 저장)
┌─────────────────────────────────────────────────┐
│ 서버 메모리/DB:                                 │
│ sessionId=abc123 → {userId: 100, cart: [...]}   │
│                                                 │
│ 특징:                                           │
│ • 서버에 실제 데이터 저장                        │
│ • 클라이언트에는 세션ID만 저
│ • 서버에 실제 데이터 저장                        │
│ • 클라이언트에는 세션ID만 저장                   │
│ • 보안성 높음                                   │
│ • 서버 확장성 문제 (세션 공유 필요)              │
└─────────────────────────────────────────────────┘

현대적 해결책: JWT 토큰
┌─────────────────────────────────────────────────┐
│ • 상태 정보를 토큰에 포함                        │
│ • 서버에서 상태 저장 불필요                      │
│ • 확장성 우수                                   │
│ • 토큰 크기 증가 문제                           │
└─────────────────────────────────────────────────┘
```

## 3계층 웹 아키텍처의 등장

**그래서 다시 로그인으로 돌아와서 클라이언트가 POST로 아이디와 패스워드 데이터를 보내는데 이 서버 입장에서 해당 데이터들은 원격지에 있는 사용자 입력 데이터**이다. 따라서 **서버 입장에서는 원격지 사용자 입력 데이터를 신뢰해서는 안 된다. 해당 데이터는 반드시 검증해야 되는 검증 대상**이다. 그래서 **해당 데이터들이 맞는지 검증하기 위해서 데이터베이스에 저장되어 있는 데이터와 비교해본다**. **사용자 입력 데이터가 id가 test1234에 비밀번호 1234인 데이터가 데이터베이스에 있는지 조회해 보면 된다**.

```
Web Server ←─→ 중간 처리 서버 ←─→ 데이터베이스
```

그러면 **웹서버가 데이터베이스에게 조회를 할 때 직접 연결해서 조회를 하는 것은 아니고 중간에 특정 서버를 하나 두고 그 서버를 통해서 웹서버와 데이터베이스가 서로 연동하게 되는 것**이다.

그래서 이 **웹서버는 기본적인 역할은 송수신 역할**이다. **데이터베이스의 역할은 자료 담당**이다. 그러면 **중간에 있는 서버는 무엇인가 하면 처리를 담당**한다.

그래서 **웹서버가 아까 사용자 입력 데이터를 꺼내서 처리 담당자에게 보내주면 그 처리 담당자가 이를 검증하고 새로운 문서를 만들어서 반환해준다**. 즉, **아까 로그인한 후에 "로그인ID님 안녕하세요"와 같이 사용자에 따라 내용이 변하는 동적인 문서를 생성하여 반환**한다.

그래서 **이 중간처리 서버와 데이터베이스는 여러 인터페이스로 연결이 된다(JDBC, ODBC). 연결된 상태에서 SQL문을 실행시켜서 데이터를 조회하는데** 위와 같이 **조회가 성공해서 동적 문서를 성공적(FOUND)으로 만들었는데 만약 데이터를 찾지 못한다면 "너 누구야?"라는 문서를 보낸다 (NOT FOUND)**.

그래서 **이 중간에서 처리를 담당하는 이 서버를 WAS(Web Application Server)라고 한다. 그래서 이 WAS에서 컨트롤이라는 제어 체계가 포함**된다.

```
3계층 웹 아키텍처:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Web Server     │    │      WAS        │    │   Database      │
│ (Presentation)  │    │  (Application)  │    │     (Data)      │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • HTTP 처리     │    │ • 비즈니스 로직 │    │ • 데이터 저장   │
│ • 정적 파일     │    │ • 동적 콘텐츠   │    │ • 트랜잭션 처리 │
│ • 로드 밸런싱   │◄──►│ • 세션 관리     │◄──►│ • 데이터 무결성 │
│ • SSL 종료      │    │ • 인증/인가     │    │ • 백업/복구     │
│ • 캐싱          │    │ • API 처리      │    │ • 성능 최적화   │
└─────────────────┘    └─────────────────┘    └─────────────────┘

각 계층의 역할:

1계층 - Web Server (송수신 담당):
┌─────────────────────────────────────────────────┐
│ • 클라이언트 요청 수신                           │
│ • 정적 리소스 제공 (HTML, CSS, JS, 이미지)       │
│ • 요청 라우팅 및 로드 밸런싱                     │
│ • SSL/TLS 처리                                  │
│ • 압축, 캐싱                                    │
│                                                 │
│ 대표 제품: Apache, Nginx, IIS                   │
└─────────────────────────────────────────────────┘

2계층 - WAS (처리 담당):
┌─────────────────────────────────────────────────┐
│ • 동적 콘텐츠 생성                              │
│ • 비즈니스 로직 실행                            │
│ • 데이터베이스 연동                             │
│ • 세션 관리                                     │
│ • 트랜잭션 처리                                 │
│ • 보안 검증                                     │
│                                                 │
│ 대표 제품: Tomcat, WebLogic, WebSphere          │
└─────────────────────────────────────────────────┘

3계층 - Database (자료 담당):
┌─────────────────────────────────────────────────┐
│ • 데이터 영구 저장                              │
│ • CRUD 연산 처리                                │
│ • 데이터 무결성 보장                            │
│ • 트랜잭션 관리                                 │
│ • 동시성 제어                                   │
│ • 백업 및 복구                                  │
│                                                 │
│ 대표 제품: MySQL, PostgreSQL, Oracle, MSSQL     │
└─────────────────────────────────────────────────┘
```

## 실제 로그인 처리 과정

```
로그인 처리 시나리오:

1. 사용자 입력:
┌─────────────────────────────────────────────────┐
│ 브라우저에서 아이디/비밀번호 입력                │
│ POST /login                                     │
│ Content-Type: application/x-www-form-urlencoded │
│ userid=test1234&password=1234                   │
└─────────────────────────────────────────────────┘

2. Web Server 처리:
┌─────────────────────────────────────────────────┐
│ • HTTP 요청 수신                                │
│ • 정적 파일 여부 확인                           │
│ • 동적 요청이므로 WAS로 전달                     │
└─────────────────────────────────────────────────┘

3. WAS 처리:
┌─────────────────────────────────────────────────┐
│ • 요청 파라미터 추출 및 검증                     │
│ • 입력값 보안 검사 (SQL Injection, XSS 방지)    │
│ • 비즈니스 로직 실행 (로그인 검증)               │
│ • 데이터베이스 조회 요청                        │
└─────────────────────────────────────────────────┘

4. Database 처리:
┌─────────────────────────────────────────────────┐
│ SQL: SELECT * FROM users                        │
│      WHERE userid='test1234'                    │
│        AND password=SHA256('1234')              │
│                                                 │
│ 결과:                                           │
│ • 성공: 사용자 정보 반환                        │
│ • 실패: 빈 결과 반환                            │
└─────────────────────────────────────────────────┘

5. 응답 생성:
┌─────────────────────────────────────────────────┐
│ 성공 시:                                        │
│ • 세션 생성 (서버 메모리/DB 저장)                │
│ • 쿠키 설정 (세션ID 클라이언트 전송)             │
│ • 개인화 페이지 HTML 생성                       │
│ • "test1234님 안녕하세요!" 메시지 포함           │
│                                                 │
│ 실패 시:                                        │
│ • 에러 메시지 HTML 생성                         │
│ • "아이디 또는 비밀번호가 잘못되었습니다"        │
└─────────────────────────────────────────────────┘
```

## 현대 웹 아키텍처의 진화

```
현대 웹 아키텍처 (마이크로서비스):

전통적 3계층:
┌─────────────────────────────────────────────────┐
│ Web Server → WAS → Database                     │
│ (단일 애플리케이션)                             │
└─────────────────────────────────────────────────┘

현대적 구조:
┌─────────────────────────────────────────────────┐
│                Load Balancer                    │
│                      │                         │
│    ┌─────────────────┼─────────────────┐       │
│    │                 │                 │       │
│ Web Server      API Gateway      CDN           │
│    │                 │                 │       │
│    │         ┌───────┼───────┐         │       │
│    │         │       │       │         │       │
│    │    Auth Service │  User Service   │       │
│    │         │       │       │         │       │
│    │    Order Service│ Payment Service │       │
│    │         │       │       │         │       │
│    │    ┌────┴───┬───┴───┬───┴────┐    │       │
│    │    │        │       │        │    │       │
│    │   DB1      DB2     DB3      Cache │       │
└─────────────────────────────────────────────────┘

장점:
- 독립적 배포 및 확장
- 기술 스택 다양화
- 장애 격리
- 팀별 독립 개발
```

## 보안 고려사항

```
웹 애플리케이션 보안:

입력 데이터 검증:
┌─────────────────────────────────────────────────┐
│ 클라이언트 입력은 절대 신뢰하지 않음             │
│                                                 │
│ 검증 항목:                                      │
│ • 데이터 타입 검증                              │
│ • 길이 제한 검증                                │
│ • 형식 검증 (이메일, 전화번호 등)               │
│ • SQL Injection 방지                           │
│ • XSS (Cross-Site Scripting) 방지              │
│ • CSRF (Cross-Site Request Forgery) 방지       │
└─────────────────────────────────────────────────┘

인증 및 인가:
┌─────────────────────────────────────────────────┐
│ 인증 (Authentication): "당신은 누구인가?"        │
│ • 아이디/비밀번호                               │
│ • 2FA (Two-Factor Authentication)              │
│ • OAuth, SAML                                  │
│                                                 │
│ 인가 (Authorization): "무엇을 할 수 있는가?"     │
│ • 역할 기반 접근 제어 (RBAC)                    │
│ • 속성 기반 접근 제어 (ABAC)                    │
│ • JWT 토큰 기반 권한 관리                       │
└─────────────────────────────────────────────────┘

데이터 보호:
┌─────────────────────────────────────────────────┐
│ 전송 중 보호: HTTPS/TLS                         │
│ 저장 중 보호: 암호화, 해싱                      │
│ 개인정보 보호: GDPR, 개인정보보호법 준수         │
└─────────────────────────────────────────────────┘
```

이러한 **웹 서비스 구조의 발전 과정**을 이해하면 **현대 웹 애플리케이션의 복잡성과 각 구성 요소의 역할**을 명확히 파악할 수 있고, **확장 가능하고 보안성 높은 시스템 설계**의 기초를 다질 수 있습니다.