# 웹 서비스 구조

## 기본 웹 통신 구조

```
Web Client                Web Server

       TCP/IP 연결 및 HTTP 세션 생성
           ------->
       HTML 문서 전송 요청(GET)    
          ------->
    서버에서 HTML 문서를 수신하고 연결 종료
          <------
```

**기본적으로 웹에서 사용하는 통신 프로토콜은 HTTP**이다. **이때 HTTP의 연결은 TCP 연결 그다음에 존재**한다.

**HTTP 트래픽이라고 하면 소켓 수준에서 만들어지는 것이고, 따라서 스트림의 형태 즉, 끝을 알기 어려운 데이터의 처리**를 말한다.

**문제는 네트워크로 무엇인가를 보낼 때는 여기 TCP/IP에서 MTU가 1500바이트뿐이니 이 스트림 데이터를 세그먼트 단위로 쪼개서 패킷에 담아(인캡슐레이션) 전송**한다.

그래서 **웹에 대해서는 패킷이니 세그먼트이니 이런 단위는 나오지 않는다. 바로 스트림 수준에서 이야기**한다. 특히 **송수신 프로토콜인 HTTP는 문자열로 되어있어서 간단한 구조를 가지고 있으며 항상 핵심은 문서의 요청과 요청받은 문서를 수신하는 것**이다.

**웹이라고 하는 기술의 가장 근간이 되는 두 가지 기술은 HTML과 HTTP**이다. **즉 문서와 그걸 실어 나르는 방법**이다.

```
프로토콜 스택과 웹 통신:

응용 계층 (L7): HTTP (HyperText Transfer Protocol)
┌─────────────────────────────────────────────────┐
│ • 텍스트 기반 프로토콜                           │
│ • 요청-응답 모델                                │
│ • 무상태(Stateless) 특성                       │
└─────────────────────────────────────────────────┘
                        ↓
전송 계층 (L4): TCP (Transmission Control Protocol)
┌─────────────────────────────────────────────────┐
│ • 연결 지향, 신뢰성 보장                         │
│ • 스트림 데이터 처리                            │
│ • 3-Way Handshake 연결 설정                    │
└─────────────────────────────────────────────────┘
                        ↓
네트워크 계층 (L3): IP (Internet Protocol)
┌─────────────────────────────────────────────────┐
│ • 패킷 단위 전송 (MTU 1500 bytes 제한)          │
│ • 라우팅 및 주소 지정                           │
│ • 큰 데이터는 분할 전송 후 재조립                │
└─────────────────────────────────────────────────┘
```

## TCP vs HTTP의 상태 관리

```
					PC ────→ 인터넷 ──→ Web Server
					(웹 클라이언트)                    │
					   브라우저                        │
					    │          HTTP              │ HTML 문서
					    │    ←─ TCP/IP ─→            │ 리소스
					    │                            │
					    │ http://request, method=GET  │
					    │      ────────→             │
		브라우저  │    HTML Response           │
	http://get  │   ←────────────           │
	요청 문서   │                            │
						   │                            │
```

이 **웹 기술이라는 것은 HTML과 HTTP 구현**이 된다고 하지만 **기본적으로 웹 클라이언트와 웹 서버 간에 TCP 연결을 기반으로 HTTP 통신이 이루어지는 것**이다. **TCP/IP 연결을 할 때 상태에 관해서 말을 하는데 반면에 HTTP가 가지고 있는 매우 중요한 특징은 바로 Stateless 무상태**이다. **즉 상태라는 개념이 없다**.

**연결이라는 개념은 TCP에 있는 것이고 HTTP는 그런 개념이 존재하지 않는다**.

```
TCP vs HTTP 상태 관리 비교:

TCP 계층 (연결 지향):
┌─────────────────────────────────────────────────┐
│ • Connection State: ESTABLISHED, FIN-WAIT 등    │
│ • 순서번호, 윈도우 크기 관리                     │
│ • 연결 유지 상태 추적                           │
│ • 세션 정보 유지                                │
└─────────────────────────────────────────────────┘

HTTP 계층 (무상태):
┌─────────────────────────────────────────────────┐
│ • 각 요청은 독립적                              │
│ • 이전 요청 정보 기억하지 않음                   │
│ • 서버는 클라이언트 상태 모름                    │
│ • 확장성과 단순성 제공                          │
└─────────────────────────────────────────────────┘

문제점과 해결책:
┌─────────────────────────────────────────────────┐
│ 문제: 사용자 인증, 장바구니 등 상태 필요         │
│ 해결: 쿠키, 세션, 토큰 등으로 상태 관리          │
└─────────────────────────────────────────────────┘
```

## 초기 웹의 단순한 구조

**팀 버너스 리가 초기에 웹을 만들었을 때 HTML 문서를 주고받는 것**이었고 따라서 이 **클라이언트에 해당되는 브라우저의 본질적인 역할은 문서 뷰어**였다. 근데 **이제 다른 뷰어들과의 차이점은 인터넷 어딘가 웹서버에 저장되어 있는 문서(리소스)를 가져오는 데에 있어서 차이**가 있었다.

**이것이 초창기 웹의 형태**이다.

```
초기 웹 아키텍처 (1990년대 초):

Client (브라우저)          Server (웹서버)
┌─────────────────┐      ┌─────────────────┐
│ • 문서 뷰어     │      │ • 정적 HTML     │
│ • HTML 파싱     │ ←──→ │   파일 저장     │
│ • 텍스트 표시   │      │ • 파일 전송     │
└─────────────────┘      └─────────────────┘

특징:
- 단순한 요청-응답 모델
- 정적 컨텐츠만 제공
- 사용자 상호작용 없음
- 읽기 전용 웹
```

## MVC 패턴의 필요성

**개발 시 UI, 데이터 영역, 제어체계(MVC) 이 3가지를 꼭 분리시켜라를 기본**으로 하고 있고 **좋은 설계라고 하면 결국 유지보수하기 용이한 설계**를 말하는데 그렇다면 **왜 MVC가 유지보수하기 효율적인가 하면 만약 UI와 데이터가 한곳에 있으면 데이터를 수정하면 반드시 화면도 같이 수정해야만 한다. 혹은 화면을 수정하는데 자료구조도 같이 변경되거나 하는 문제가 발생**한다.

```
MVC 패턴의 필요성:

문제가 되는 구조 (UI + Data 결합):
┌─────────────────────────────────────────────────┐
│ HTML + 데이터 로직이 한 파일에 모두 존재         │
│                                                 │
│ 문제점:                                         │
│ • 데이터 변경 → UI 수정 필수                    │
│ • UI 변경 → 데이터 로직 영향                    │
│ • 코드 재사용 어려움                            │
│ • 테스트 복잡함                                 │
│ • 협업 시 충돌 발생                             │
└─────────────────────────────────────────────────┘

MVC 패턴 적용:
┌─────────────────────────────────────────────────┐
│ Model (데이터 + 비즈니스 로직)                   │
│ • 데이터 구조 정의                              │
│ • 비즈니스 규칙 처리                            │
│ • 데이터베이스 연동                             │
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│ Controller (제어 로직)                          │
│ • 사용자 입력 처리                              │
│ • Model과 View 조정                            │
│ • 비즈니스 흐름 제어                            │
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│ View (사용자 인터페이스)                        │
│ • 데이터 표시                                   │
│ • 사용자 입력 인터페이스                        │
│ • 화면 레이아웃                                 │
└─────────────────────────────────────────────────┘
```

## 웹 기술의 발전 과정

### 1단계: HTML 문서의 스타일링 (CSS 등장)

**위의 내용을 상기한 채로 이 웹이 어떤 식으로 발전을 했느냐 하면 처음에는 문서 요청하고 그 문서를 받아서 처리하는 것만으로도 좋았는데 하다 보니까 이 문서를 좀 예쁘게 꾸밀 필요가 생겼다**. 그래서 이 **HTML 문서에 좀 더 이쁘게 보이게끔 하는 문법을 추가**한다. 그러면 **지금 한 문서에 데이터와 UI가 공존하게 됐는데** 간단하게 생각해서 **문서를 꾸미겠다고 논문을 뜯어고치면 될까? 당연히 말도 안 된다**. 그래서 **그 둘을 분리하게 된다**.

**HTML 안에 한 번에 기술할 수 있었지만 이를 분리시킨다. 그렇게 해서 문서와 이를 꾸미기 위한 문법이 분리된다. 그것이 CSS 스타일시트라는 게 필요해진 것**이다.

```
			`PC ────→ 인터넷 ──→ Web Server
			(웹 클라이언트)                    │
			   브라우저                        │
			    │          HTTP              │ HTML 문서 + CSS
			    │    ←─ TCP/IP ─→            │ 리소스
			    │                            │
			    │ http://request, method=GET  │
			    │      ────────→             │
브라우저   │    HTML + CSS              │
http://get │   ←───────────────         │
요청 문서   │                            │
			     │                            │`
```

```

`HTML + CSS 분리의 장점:

분리 전 (HTML 내 스타일 포함):
┌─────────────────────────────────────────────────┐
│ <p style="color:red; font-size:14px;">텍스트</p> │
│ <p style="color:red; font-size:14px;">텍스트2</p>│
│                                                 │
│ 문제점:                                         │
│ • 스타일 중복                                   │
│ • 유지보수 어려움                               │
│ • 파일 크기 증가                                │
└─────────────────────────────────────────────────┘

분리 후 (CSS 파일 분리):
┌─────────────────────────────────────────────────┐
│ HTML: <p class="text">텍스트</p>                 │
│ CSS:  .text { color:red; font-size:14px; }      │
│                                                 │
│ 장점:                                           │
│ • 재사용성 향상                                 │
│ • 유지보수 용이                                 │
│ • 캐싱 효율성                                   │
│ • 역할 분담 가능 (디자이너 vs 개발자)            │
└─────────────────────────────────────────────────┘`
```

### 2단계: 동적 요소 추가 (JavaScript 등장)

**이렇게 발전해 오다가 1990년 중반으로 넘어오고 새로운 문서 뷰어가 나오게 되는데 그것이 넷스케이프 내비게이터**다. 이 **문서, 즉 정적인 문서 책이나 신문 같은 문서와 유사한데 이 정적인 문서에 어떤 움직임을 넣어준다거나 문서의 내용이 그때그때 바뀔 수 있는 어떤 동적인 제어가 가능한 무언가를 만들려고 노력**을 했다.

**즉 예전에는 그냥 문서만 받고 끝이었다면 이제는 문서를 받고 그 문서에 어떤 움직임을 추가하게 된 것**이다.

그래서 이 **문서 뷰어에 동적인 요소를 반영하려고 한 것**이다. 당연히 이 **동적 움직임에는 특정한 규칙이 필요하고 그 규칙을 따라야만 했고 그 규칙이라는 것을 스크립트 형태로 기술하게 된다**. 그래서 **탄생한 최초의 스크립트가 Mocha Script**였다. 그다음에 **몇 달 후에 LiveScript라는 이름으로 명칭을 변경**한다.

그리고 **최종적으로 JavaScript라는 이름을 쓰게 된다**.

```
				`PC ────→ 인터넷 ──→ Web Server
				(웹 클라이언트)                        │
				   브라우저                            │
				    │          HTTP                   │ HTML + CSS + JavaScript
				    │    ←─ TCP/IP ─→                 │ + JPG 리소스
				    │                                 │
				    │ http://request, method=GET      │
				    │      ────────→                  │
브라우저    │    HTML + CSS + JavaScript      │
http://get  │   ←──────────────────────       │
요청 문서   │                                 │
	꾸밈      │                                 │
움직임     │                                  │`

```

```

`JavaScript 발전사:

1995년 5월: Mocha Script (넷스케이프)
┌─────────────────────────────────────────────────┐
│ • 브랜든 아이크가 10일 만에 개발                 │
│ • 간단한 스크립팅 언어로 설계                    │
└─────────────────────────────────────────────────┘

1995년 9월: LiveScript
┌─────────────────────────────────────────────────┐
│ • 베타 버전에서 LiveScript로 명명                │
│ • 동적 웹페이지 구현을 위한 목적                 │
└─────────────────────────────────────────────────┘

1995년 12월: JavaScript
┌─────────────────────────────────────────────────┐
│ • 선 마이크로시스템즈와 파트너십                 │
│ • Java 인기에 편승한 마케팅적 네이밍             │
│ • 실제로는 Java와 다른 언어                     │
└─────────────────────────────────────────────────┘

JavaScript의 역할:
┌─────────────────────────────────────────────────┐
│ • DOM 조작 (요소 생성, 수정, 삭제)               │
│ • 이벤트 처리 (클릭, 입력, 스크롤 등)            │
│ • 애니메이션 효과                               │
│ • 동적 콘텐츠 생성                              │
│ • 사용자 상호작용 처리                          │
└─────────────────────────────────────────────────┘`
```

## 브라우저의 진화

그러니 **이제 HTML 문서를 렌더링을 해야 되는데** 그 전에 생각해보면 **예전에는 단순한 텍스트밖에 없었는데 이제는 움직임과 꾸밈이 추가되면서 구문 분석이라는 것을 하게 된 것**이다. 이 **구문 분석이라고 하면 태그와 텍스트를 분리해서 해당 태그를 해석해서 거기에 맞게 화면을 만들어(렌더링) 주게 되는 것**이다.

그래서 **이제 브라우저의 역할이 구문을 분석해야 되고 그 분석된 구문을 기반으로 화면을 렌더링해야 되기 때문에 파서와 렌더링 엔진이 포함되기 시작했다. 여기에 움직임까지 추가되면서 JavaScript 엔진까지 추가되게 된 것**이다.

**결국 이 JavaScript도 코드이기 때문에 결국 서버에 위치하게 된다. 그래서 결국 문서를 포함한 이러한 요소들이 HTTP 요청에 대한 응답이 되는 것**이다.

그래서 **현대에 들어서는 정적인 동적 문서의 형태로 발전하게 된 것**이다.

```
브라우저 엔진의 진화:

초기 브라우저 (텍스트 뷰어):
┌─────────────────────────────────────────────────┐
│ • 단순 텍스트 파싱                              │
│ • 기본적인 HTML 태그 해석                       │
│ • 링크 클릭 기능                                │
└─────────────────────────────────────────────────┘

HTML + CSS 시대:
┌─────────────────────────────────────────────────┐
│ HTML Parser: 구조 분석                          │
│ CSS Parser: 스타일 규칙 해석                     │
│ Rendering Engine: 레이아웃 계산 및 화면 그리기   │
└─────────────────────────────────────────────────┘

현대 브라우저 (JavaScript 추가):
┌─────────────────────────────────────────────────┐
│ HTML Parser: DOM 트리 생성                      │
│ CSS Parser: CSSOM 트리 생성                     │
│ JavaScript Engine: V8, SpiderMonkey 등         │
│ Rendering Engine: 레이아웃, 페인팅, 컴포지팅     │
│ Event System: 사용자 상호작용 처리              │
└─────────────────────────────────────────────────┘

브라우저 렌더링 과정:
┌─────────────────────────────────────────────────┐
│ 1. HTML 파싱 → DOM 트리 생성                    │
│ 2. CSS 파싱 → CSSOM 트리 생성                   │
│ 3. DOM + CSSOM → 렌더 트리 생성                 │
│ 4. 레이아웃 (Reflow) → 요소 위치 계산           │
│ 5. 페인팅 (Repaint) → 픽셀 그리기               │
│ 6. 컴포지팅 → 레이어 합성                       │
└─────────────────────────────────────────────────┘
```

## 양방향 상호작용의 필요성 (POST 등장)

그래서 **GET은 다운로드의 성격이 강하다 (주세요!). 그래서 이 문서를 요청하고 받는다. 딱 여기까지만 보자면 단방향 작용**이다. **양방향 상호작용이 아닌 것**이다. **초창기에는 단순히 문서를 받는 데에만 그쳤기 때문에 어떤 이 문서에 대해 개입할 방법이 전혀 없었다**.

그래서 **이러한 단방향적인 관계를 어떻게 해결할 것인가에 대한 많은 고민이 이루어졌다**. 그래서 **이 메서드가 GET 이외에 다른 메서드가 등장했는데 그것이 POST**이다.

그래서 **우리가 대표적으로 로그인 아이디와 비밀번호를 입력하고 로그인 버튼을 눌렀을 때를 생각해보면 이해하기 쉽다**. **즉 GET은 서버로부터 일방적으로 문서를 요청하고 받았다면 POST는 반대로 서버에게 특정한 데이터를 등록해달라고 요청할 수 있게 됨으로써 양방향 상호작용을 하게 된 것**이다.

```
웹 상호작용의 진화:

1세대: 읽기 전용 웹 (GET only)
┌─────────────────────────────────────────────────┐
│ 사용자 → [문서 요청] → 서버                      │
│ 사용자 ← [문서 응답] ← 서버                      │
│                                                 │
│ 특징:                                           │
│ • 단방향 정보 소비                              │
│ • 정적 콘텐츠만 제공                            │
│ • 사용자 개인화 불가                            │
└─────────────────────────────────────────────────┘

2세대: 상호작용 웹 (GET + POST)
┌─────────────────────────────────────────────────┐
│ 사용자 → [로그인 정보] → 서버                    │
│ 사용자 ← [개인화된 페이지] ← 서버                │
│                                                 │
│ 가능해진 기능:                                   │
│ • 사용자 인증/로그인                            │
│ • 게시판 글 작성                                │
│ • 온라인 쇼핑                                   │
│ • 사용자별 맞춤 콘텐츠                          │
└─────────────────────────────────────────────────┘

현대: RESTful 웹 (다양한 HTTP 메서드)
┌─────────────────────────────────────────────────┐
│ GET: 조회    PUT: 전체 수정                     │
│ POST: 생성   DELETE: 삭제                       │
│ PATCH: 부분 수정                                │
└─────────────────────────────────────────────────┘
```

## 상태 관리의 필요성

근데 **여기서 문제가 발생하게 되는데 이 어떠한 상호작용을 하게 된다는 것은 어떤 문맥 등의 상태가 전이하는 게 발생한다. 그런데 HTTP는 무상태**이다.

그러니까 **클라이언트와 웹서버 간에 어떠한 작업을 했다. 예를 들어 어제 누군가 만나서 대화를 하고 다음날 다시 대화를 한다고 했을 때 이전에 했던 대화가 이어져야 한다. 이와 같이 이 어떤 작업에 대한 특정한 상태를 어디간에 저장해 두지 않으면 알 수 없다**.

그래서 **필연적으로 따라오게 된 것이 이 상태에 대해서 어디간에 기억을 시켜야 될 필요가 생긴 것**이다.

근데 **그 기억은 상대방도 하고 나도 해야 되는 것처럼 클라이언트도 하고 서버도 해야 되는 것**이다.

그래서 **이 기억이라는 것을 클라이언트 쪽에서도 구현하게 되고 서버쪽에서 구현하게 된 것**이다.

**이 기억이라는 것은 똑같은 내용을 양쪽이 같이 해야 되는 것**이다.

**이때 서버측은 기억해야 될 사람이 많을 것이다. 반대로 손님은 자기 혼자만 기억하면 되는 것**이고,

그래서 **클라이언트 측에서는 이 기억을 쿠키의 형태로 구현되게 되었다. 서버는 기억해야 될 것이 너무나 많기 때문에 데이터베이스의 형태로 만들게 되었다**.

```
상태 관리 솔루션:

HTTP의 무상태 문제:
┌─────────────────────────────────────────────────┐
│ 요청 1: 로그인 성공                             │
│ 요청 2: 장바구니 추가 ← 누가 로그인했는지 모름   │
│ 요청 3: 결제 시도 ← 장바구니가 누구 것인지 모름  │
└─────────────────────────────────────────────────┘

해결책 1: 쿠키 (클라이언트 측 저장)
┌─────────────────────────────────────────────────┐
│ 서버 → 클라이언트: Set-Cookie: sessionId=abc123  │
│ 클라이언트 → 서버: Cookie: sessionId=abc123      │
│                                                 │
│ 특징:                                           │
│ • 클라이언트 브라우저에 저장                     │
│ • 자동으로 요청에 포함됨                        │
│ • 용량 제한 (4KB)                              │
│ • 보안 위험 (XSS, CSRF)                        │
└─────────────────────────────────────────────────┘

해결책 2: 세션 (서버 측 저장)
┌─────────────────────────────────────────────────┐
│ 서버 메모리/DB:                                 │
│ sessionId=abc123 → {userId: 100, cart: [...]}   │
│                                                 │
│ 특징:                                           │
│ • 서버에 실제 데이터 저장                        │
│ • 클라이언트에는 세션ID만 저
│ • 서버에 실제 데이터 저장                        │
│ • 클라이언트에는 세션ID만 저장                   │
│ • 보안성 높음                                   │
│ • 서버 확장성 문제 (세션 공유 필요)              │
└─────────────────────────────────────────────────┘

현대적 해결책: JWT 토큰
┌─────────────────────────────────────────────────┐
│ • 상태 정보를 토큰에 포함                        │
│ • 서버에서 상태 저장 불필요                      │
│ • 확장성 우수                                   │
│ • 토큰 크기 증가 문제                           │
└─────────────────────────────────────────────────┘
```

## 3계층 웹 아키텍처의 등장

**그래서 다시 로그인으로 돌아와서 클라이언트가 POST로 아이디와 패스워드 데이터를 보내는데 이 서버 입장에서 해당 데이터들은 원격지에 있는 사용자 입력 데이터**이다. 따라서 **서버 입장에서는 원격지 사용자 입력 데이터를 신뢰해서는 안 된다. 해당 데이터는 반드시 검증해야 되는 검증 대상**이다. 그래서 **해당 데이터들이 맞는지 검증하기 위해서 데이터베이스에 저장되어 있는 데이터와 비교해본다**. **사용자 입력 데이터가 id가 test1234에 비밀번호 1234인 데이터가 데이터베이스에 있는지 조회해 보면 된다**.

```
Web Server ←─→ 중간 처리 서버 ←─→ 데이터베이스
```

그러면 **웹서버가 데이터베이스에게 조회를 할 때 직접 연결해서 조회를 하는 것은 아니고 중간에 특정 서버를 하나 두고 그 서버를 통해서 웹서버와 데이터베이스가 서로 연동하게 되는 것**이다.

그래서 이 **웹서버는 기본적인 역할은 송수신 역할**이다. **데이터베이스의 역할은 자료 담당**이다. 그러면 **중간에 있는 서버는 무엇인가 하면 처리를 담당**한다.

그래서 **웹서버가 아까 사용자 입력 데이터를 꺼내서 처리 담당자에게 보내주면 그 처리 담당자가 이를 검증하고 새로운 문서를 만들어서 반환해준다**. 즉, **아까 로그인한 후에 "로그인ID님 안녕하세요"와 같이 사용자에 따라 내용이 변하는 동적인 문서를 생성하여 반환**한다.

그래서 **이 중간처리 서버와 데이터베이스는 여러 인터페이스로 연결이 된다(JDBC, ODBC). 연결된 상태에서 SQL문을 실행시켜서 데이터를 조회하는데** 위와 같이 **조회가 성공해서 동적 문서를 성공적(FOUND)으로 만들었는데 만약 데이터를 찾지 못한다면 "너 누구야?"라는 문서를 보낸다 (NOT FOUND)**.

그래서 **이 중간에서 처리를 담당하는 이 서버를 WAS(Web Application Server)라고 한다. 그래서 이 WAS에서 컨트롤이라는 제어 체계가 포함**된다.

```
3계층 웹 아키텍처:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Web Server     │    │      WAS        │    │   Database      │
│ (Presentation)  │    │  (Application)  │    │     (Data)      │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • HTTP 처리     │    │ • 비즈니스 로직 │    │ • 데이터 저장   │
│ • 정적 파일     │    │ • 동적 콘텐츠   │    │ • 트랜잭션 처리 │
│ • 로드 밸런싱   │◄──►│ • 세션 관리     │◄──►│ • 데이터 무결성 │
│ • SSL 종료      │    │ • 인증/인가     │    │ • 백업/복구     │
│ • 캐싱          │    │ • API 처리      │    │ • 성능 최적화   │
└─────────────────┘    └─────────────────┘    └─────────────────┘

각 계층의 역할:

1계층 - Web Server (송수신 담당):
┌─────────────────────────────────────────────────┐
│ • 클라이언트 요청 수신                           │
│ • 정적 리소스 제공 (HTML, CSS, JS, 이미지)       │
│ • 요청 라우팅 및 로드 밸런싱                     │
│ • SSL/TLS 처리                                  │
│ • 압축, 캐싱                                    │
│                                                 │
│ 대표 제품: Apache, Nginx, IIS                   │
└─────────────────────────────────────────────────┘

2계층 - WAS (처리 담당):
┌─────────────────────────────────────────────────┐
│ • 동적 콘텐츠 생성                              │
│ • 비즈니스 로직 실행                            │
│ • 데이터베이스 연동                             │
│ • 세션 관리                                     │
│ • 트랜잭션 처리                                 │
│ • 보안 검증                                     │
│                                                 │
│ 대표 제품: Tomcat, WebLogic, WebSphere          │
└─────────────────────────────────────────────────┘

3계층 - Database (자료 담당):
┌─────────────────────────────────────────────────┐
│ • 데이터 영구 저장                              │
│ • CRUD 연산 처리                                │
│ • 데이터 무결성 보장                            │
│ • 트랜잭션 관리                                 │
│ • 동시성 제어                                   │
│ • 백업 및 복구                                  │
│                                                 │
│ 대표 제품: MySQL, PostgreSQL, Oracle, MSSQL     │
└─────────────────────────────────────────────────┘
```

## 실제 로그인 처리 과정

```
로그인 처리 시나리오:

1. 사용자 입력:
┌─────────────────────────────────────────────────┐
│ 브라우저에서 아이디/비밀번호 입력                │
│ POST /login                                     │
│ Content-Type: application/x-www-form-urlencoded │
│ userid=test1234&password=1234                   │
└─────────────────────────────────────────────────┘

2. Web Server 처리:
┌─────────────────────────────────────────────────┐
│ • HTTP 요청 수신                                │
│ • 정적 파일 여부 확인                           │
│ • 동적 요청이므로 WAS로 전달                     │
└─────────────────────────────────────────────────┘

3. WAS 처리:
┌─────────────────────────────────────────────────┐
│ • 요청 파라미터 추출 및 검증                     │
│ • 입력값 보안 검사 (SQL Injection, XSS 방지)    │
│ • 비즈니스 로직 실행 (로그인 검증)               │
│ • 데이터베이스 조회 요청                        │
└─────────────────────────────────────────────────┘

4. Database 처리:
┌─────────────────────────────────────────────────┐
│ SQL: SELECT * FROM users                        │
│      WHERE userid='test1234'                    │
│        AND password=SHA256('1234')              │
│                                                 │
│ 결과:                                           │
│ • 성공: 사용자 정보 반환                        │
│ • 실패: 빈 결과 반환                            │
└─────────────────────────────────────────────────┘

5. 응답 생성:
┌─────────────────────────────────────────────────┐
│ 성공 시:                                        │
│ • 세션 생성 (서버 메모리/DB 저장)                │
│ • 쿠키 설정 (세션ID 클라이언트 전송)             │
│ • 개인화 페이지 HTML 생성                       │
│ • "test1234님 안녕하세요!" 메시지 포함           │
│                                                 │
│ 실패 시:                                        │
│ • 에러 메시지 HTML 생성                         │
│ • "아이디 또는 비밀번호가 잘못되었습니다"        │
└─────────────────────────────────────────────────┘
```

## 현대 웹 아키텍처의 진화

```
현대 웹 아키텍처 (마이크로서비스):

전통적 3계층:
┌─────────────────────────────────────────────────┐
│ Web Server → WAS → Database                     │
│ (단일 애플리케이션)                             │
└─────────────────────────────────────────────────┘

현대적 구조:
┌─────────────────────────────────────────────────┐
│                Load Balancer                    │
│                      │                         │
│    ┌─────────────────┼─────────────────┐       │
│    │                 │                 │       │
│ Web Server      API Gateway      CDN           │
│    │                 │                 │       │
│    │         ┌───────┼───────┐         │       │
│    │         │       │       │         │       │
│    │    Auth Service │  User Service   │       │
│    │         │       │       │         │       │
│    │    Order Service│ Payment Service │       │
│    │         │       │       │         │       │
│    │    ┌────┴───┬───┴───┬───┴────┐    │       │
│    │    │        │       │        │    │       │
│    │   DB1      DB2     DB3      Cache │       │
└─────────────────────────────────────────────────┘

장점:
- 독립적 배포 및 확장
- 기술 스택 다양화
- 장애 격리
- 팀별 독립 개발
```

## 보안 고려사항

```
웹 애플리케이션 보안:

입력 데이터 검증:
┌─────────────────────────────────────────────────┐
│ 클라이언트 입력은 절대 신뢰하지 않음             │
│                                                 │
│ 검증 항목:                                      │
│ • 데이터 타입 검증                              │
│ • 길이 제한 검증                                │
│ • 형식 검증 (이메일, 전화번호 등)               │
│ • SQL Injection 방지                           │
│ • XSS (Cross-Site Scripting) 방지              │
│ • CSRF (Cross-Site Request Forgery) 방지       │
└─────────────────────────────────────────────────┘

인증 및 인가:
┌─────────────────────────────────────────────────┐
│ 인증 (Authentication): "당신은 누구인가?"        │
│ • 아이디/비밀번호                               │
│ • 2FA (Two-Factor Authentication)              │
│ • OAuth, SAML                                  │
│                                                 │
│ 인가 (Authorization): "무엇을 할 수 있는가?"     │
│ • 역할 기반 접근 제어 (RBAC)                    │
│ • 속성 기반 접근 제어 (ABAC)                    │
│ • JWT 토큰 기반 권한 관리                       │
└─────────────────────────────────────────────────┘

데이터 보호:
┌─────────────────────────────────────────────────┐
│ 전송 중 보호: HTTPS/TLS                         │
│ 저장 중 보호: 암호화, 해싱                      │
│ 개인정보 보호: GDPR, 개인정보보호법 준수         │
└─────────────────────────────────────────────────┘
```

이러한 **웹 서비스 구조의 발전 과정**을 이해하면 **현대 웹 애플리케이션의 복잡성과 각 구성 요소의 역할**을 명확히 파악할 수 있고, **확장 가능하고 보안성 높은 시스템 설계**의 기초를 다질 수 있습니다.


## 3-Tier 아키텍처

그래서 **웹서버와 WAS와 데이터베이스를 하나의 구성으로써 각각 1개의 티어로 총 3개의 티어로 이루어져 있게 된다**.

```
Web Server ─────── WAS ─────── DB
  1-Tier         1-Tier      1-Tier  → 3-Tier로 구성
                  <   APM    >
```

**보통은 웹 서비스 시스템이 잘 동작하는지 모니터링하게 마련**인데,

**Web Server의 네트워크가 아무리 빨라도 WAS에서의 처리 속도가 느려지거나, DB의 응답속도가 느려지면 전체적으로는 느려질 수밖에 없다**. 그래서 이 **WAS가 DB에게 질의하고 응답받은 것을 다시 응답하는 이 전체적인 응답시간이 서비스 품질에 있어서 매우 중요**하다.

```
3-Tier 성능 병목 지점:

┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Web Server  │    │    WAS      │    │  Database   │
│ (빠름)      │ →  │ (보통/느림)  │ →  │ (느림)      │
└─────────────┘    └─────────────┘    └─────────────┘
      ↓                   ↓                   ↓
 네트워크 처리         비즈니스 로직       데이터 조회
 정적 파일 제공       세션 관리          복잡한 쿼리
 SSL 종료            API 처리           인덱싱 부족

전체 응답시간 = Web Server 시간 + WAS 시간 + DB 시간
→ 가장 느린 구간이 전체 성능을 결정
```

## APM (Application Performance Management)

그래서 **위의 과정을 집중적으로 모니터링하는 시스템이 존재하는데 WAS 상태와 DB 응답시간을 모니터링해서 Web Application이 잘 동작하는지 모니터링하는 시스템을 APM(Application Performance Management) 시스템**이라고 한다. **대표적으로는 스카우터, 데이터독 등**이 있다.

그래서 **기본적으로 APM이 응답시간에 대한 모니터링을 하고 응답시간이 지연되는지 확인**한다.

```
APM 모니터링 요소:

성능 지표:
┌─────────────────────────────────────────────────┐
│ • 응답시간 (Response Time)                      │
│ • 처리량 (Throughput - TPS, RPS)               │
│ • 동시 사용자 수 (Concurrent Users)             │
│ • 에러율 (Error Rate)                          │
│ • 가용성 (Availability)                        │
└─────────────────────────────────────────────────┘

시스템 리소스:
┌─────────────────────────────────────────────────┐
│ • CPU 사용률                                    │
│ • 메모리 사용률                                 │
│ • 디스크 I/O                                   │
│ • 네트워크 I/O                                 │
│ • JVM 힙 메모리                                │
│ • GC (Garbage Collection) 성능                 │
└─────────────────────────────────────────────────┘

애플리케이션 레벨:
┌─────────────────────────────────────────────────┐
│ • SQL 실행 시간                                 │
│ • 외부 API 호출 시간                            │
│ • 트랜잭션 추적                                 │
│ • 메서드별 실행 시간                            │
│ • 예외 발생 빈도                                │
└─────────────────────────────────────────────────┘

대표적인 APM 도구:
- 스카우터 (Scouter): 오픈소스 APM
- 데이터독 (DataDog): 클라우드 기반 모니터링
- 뉴렐릭 (New Relic): SaaS 기반 APM
- 디얕트레이스 (Dynatrace): AI 기반 모니터링
```

## JVM과 미들웨어 구조

```
              │ JSP, PHP, ASP ....         │
                ────────────────────────────
                  │ 서블릿 형태로 변환 
                  │ 
                 │ Framework      │ Spring
                 ─────────────────── 
                  │
  Middleware    │ S/W , S/W  , S/W  │
                 ─────────────────────
      기본기능 │ TCP/IP , DB ,File.. │
                ─────────────────────
                │ Java Byte Code   │
          S/W  ─────────────────────────
                  CPU JVM
User Mode       
─────────────────────────────
Kernel Mode

S/W     Logical = Virtual
─────────────────────────────
H/W        CPU (Machine)
```

**보통 대한민국에서는 웹을 Java로 많이 개발하게 되는데** **CPU의 다른 말은 머신이고 S/W는 논리적이고 H/W는 물리적**이다. **논리적의 다른 말은 Virtual**이다. 그래서 **CPU를 애플리케이션으로 구현했는데 이 CPU는 Java를 위한 소프트웨어 CPU**이다. 그래서 **JVM(Java Virtual Machine), Java를 위한 논리적인 CPU**인 것이다.

그래서 **이 CPU가 인식할 수 있는 명령체계가 있는데 그것이 Bytecode**이다. 그래서 **Java Bytecode로 동작**한다. 이 **Java Bytecode 기반으로 애플리케이션을 동작시켜주는 흔히 미들웨어가 있는데 이 미들웨어는 다른 소프트웨어들이 잘 동작하게 도와주는 소프트웨어**이다.

```
JVM 아키텍처:

┌─────────────────────────────────────────────────┐
│                  JVM 구조                       │
├─────────────────────────────────────────────────┤
│ Method Area          │ Heap Memory              │
│ • 클래스 정보         │ • 객체 인스턴스 저장      │
│ • 상수 풀            │ • Young Generation       │
│ • 메서드 정보        │ • Old Generation         │
├─────────────────────┼─────────────────────────┤
│ JVM Stack           │ PC Register              │
│ • 메서드 호출 스택   │ • 현재 실행 명령 주소     │
│ • 지역 변수         │                          │
├─────────────────────┼─────────────────────────┤
│ Native Method Stack │ Direct Memory            │
│ • JNI 호출 스택     │ • Off-heap 영역          │
└─────────────────────┴─────────────────────────┘

Java 코드 실행 과정:
┌─────────────────────────────────────────────────┐
│ 1. Java 소스코드 (.java)                        │
│ 2. 컴파일러 (javac) → Bytecode (.class)         │
│ 3. JVM 로딩 → 클래스 로더가 메모리에 로드        │
│ 4. 바이트코드 검증 → 보안 및 유효성 검사         │
│ 5. 인터프리터/JIT 컴파일러 → 기계어로 변환       │
│ 6. 실행                                         │
└─────────────────────────────────────────────────┘
```

## 미들웨어와 서블릿 컨테이너

이 **소프트웨어들이 잘 동작하기 위해 필요한 필수적인 것들이 존재하는데 예를 들면 TCP/IP 통신, DB 통신, 파일 입출력 등 모든 소프트웨어들이 기본적으로 필요로 하는 기능들**이다. 그래서 **이러한 기능들을 미들웨어에서 미리 만들어서 가지고 있는 것**이다.

그래서 **흔히 C언어는 main함수 안에 다른 함수들을 작성하여 코딩하는데 JSP를 활용하게 되면 미들웨어에서 이미 만들어진 기능을 사용해서 가져다 사용하고 필요한 함수만 작성하게 되면 이것이 번역되어서 미들웨어의 소프트웨어로 감싸지고 밑에 TCP/IP 같은 통신을 할 수 있다**. 그래서 **이 미들웨어에서 S/W를 서블릿이라 하고 미들웨어 전체를 서블릿 컨테이너**라고 한다.

그리고 **이 미들웨어를 WAS**라고 하는 것이다. **대표적으로는 톰캣**이 있다.

```
서블릿 컨테이너 구조:

┌─────────────────────────────────────────────────┐
│              서블릿 컨테이너 (Tomcat)             │
├─────────────────────────────────────────────────┤
│ 개발자 작성 코드:                               │
│ ┌─────────────┬─────────────┬─────────────┐     │
│ │   JSP       │  Servlet    │   Filter    │     │
│ │ (View)      │ (Controller)│ (처리기)    │     │
│ └─────────────┴─────────────┴─────────────┘     │
├─────────────────────────────────────────────────┤
│ 컨테이너 제공 기능:                             │
│ • HTTP 요청/응답 처리                           │
│ • 서블릿 생명주기 관리                          │
│ • 스레드 풀 관리                               │
│ • 세션 관리                                    │
│ • 보안 처리                                    │
├─────────────────────────────────────────────────┤
│ 기본 시스템 기능:                               │
│ • TCP/IP 통신                                  │
│ • 파일 I/O                                     │
│ • 데이터베이스 연결                             │
│ • 멀티스레딩                                   │
└─────────────────────────────────────────────────┘

서블릿 생명주기:
┌─────────────────────────────────────────────────┐
│ 1. 로딩: 클래스 로더가 서블릿 클래스 로드        │
│ 2. 인스턴스화: 서블릿 객체 생성                  │
│ 3. 초기화: init() 메서드 호출                   │
│ 4. 요청 처리: service() → doGet(), doPost()     │
│ 5. 소멸: destroy() 메서드 호출                  │
└─────────────────────────────────────────────────┘
```

## Spring Framework

**여기에 이제 여기서 이 미들웨어를 좀 더 편하게 사용할 수 있게 도와주는 프레임워크가 등장**한다. **이 Spring도 결국 컨테이너 기술인데 객체를 생성하고 의존성을 가지고 객체를 생성하고 소멸을 Spring에서 자동으로 관리**해준다.

**예를 들면 어떤 함수가 호출되었다는 것은 그걸 호출시키는 요청이 있을 텐데 그 요청이 없으면 사실상 동작할 필요가 없다. 이때 자동으로 메모리에서 없애주고 여러 가지 등의 일련의 관리**를 해준다.

```
Spring Framework 핵심 기능:

IoC (Inversion of Control) 컨테이너:
┌─────────────────────────────────────────────────┐
│ • 객체 생성 및 생명주기 관리                     │
│ • 의존성 주입 (Dependency Injection)           │
│ • 설정 기반 객체 관리 (XML, Annotation)         │
└─────────────────────────────────────────────────┘

AOP (Aspect-Oriented Programming):
┌─────────────────────────────────────────────────┐
│ • 횡단 관심사 분리 (로깅, 보안, 트랜잭션)        │
│ • 코드 중복 제거                                │
│ • 비즈니스 로직과 부가 기능 분리                 │
└─────────────────────────────────────────────────┘

Spring Boot:
┌─────────────────────────────────────────────────┐
│ • 자동 설정 (Auto Configuration)               │
│ • 내장 서버 (Tomcat, Jetty, Undertow)          │
│ • 의존성 관리 간소화                            │
│ • 모니터링 및 헬스체크 기본 제공                 │
└─────────────────────────────────────────────────┘
```

그래서 **APM에서 어떤 장애가 발생했을 때 DB의 응답시간을 관측하지만 한편으로는 이 JVM을 모니터링한다. 이 JVM에서 어떤 이상이 없는지를 확인**한다.

**사용자 클라이언트의 요청에 따라 어떤 코드 뭉치들이 생성되고 실행됐다 사라지고를 반복**할 것이다.

이 **코드 뭉치를 함수라 표현했다. 즉, 어떤 기능적인 요소이다. 이 기능적 요소가 실행되는 트리거가 되어주는 것은 리퀘스트**다.

## UI와 데이터 분리 패턴

**위에 말을 잘 생각해보고 맨 처음 로그인한 다음에 서버에서 HTML을 만들어서 화면에 뿌려줬을 때** 예를 들어 **로그인 후에 "test님 안녕하세요."라는 이 페이지를 클라이언트가 받아서 보여주었다**. 근데 **여기서 이 클라이언트의 다양화 즉, 어떤 사람은 아이폰으로, 누구는 갤럭시 폴드, 태블릿, PC 등 사용자 환경이 너무나 다양해지기 시작**했다.

그래서 **이 사용자 환경마다 화면을 전부 만들어야 되는 문제가 발생하고 이에 대해 많은 고민**을 하게 된다.

이 **HTML이라는 문서가 일정 수준 UI적 요소를 가지고 있다**.

그래서 **이 웹 서버에 요청을 보내고 응답을 받을 때 UI와 데이터를 분리하자는 시도**가 발생한다.

```
`PC Client                       Web Server                            WAS
    │            Request                       Read, Write, Update, Delete
           ─────────────→                 ─────────────────────→
           
               UI와 데이터를 분리 
   JS/SW           [ XML, JSON ] 자료
           ←─────────────────`

`클라이언트 다양화 문제:

기존 방식 (서버 사이드 렌더링):
┌─────────────────────────────────────────────────┐
│ 각 디바이스별 HTML 생성 필요:                    │
│ • Desktop HTML                                  │
│ • Mobile HTML                                   │
│ • Tablet HTML                                   │
│ • Smart TV HTML                                 │
│                                                 │
│ 문제점:                                         │
│ • 중복된 개발 작업                              │
│ • 유지보수 복잡성 증가                          │
│ • 일관성 유지 어려움                            │
└─────────────────────────────────────────────────┘

해결책 (클라이언트 사이드 렌더링):
┌─────────────────────────────────────────────────┐
│ 서버: 순수 데이터만 제공 (JSON/XML)             │
│ 클라이언트: 디바이스에 맞게 UI 생성              │
│                                                 │
│ 장점:                                           │
│ • 하나의 API로 모든 디바이스 지원               │
│ • 프론트엔드/백엔드 역할 분리                   │
│ • 개발 효율성 향상                              │
│ • 사용자 경험 개선 (빠른 반응)                   │
└─────────────────────────────────────────────────┘`
```

그래서 **기존과 동일하게 GET 요청을 보내는데 이때 순수하게 자료만을 응답받게 변경된 것**이다.

이 **자료도 결국 문서의 형태로 응답하게 되는데 대표적으로 XML과 JSON 파일로 응답**을 하게 된다.

그래서 **클라이언트 사이드에서 어떤 JavaScript 소프트웨어가 서버에서 전달해준 데이터를 받아다가 그 자리에서 HTML을 생성**한다. 그래서 이 **JS 소프트웨어가 사용자 디바이스가 어떤 것인가에 따라서 그때그때마다 바꿔서 생성**한다.

**이러한 JavaScript 프레임워크 중에 대표적으로 React.js나 Vue.js**가 있다.

```
현대 웹 개발 패턴:

데이터 포맷 비교:
┌─────────────────────────────────────────────────┐
│ XML:                                            │
│ <user>                                          │
│   <id>123</id>                                  │
│   <name>홍길동</name>                           │
│   <email>hong@example.com</email>               │
│ </user>                                         │
│                                                 │
│ JSON:                                           │
│ {                                               │
│   "id": 123,                                    │
│   "name": "홍길동",                             │
│   "email": "hong@example.com"                   │
│ }                                               │
│                                                 │
│ → JSON이 더 가볍고 JavaScript와 호환성 좋음      │
└─────────────────────────────────────────────────┘

프론트엔드 프레임워크:
┌─────────────────────────────────────────────────┐
│ React.js:                                       │
│ • Facebook 개발                                 │
│ • 컴포넌트 기반                                 │
│ • Virtual DOM                                   │
│ • 단방향 데이터 흐름                            │
│                                                 │
│ Vue.js:                                         │
│ • 에반 유(Evan You) 개발                        │
│ • 점진적 적용 가능                              │
│ • 템플릿 기반                                   │
│ • 양방향 데이터 바인딩                          │
│                                                 │
│ Angular:                                        │
│ • Google 개발                                   │
│ • TypeScript 기본                               │
│ • 완전한 프레임워크                             │
└─────────────────────────────────────────────────┘
```

## RESTful API의 등장

그래서 **이 HTML을 직접 전송하는 시대에서 자료를 받아서 그 자리에서 생성하는 구조로 변경하게 된 것**이다.

**여기서 이 요청은 결국 서버측에게 어떤 데이터를 읽거나, 쓰거나, 업데이트를 해달라는 내용**이다.

**C: Create, R: Read, U: Update, D: Delete, CRUD는 어떤 처리에 대한 리퀘스트가 되는 거**다.

근데 **이 요청들에 대해서 함수로 구현을 하게 되고 이 함수들을 사용자가 호출하게 되는 것**이다.

그래서 **함수라는 걸 사용자가 호출하는 것이 리퀘스트의 다른 형태가 되었다. 그래서 이 함수 기능을 URI로 만들어서 기술하게 되었다. 이 함수를 다른 말로 API라 부른다. 이제 웹에서 이런 걸 구현한 함수를 RESTful API**라고 부른다.

```
RESTful API 설계:

HTTP 메서드와 CRUD 매핑:
┌─────────────────────────────────────────────────┐
│ GET /users          → Read (사용자 목록 조회)    │
│ GET /users/123      → Read (특정 사용자 조회)    │
│ POST /users         → Create (새 사용자 생성)    │
│ PUT /users/123      → Update (사용자 정보 수정)  │
│ DELETE /users/123   → Delete (사용자 삭제)      │
└─────────────────────────────────────────────────┘

REST 원칙:
┌─────────────────────────────────────────────────┐
│ 1. 자원(Resource) 식별: URI로 자원 표현          │
│ 2. 표현(Representation): JSON/XML로 데이터 표현 │
│ 3. 자기 서술적 메시지: HTTP 메서드로 의도 표현   │
│ 4. 무상태(Stateless): 각 요청 독립적           │
│ 5. 계층화(Layered): 여러 계층 구조 가능         │
└─────────────────────────────────────────────────┘

API 응답 예시:
┌─────────────────────────────────────────────────┐
│ GET /api/users/123                              │
│                                                 │
│ 응답:                                           │
│ {                                               │
│   "status": "success",                          │
│   "data": {                                     │
│     "id": 123,                                  │
│     "name": "홍길동",                           │
│     "email": "hong@example.com",                │
│     "created_at": "2024-01-01T00:00:00Z"        │
│   }                                             │
│ }                                               │
└─────────────────────────────────────────────────┘
```

## 웹 보안 아키텍처

그래서 **이 클라이언트가 서버에 요청을 할 때 직접 바로 요청하는 것이 아니라 여러 가지 서버를 거쳐서 오게 된다**.

```
PC Client ── 인터넷 ── IPS ── SSL처리 ── 웹애플리케이션 방화벽 ── Web Server
<                    HTTPS 통신                     >

PC Client ── 인터넷 ── IPS ── SSL처리 ── Web Server ── 웹애플리케이션 방화벽 ── WAS
```

**여기서 IPS는 1차 방어 체계, 웹애플리케이션 방화벽은 2차 방어 체계**이다. **가끔은 웹서버와 WAS 사이에 웹애플리케이션 방화벽이 위치**하곤 한다.

**여기서 SSL은 암호화 처리 담당인데 위처럼 중간에 SSL 처리를 해주는 장치가 중간에 있게 되면 HTTP가 아니라 HTTPS가 되는 것**이다. **그다음에 SSL 처리 후에 HTTP로 변경**된다.

```
웹 보안 계층:

1차 방어: IPS (Intrusion Prevention System)
┌─────────────────────────────────────────────────┐
│ • 네트워크 레벨 공격 차단                        │
│ • DDoS 공격 방어                                │
│ • 악성 IP 차단                                  │
│ • 패킷 필터링                                   │
│ • 포트 스캔 탐지                                │
└─────────────────────────────────────────────────┘

암호화 처리: SSL/TLS Termination
┌─────────────────────────────────────────────────┐
│ • HTTPS 트래픽 복호화                           │
│ • 인증서 관리                                   │
│ • 암호화 연산 오프로드                          │
│ • HTTP로 변환하여 내부 전달                     │
└─────────────────────────────────────────────────┘

2차 방어: WAF (Web Application Firewall)
┌─────────────────────────────────────────────────┐
│ • 애플리케이션 레벨 공격 차단                    │
│ • SQL Injection 방어                           │
│ • XSS (Cross-Site Scripting) 차단              │
│ • CSRF 공격 방어                               │
│ • 입력값 검증 및 필터링                         │
│ • API 호출 패턴 분석                           │
└─────────────────────────────────────────────────┘
```

그래서 **앞서 사용자 입력 데이터를 신뢰하면 안 되고 검증해야 된다 했는데 만약에 이 입력 데이터에 SQL문이 있게 되면 그것이 SQL 인젝션이 되는 것**이다.

```
주요 웹 보안 위협:

SQL Injection:
┌─────────────────────────────────────────────────┐
│ 악의적인 SQL 코드 삽입 공격                      │
│                                                 │
│ 예시:                                           │
│ 입력: ' OR '1'='1' --                           │
│ 쿼리: SELECT * FROM users                       │
│       WHERE username='' OR '1'='1' --'          │
│       AND password='...'                        │
│                                                 │
│ 결과: 모든 사용자 정보 노출                      │
│                                                 │
│ 방어: Prepared Statement, 입력값 검증           │
└─────────────────────────────────────────────────┘

XSS (Cross-Site Scripting):
┌─────────────────────────────────────────────────┐
│ 악성 스크립트 삽입 공격                          │
│                                                 │
│ 예시:                                           │
│ 입력: <script>alert('XSS')</script>             │
│                                                 │
│ 방어: 입력값 이스케이프, CSP 헤더               │
└─────────────────────────────────────────────────┘

CSRF (Cross-CSRF (Cross-Site Request Forgery):
┌─────────────────────────────────────────────────┐
│ 사용자 의도와 무관한 요청 전송 공격              │
│                                                 │
│ 예시:                                           │
│ 악성 사이트에서 은행 송금 요청 자동 전송         │
│ <img src="http://bank.com/transfer?             │
│           to=attacker&amount=1000000">          │
│                                                 │
│ 방어: CSRF 토큰, SameSite 쿠키                  │
└─────────────────────────────────────────────────┘

보안 모범 사례:
┌─────────────────────────────────────────────────┐
│ 입력 검증:                                      │
│ • 화이트리스트 기반 검증                        │
│ • 정규식을 통한 패턴 매칭                       │
│ • 길이 제한 및 타입 검증                        │
│                                                 │
│ 출력 인코딩:                                    │
│ • HTML 엔티티 인코딩                           │
│ • JavaScript 이스케이프                        │
│ • URL 인코딩                                   │
│                                                 │
│ 세션 보안:                                      │
│ • 세션 타임아웃 설정                            │
│ • 세션 고정 공격 방어                           │
│ • 안전한 세션 ID 생성                          │
└─────────────────────────────────────────────────┘
```

## 현대 웹 아키텍처의 완전한 그림

```
최종 현대 웹 아키텍처:

                    인터넷
                      │
            ┌─────────┼─────────┐
            │                   │
        모바일 앱           웹 브라우저
            │                   │
            └─────────┬─────────┘
                      │
                 Load Balancer
                      │
            ┌─────────┼─────────┐
            │                   │
          CDN                 WAF
            │                   │
            └─────────┬─────────┘
                      │
                  API Gateway
                      │
            ┌─────────┼─────────┐
            │         │         │
      Auth Service  User API  Order API
            │         │         │
            └─────────┼─────────┘
                      │
               Message Queue
                      │
            ┌─────────┼─────────┐
            │         │         │
       Database    Cache     File Storage
        (MySQL)   (Redis)    (S3/MinIO)

각 계층의 역할:

프론트엔드:
- React/Vue.js: 사용자 인터페이스
- Progressive Web App (PWA)
- 반응형 디자인 (Responsive Design)

API 계층:
- RESTful API 또는 GraphQL
- 마이크로서비스 아키텍처
- 서비스 메시 (Service Mesh)

데이터 계층:
- 관계형 DB (RDBMS)
- NoSQL (MongoDB, Cassandra)
- 캐시 (Redis, Memcached)
- 검색 엔진 (Elasticsearch)

인프라 계층:
- 컨테이너화 (Docker)
- 오케스트레이션 (Kubernetes)
- 클라우드 서비스 (AWS, Azure, GCP)
- CI/CD 파이프라인
```

## 성능 최적화 전략

```
웹 성능 최적화:

프론트엔드 최적화:
┌─────────────────────────────────────────────────┐
│ • 코드 분할 (Code Splitting)                    │
│ • 트리 셰이킹 (Tree Shaking)                    │
│ • 이미지 최적화 (WebP, 지연 로딩)               │
│ • 번들 크기 최소화                              │
│ • 브라우저 캐싱 활용                            │
└─────────────────────────────────────────────────┘

백엔드 최적화:
┌─────────────────────────────────────────────────┐
│ • 데이터베이스 인덱싱                           │
│ • 쿼리 최적화                                   │
│ • 커넥션 풀링                                   │
│ • 비동기 처리                                   │
│ • 캐싱 전략 (Redis, Memcached)                 │
└─────────────────────────────────────────────────┘

네트워크 최적화:
┌─────────────────────────────────────────────────┐
│ • CDN 활용                                      │
│ • HTTP/2, HTTP/3 사용                          │
│ • 압축 (Gzip, Brotli)                          │
│ • 정적 자원 최적화                              │
│ • API 응답 최적화                               │
└─────────────────────────────────────────────────┘
```

## 모니터링과 운영

```
DevOps와 SRE:

모니터링 도구:
┌─────────────────────────────────────────────────┐
│ • APM: New Relic, DataDog, Dynatrace           │
│ • 로그 수집: ELK Stack, Fluentd                │
│ • 메트릭: Prometheus + Grafana                 │
│ • 에러 추적: Sentry, Rollbar                   │
│ • 업타임 모니터링: Pingdom, StatusPage         │
└─────────────────────────────────────────────────┘

자동화:
┌─────────────────────────────────────────────────┐
│ • 배포 자동화: Jenkins, GitLab CI, GitHub Actions│
│ • 인프라 코드: Terraform, CloudFormation       │
│ • 컨테이너 관리: Docker, Kubernetes            │
│ • 설정 관리: Ansible, Chef, Puppet             │
└─────────────────────────────────────────────────┘

장애 대응:
┌─────────────────────────────────────────────────┐
│ • 알림 시스템: PagerDuty, OpsGenie              │
│ • 장애 추적: JIRA, ServiceNow                  │
│ • 포스트모템: 장애 원인 분석 및 개선책 수립      │
│ • 카나리 배포: 점진적 배포로 위험 최소화         │
└─────────────────────────────────────────────────┘
```

이러한 **현대 웹 서비스 구조와 기술 스택**을 이해하면 **확장 가능하고 안전하며 성능이 우수한 웹 애플리케이션**을 설계하고 구축할 수 있는 포괄적인 지식을 갖출 수 있습니다.