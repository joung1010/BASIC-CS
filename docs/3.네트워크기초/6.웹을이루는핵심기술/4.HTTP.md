# 간단하고 짧게 살펴보는 HTTP

**HTTP는 HTML 문서를 전송받기 위해 만들어진 응용 프로그램 계층(L7) 통신 프로토콜**이다. **1991년에 0.9 버전이 처음 등장했으며, 1996년에 1.0 스펙이 발표됐고 1997년 1월에 1.1이 발표**됐다.

**기본적으로 클라이언트 요청에 대응하는 응답 형식으로 작동**한다.

```
HTTP 버전 발전사:

HTTP/0.9 (1991):
┌─────────────────────────────────────────────────┐
│ • 단순한 GET 메서드만 지원                       │
│ • HTML 문서만 전송 가능                         │
│ • 헤더 없음, 상태 코드 없음                      │
└─────────────────────────────────────────────────┘

HTTP/1.0 (1996):
┌─────────────────────────────────────────────────┐
│ • 헤더 개념 도입                                │
│ • POST, HEAD 메서드 추가                        │
│ • 상태 코드 도입                                │
│ • 다양한 미디어 타입 지원                        │
└─────────────────────────────────────────────────┘

HTTP/1.1 (1997):
┌─────────────────────────────────────────────────┐
│ • 지속 연결 (Keep-Alive) 기본값                 │
│ • 파이프라이닝 지원                             │
│ • PUT, DELETE 등 메서드 추가                    │
│ • 청크 전송 인코딩                              │
└─────────────────────────────────────────────────┘

HTTP/2.0 (2015):
┌─────────────────────────────────────────────────┐
│ • 바이너리 프로토콜 (텍스트 → 바이너리)          │
│ • 멀티플렉싱 (하나의 연결로 여러 요청 동시 처리)  │
│ • 서버 푸시 (클라이언트 요청 없이 리소스 전송)    │
│ • 헤더 압축 (HPACK)                             │
└─────────────────────────────────────────────────┘

HTTP/3.0 (2022):
┌─────────────────────────────────────────────────┐
│ • UDP 기반 (QUIC 프로토콜 사용)                  │
│ • 연결 설정 시간 단축                           │
│ • 패킷 손실에 강한 구조                          │
└─────────────────────────────────────────────────┘
```

## HTTP와 스트림 데이터

우리가 일반적으로 **TCP/IP 계층이나 L2 계층에서의 단위 데이터들을 프레임이나 패킷**을 생각해보면, 예를 들어 **IP 네트워크인 경우 MTU가 1500바이트**이다. 그래서 이 **데이터들을 끊어서 생각하기가 좋았는데 L5 이상에서는 소켓 통신을 하는 것이고 소켓 통신은 스트림 데이터**이다. **시작은 확실한데 이 끝이 언제 끝날지에 대해서 생각해 봐야 하는데 이에 대한 규정이 HTTP 헤더에 정의**되어 있다.

**HTTP의 헤더는 그 이전 단위 데이터들이 16진수로 값이 표현되었는데 문자열로 표현**된다.

```
계층별 데이터 처리 방식:

L2 (데이터 링크):
┌─────────────────────────────────────────────────┐
│ Frame: 고정된 헤더 + 데이터 + 트레일러           │
│ 크기: 명확한 길이 필드로 경계 구분               │
└─────────────────────────────────────────────────┘

L3 (네트워크):
┌─────────────────────────────────────────────────┐
│ Packet: IP 헤더의 Total Length 필드             │
│ MTU: 1500바이트 제한                            │
│ 크기: 헤더에 명시된 정확한 길이                  │
└─────────────────────────────────────────────────┘

L4 (전송):
┌─────────────────────────────────────────────────┐
│ TCP Segment: 순서번호 + 윈도우 크기              │
│ 스트림: 연속된 바이트 흐름                       │
│ 경계: 애플리케이션이 직접 처리                   │
└─────────────────────────────────────────────────┘

L7 (애플리케이션) - HTTP:
┌─────────────────────────────────────────────────┐
│ 메시지: 텍스트 기반 헤더 + 본문                  │
│ 경계 처리 방법:                                 │
│ • Content-Length: 본문 크기 명시                │
│ • Transfer-Encoding: chunked (청크 단위)        │
│ • Connection: close (연결 종료로 끝 표시)       │
└─────────────────────────────────────────────────┘
```

## HTTP 헤더 분류

헤더는 크게:

- **일반 헤더 (General Header)**
- **요청 헤더 (Request Header)**
- **응답 헤더 (Response Header)**

이렇게 분류된다. **핵심은 HTTP는 문서를 전송받기 위해 만들어졌기 때문에** 이 **요청 헤더에서 요청은 문서를 요청하는 것**이다. **응답은 당연히 그 요청한 문서를 응답해 주는 것**이다.

```
실제 HTTP 요청/응답 예시:

HTTP 요청:
┌─────────────────────────────────────────────────┐
│ GET /index.html HTTP/1.1                        │
│ Host: www.example.com                           │
│ User-Agent: Mozilla/5.0 Chrome/91.0            │
│ Accept: text/html,application/xhtml+xml         │
│ Accept-Language: ko-KR,ko;q=0.9,en;q=0.8       │
│ Accept-Encoding: gzip, deflate, br              │
│ Connection: keep-alive                          │
│ Cache-Control: max-age=0                        │
│                                                 │
│ (빈 줄로 헤더와 본문 구분)                       │
│ (GET 요청이므로 본문 없음)                       │
└─────────────────────────────────────────────────┘

HTTP 응답:
┌─────────────────────────────────────────────────┐
│ HTTP/1.1 200 OK                                 │
│ Date: Tue, 15 Nov 2024 10:00:00 GMT             │
│ Server: nginx/1.18.0                           │
│ Content-Type: text/html; charset=UTF-8          │
│ Content-Length: 1234                            │
│ Last-Modified: Mon, 14 Nov 2024 15:30:00 GMT   │
│ ETag: "abc123"                                  │
│ Cache-Control: public, max-age=3600             │
│ Connection: keep-alive                          │
│                                                 │
│ <!DOCTYPE html>                                 │
│ <html>                                          │
│ <head><title>Example</title></head>             │
│ <body>Hello World!</body>                       │
│ </html>                                         │
└─────────────────────────────────────────────────┘
```

## HTTP 메서드

그래서 이 **요청, 다른 말로는 메서드에 사용되는 것이 GET, POST, PUT, PATCH, DELETE, OPTIONS, CONNECT**가 있다.

### 주요 HTTP 메서드

- **GET**: 리소스 조회
- **POST**: 요청 데이터 처리, 주로 등록에 사용
- **PUT**: 리소스를 대체, 해당 리소스가 없으면 생성
- **PATCH**: 리소스 부분 변경
- **DELETE**: 리소스 삭제

### 기타 HTTP 메서드

- **HEAD**: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- **OPTIONS**: 대상 리소스에 대한 통신 기능 옵션(메서드)을 설명(주로 CORS에서 사용)
- **CONNECT**: 대상 자원으로 식별되는 서버에 대한 터널을 설정
- **TRACE**: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

```
HTTP 메서드 상세:

GET: 리소스 조회
┌─────────────────────────────────────────────────┐
│ 용도: 서버에서 리소스 조회                       │
│ 특징: 안전(Safe), 멱등(Idempotent)              │
│ 본문: 없음 (쿼리 스트링으로 데이터 전달)         │
│ 캐시: 가능                                      │
│                                                 │
│ 예시: GET /users/123?include=profile            │
└─────────────────────────────────────────────────┘

POST: 데이터 전송/처리
┌─────────────────────────────────────────────────┐
│ 용도: 서버에 데이터 전송하여 처리 요청           │
│ 특징: 안전하지 않음, 멱등하지 않음               │
│ 본문: 있음 (form-data, JSON 등)                 │
│ 캐시: 불가능                                    │
│                                                 │
│ 예시: POST /users (새 사용자 생성)               │
│       POST /login (로그인 처리)                 │
└─────────────────────────────────────────────────┘

PUT: 리소스 전체 교체
┌─────────────────────────────────────────────────┐
│ 용도: 리소스 전체를 새로 생성하거나 교체         │
│ 특징: 멱등성 있음                               │
│ 본문: 있음 (전체 리소스 데이터)                  │
│                                                 │
│ 예시: PUT /users/123 (123번 사용자 정보 전체 교체)│
└─────────────────────────────────────────────────┘

PATCH: 리소스 부분 수정
┌─────────────────────────────────────────────────┐
│ 용도: 리소스의 일부분만 수정                     │
│ 특징: 일반적으로 멱등성 있음                     │
│ 본문: 있음 (수정할 부분만)                       │
│                                                 │
│ 예시: PATCH /users/123 {"name": "새이름"}        │
└─────────────────────────────────────────────────┘

DELETE: 리소스 삭제
┌─────────────────────────────────────────────────┐
│ 용도: 리소스 삭제                               │
│ 특징: 멱등성 있음                               │
│ 본문: 일반적으로 없음                            │
│                                                 │
│ 예시: DELETE /users/123                         │
└─────────────────────────────────────────────────┘
```

## HTTP 메서드의 속성

- **안전(Safe Methods)**
- **멱등(Idempotent Methods)**
- **캐시가능(Cacheable Methods)**

### 안전(Safe Methods)

**호출해도 리소스를 변경하지 않는다.**

**Q**: 그래도 계속 호출해서, 로그 같은 게 쌓여서 장애가 발생하면?
**A**: 안전은 해당 리소스만 고려한다. 그런 부분까지 고려하지 않는다.

```
안전한 메서드와 안전하지 않은 메서드:

안전한 메서드 (Safe):
┌─────────────────────────────────────────────────┐
│ GET, HEAD, OPTIONS, TRACE                       │
│ • 서버 상태를 변경하지 않음                      │
│ • 조회 목적으로만 사용                          │
│ • 여러 번 호출해도 서버 리소스에 영향 없음        │
└─────────────────────────────────────────────────┘

안전하지 않은 메서드 (Unsafe):
┌─────────────────────────────────────────────────┐
│ POST, PUT, PATCH, DELETE                        │
│ • 서버 상태를 변경함                            │
│ • 생성, 수정, 삭제 등의 작업 수행                │
│ • 호출 시 서버 리소스에 부작용 발생              │
└─────────────────────────────────────────────────┘
```

### 멱등(Idempotent Methods)

**f(f(x)) = f(x)한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.**

**멱등 메서드**:

- **GET**: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
- **PUT**: 결과를 대체한다. 따라서 같은 요청을 여러 번 해도 최종 결과는 같다.
- **DELETE**: 결과를 삭제한다. 같은 요청을 여러 번 해도 삭제된 결과는 똑같다.
- **POST**: 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.

**활용**:

- **자동 복구 메커니즘**
- **서버가 Timeout 등으로 정상 응답을 못 줬을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거**

```
멱등성 예시:

GET /users/123 (멱등):
┌─────────────────────────────────────────────────┐
│ 1회 호출: {"id": 123, "name": "홍길동"}          │
│ 2회 호출: {"id": 123, "name": "홍길동"}          │
│ n회 호출: {"id": 123, "name": "홍길동"}          │
│ → 동일한 결과                                   │
└─────────────────────────────────────────────────┘

PUT /users/123 {"name": "김철수"} (멱등):
┌─────────────────────────────────────────────────┐
│ 1회 호출: 사용자 이름이 "김철수"로 변경          │
│ 2회 호출: 사용자 이름이 "김철수"로 유지          │
│ n회 호출: 사용자 이름이 "김철수"로 유지          │
│ → 최종 상태 동일                                │
└─────────────────────────────────────────────────┘

POST /orders {"item": "책", "price": 10000} (비멱등):
┌─────────────────────────────────────────────────┐
│ 1회 호출: 주문 #001 생성                        │
│ 2회 호출: 주문 #002 생성 (중복 주문!)            │
│ n회 호출: 주문 #00n 생성 (계속 중복!)            │
│ → 매번 다른 결과                                │
└─────────────────────────────────────────────────┘

실무 적용:
┌─────────────────────────────────────────────────┐
│ 네트워크 오류 발생 시:                           │
│ • GET, PUT, DELETE: 재시도 안전                 │
│ • POST: 중복 처리 방지 로직 필요                 │
│   (예: 주문번호 중복 체크, 토큰 방식)            │
└─────────────────────────────────────────────────┘
```

### 캐시가능(Cacheable Methods)

**응답 결과 리소스를 캐시해서 사용해도 되는가?**

- **GET, HEAD, POST, PATCH 캐시가능**
- **실제로는 GET, HEAD 정도만 캐시 사용**
    - **POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않다.**

```
캐시 가능성:

실용적 캐시 가능 (GET, HEAD):
┌─────────────────────────────────────────────────┐
│ GET /images/logo.png                            │
│ • URL만으로 캐시 키 생성 가능                    │
│ • 브라우저, CDN에서 널리 캐시됨                  │
│ • 캐시 헤더: Cache-Control, ETag, Last-Modified │
└─────────────────────────────────────────────────┘

이론적 캐시 가능하나 복잡 (POST, PATCH):
┌─────────────────────────────────────────────────┐
│ POST /api/search                                │
│ Body: {"query": "HTTP", "page": 1}              │
│ • URL + 본문 내용까지 캐시 키로 고려해야 함       │
│ • 구현 복잡도 높음                              │
│ • 실제로는 거의 캐시하지 않음                    │
└─────────────────────────────────────────────────┘
```

## HTTP 응답 코드

```
HTTP 상태 코드 체계:

1xx (정보성): 요청 처리 중
┌─────────────────────────────────────────────────┐
│ 100 Continue: 클라이언트가 요청을 계속 전송     │
│ 101 Switching Protocols: 프로토콜 변경         │
│ 102 Processing: 처리 중 (WebDAV)                │
└─────────────────────────────────────────────────┘

2xx (성공): 요청이 정상적으로 처리됨
┌─────────────────────────────────────────────────┐
│ 200 OK: 요청이 정상적으로 처리됨                │
│ 201 Created: 요청에 대한 새로운 자원 생성 성공  │
│ 202 Accepted: 요청 접수했으나 처리 완료 안됨     │
│ 204 No Content: 처리 성공, 반환할 내용 없음     │
│ 206 Partial Content: 부분 다운로드             │
└─────────────────────────────────────────────────┘

3xx (리다이렉션): 추가 작업 필요
┌─────────────────────────────────────────────────┐
│ 301 Moved Permanently: 영구적 이동             │
│ 302 Found: 임시 이동                           │
│ 304 Not Modified: 캐시된 버전 사용             │
│ 307 Temporary Redirect: 임시 리다이렉트        │
│ 308 Permanent Redirect: 영구 리다이렉트        │
└─────────────────────────────────────────────────┘

4xx (클라이언트 오류): 클라이언트 잘못
┌─────────────────────────────────────────────────┐
│ 400 Bad Request: HTTP 규약에 맞지 않는 요청     │
│ 401 Unauthorized: 인증 필요                    │
│ 403 Forbidden: 권한이 없거나 잘못된 접근 시도   │
│ 404 Not Found: 요청한 리소스를 찾을 수 없음     │
│ 405 Method Not Allowed: 허용되지 않는 메서드    │
│ 409 Conflict: 요청이 현재 서버 상태와 충돌      │
│ 429 Too Many Requests: 요청 횟수 제한 초과      │
└─────────────────────────────────────────────────┘

5xx (서버 오류): 서버 잘못
┌─────────────────────────────────────────────────┐
│ 500 Internal Server Error: 내부 오류로 처리 불가│
│ 502 Bad Gateway: 게이트웨이 오류                │
│ 503 Service Unavailable: 서비스 일시 불가       │
│ 504 Gateway Timeout: 게이트웨이 시간 초과       │
│ 505 HTTP Version Not Supported: 버전 미지원    │
└─────────────────────────────────────────────────┘
```

## HTTP 특징

- **클라이언트 서버 구조**
- **무상태 프로토콜(스테이트리스), 비연결성**
- **HTTP 메시지**
- **단순함, 확장 가능**

## Stateful vs Stateless 차이

### 상태유지 - Stateful 예제

```
고객: 이 노트북 얼마인가요?
점원: 100만원 입니다. (노트북 상태 유지)

고객: 2개 구매하겠습니다.
점원: 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?
(노트북, 2개 상태 유지)

고객: 신용카드로 구매하겠습니다.
점원: 200만원 결제 완료되었습니다. (노트북, 2개, 신용카드 상태 유지)
```

### 상태유지 - Stateful: 근데 만약 중간에 점원이 바뀐다면???

```
고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원B: ? 무엇을 2개 구매하시겠어요?

고객: 신용카드로 구매하겠습니다.
점원C: ? 무슨 제품을 몇 개 신용카드로 구매하시겠어요?
```

### 무상태 - Stateless

```
고객: 이 노트북 얼마인가요?
점원: 100만원 입니다.

고객: 노트북 2개 구매하겠습니다.
점원: 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?

고객: 노트북 2개를 신용카드로 구매하겠습니다.
점원: 200만원 결제 완료되었습니다.
```

### 무상태 - Stateless, 점원이 중간에 바뀐다면??

```
고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 노트북 2개 구매하겠습니다.
점원B: 200만원 입니다. 신용카드, 현금 중 어떤 걸로 구매하시겠어요?

고객: 노트북 2개를 신용카드로 구매하겠습니다.
점원C: 200만원 결제 완료되었습니다.
```

**상태 유지에서 만약 점원이 바뀐다면 이 서비스는 에러가 발생**하는 것이다.

**하지만 무상태에서는 클라이언트가 그때그때 필요한 정보를 모두 전달**한다.

**그래서 중간에 점원이 바뀌어도 아무 문제가 없다**.

```
Stateful vs Stateless 서버 관점:

Stateful (상태 유지):
┌─────────────────────────────────────────────────┐
│ 서버가 클라이언트 상태 정보를 보관               │
│                                                 │
│ 장점:                                           │
│ • 클라이언트 요청이 간단함                       │
│ • 서버에서 문맥 파악 용이                        │
│                                                 │
│ 단점:                                           │
│ • 서버 장애 시 상태 정보 손실                    │
│ • 확장성 제한 (특정 서버에 의존)                 │
│ • 메모리 사용량 증가                            │
└─────────────────────────────────────────────────┘

Stateless (무상태):
┌─────────────────────────────────────────────────┐
│ 서버가 클라이언트 상태 정보를 보관하지 않음       │
│                                                 │
│ 장점:                                           │
│ • 서버 확장성 우수 (Scale Out 용이)              │
│ • 서버 장애에 강함                              │
│ • 서버 자원 효율적 사용                          │
│                                                 │
│ 단점:                                           │
│ • 클라이언트가 많은 정보를 전송해야 함           │
│ • 데이터 전송량 증가                            │
└─────────────────────────────────────────────────┘
```

- **상태 유지**: 중간에 다른 점원으로 바뀌면 안 된다.
    - 중간에 다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.
- **무상태**: 중간에 다른 점원으로 바뀌어도 된다.
    - 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
    - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
- **무상태는 응답 서버를 쉽게 바꿀 수 있다.**

### Stateless의 한계

- **모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.**
- **무상태**
    - 예) 로그인이 필요 없는 단순한 서비스 소개 화면
- **상태 유지**
    - 예) 로그인
- **로그인한 사용자의 경우 로그인했다는 상태를 서버에 유지**
- **일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지**
- **상태 유지는 최소한만 사용**

```
상태 관리 전략:

기본 원칙: 무상태
┌─────────────────────────────────────────────────┐
│ • 대부분의 API는 무상태로 설계                   │
│ • RESTful API 설계 원칙                         │
│ • 마이크로서비스 아키텍처에 적합                 │
└─────────────────────────────────────────────────┘

필요시에만 상태 유지:
┌─────────────────────────────────────────────────┐
│ 사용자 인증/인가:                                │
│ • 세션 기반: 서버에 세션 정보 저장               │
│ • 토큰 기반: JWT 등으로 상태를 클라이언트에 위임  │
│                                                 │
│ 실시간 상호작용:                                 │
│ • WebSocket 연결 상태                           │
│ • 게임, 채팅 등의 실시간 통신                    │
│                                                 │
│ 트랜잭션 처리:                                   │
│ • 장바구니, 결제 프로세스                        │
│ • 다단계 프로세스의 중간 상태                    │
└─────────────────────────────────────────────────┘
```

## 비연결성

**HTTP는 기본이 연결을 유지하지 않는 모델**

- **일반적으로 초 단위 이하의 빠른 속도로 응답**
- **1시간 동안 수천 명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십 개 이하로 매우 적음**
    - 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지 않는다.
- **서버 자원을 매우 효율적으로 사용할 수 있음**

```
연결 유지 vs 비연결성 비교:

연결 유지 모델:
┌─────────────────────────────────────────────────┐
│ Client1 ────────────── Server (연결 유지)       │
│ Client2 ────────────── Server (연결 유지)       │
│ Client3 ────────────── Server (연결 유지)       │
│                                                 │
│ 문제점:                                         │
│ • 서버 자원 계속 점유 (메모리, 소켓)             │
│ • 동시 접속자 수 제한                           │
│ • 사용하지 않는 연결도 자원 소모                 │
└─────────────────────────────────────────────────┘

비연결성 모델 (HTTP):
┌─────────────────────────────────────────────────┐
│ Client1 ──요청→ Server ←응답── (연결 종료)       │
│ Client2 ──요청→ Server ←응답── (연결 종료)       │
│ Client3 ──요청→ Server ←응답── (연결 종료)       │
│                                                 │
│ 장점:                                           │
│ • 서버 자원 효율적 사용                          │
│ • 더 많은 클라이언트 동시 처리 가능              │
│ • 스케일링에 유리                               │
└─────────────────────────────────────────────────┘

실제 사용 패턴:
┌─────────────────────────────────────────────────┐
│ 사용자 행동 분석:                               │
│ • 웹페이지 요청 → 3초 내 응답 → 연결 종료        │
│ • 사용자가 페이지 읽는 시간: 수십 초~수 분       │
│ • 다음 요청까지 긴 간격 (사용자 생각하는 시간)   │
│                                                 │
│ → 연결 유지할 필요 없음                         │
└─────────────────────────────────────────────────┘
```

### 비연결성의 한계와 극복

**한계**:

- **TCP/IP 연결을 새로 맺어야 함 - 3-way handshake 시간 추가**
- **웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 JavaScript, CSS, 추가 이미지 등 수많은 자원이 함께 다운로드**

**극복**:

- **지금은 HTTP 지속 연결(Persistent Connection)로 문제 해결**
- **HTTP/2.0, HTTP/3.0에서 더 많은 최적화**

```
연결 방식의 진화:

HTTP/1.0 (초기 비연결성):
┌─────────────────────────────────────────────────┐
│ 요청마다 연결 생성/해제                          │
│                                                 │
│ HTML 요청: 연결 → 전송 → 해제                    │
│ CSS 요청:  연결 → 전송 → 해제                    │
│ JS 요청:   연결 → 전송 → 해제                    │
│ 이미지1:   연결 → 전송 → 해제                    │
│ 이미지2:   연결 → 전송 → 해제                    │
│                                                 │
│ 단점: 연결 오버헤드 과다                         │
└─────────────────────────────────────────────────┘

HTTP/1.1 (지속 연결):
┌─────────────────────────────────────────────────┐
│ Keep-Alive로 연결 재사용                        │
│                                                 │
│ 연결 → HTML → CSS → JS → 이미지1 → 이미지2 → 해제│
│                                                 │
│ 장점: 연결 설정 시간 단축                        │
│ 단점: Head-of-Line Blocking                     │
└─────────────────────────────────────────────────┘

HTTP/2.0 (멀티플렉싱):
┌─────────────────────────────────────────────────┐
│ 하나의 연결로 여러 요청 동시 처리                │
│                                                 │
│ 연결 → ┌HTML┐┌CSS┐┌JS┐┌IMG1┐┌IMG2┐ → 해제      │
│       └────┘└───┘└──┘└────┘└────┘             │
│                                                 │
│ 장점: 진정한 병렬 처리, 헤더 압축                │
└─────────────────────────────────────────────────┘

HTTP/3.0 (QUIC 기반):
┌─────────────────────────────────────────────────┐
│ UDP 기반으로 연결 설정 시간 단축                 │
│                                                 │
│ 0-RTT 연결 → 즉시 데이터 전송 가능               │
│                                                 │
│ 장점: 연결 지연 최소화, 패킷 손실 독립 처리      │
└─────────────────────────────────────────────────┘
```

## HTTP 메시지 종료 처리

```
스트림 데이터 종료 처리 방법:

1. Content-Length 사용:
┌─────────────────────────────────────────────────┐
│ Content-Length: 1234                            │
│                                                 │
│ → 정확히 1234바이트 읽은 후 메시지 끝           │
│ → 가장 일반적인 방법                            │
│                                                 │
│ 예시:                                           │
│ HTTP/1.1 200 OK                                 │
│ Content-Length: 13                              │
│                                                 │
│ Hello, World!                                   │
└─────────────────────────────────────────────────┘

2. Transfer-Encoding: chunked:
┌─────────────────────────────────────────────────┐
│ Transfer-Encoding: chunked                      │
│                                                 │
│ D                     ← 16진수로 청크 크기(13)  │
│ Hello, World!         ← 실제 데이터             │
│ 0                     ← 마지막 청크 (크기 0)    │
│                       ← 빈 줄로 끝              │
│                                                 │
│ 용도: 스트리밍, 실시간 데이터 전송               │
└─────────────────────────────────────────────────┘

3. Connection: close:
┌─────────────────────────────────────────────────┐
│ Connection: close                               │
│                                                 │
│ → TCP 연결 종료로 메시지 끝을 표시               │
│ → HTTP/1.0의 기본 동작                          │
│ → 현재는 비효율적이므로 잘 사용하지 않음         │
└─────────────────────────────────────────────────┘
```

## 실무에서의 HTTP 활용

```
현대 웹 개발에서 HTTP 활용:

RESTful API 설계:
┌─────────────────────────────────────────────────┐
│ GET    /users          → 사용자 목록 조회        │
│ GET    /users/123      → 특정 사용자 조회        │
│ POST   /users          → 새 사용자 생성          │
│ PUT    /users/123      → 사용자 정보 전체 수정   │
│ PATCH  /users/123      → 사용자 정보 부분 수정   │
│ DELETE /users/123      → 사용자 삭제             │
└─────────────────────────────────────────────────┘

상태 코드 활용:
┌─────────────────────────────────────────────────┐
│ 200: 정상 처리 (GET, PUT, PATCH)                │
│ 201: 생성 완료 (POST)                           │
│ 204: 처리 완료, 반환 데이터 없음 (DELETE)        │
│ 400: 잘못된 요청 (유효성 검사 실패)              │
│ 401: 인증 필요                                  │
│ 403: 권한 없음                                  │
│ 404: 리소스 없음                                │
│ 409: 데이터 충돌 (중복 생성 시도)                │
│ 500: 서버 내부 오류                             │
└─────────────────────────────────────────────────┘

캐싱 전략:
┌─────────────────────────────────────────────────┐
│ Cache-Control: public, max-age=3600             │
│ → 1시간 동안 캐시 유효                          │
│                                                 │
│ ETag: "abc123"                                  │
│ → 리소스 버전 관리                              │
│                                                 │
│ Last-Modified: Mon, 01 Jan 2024 00:00:00 GMT    │
│ → 마지막 수정 시간 기반 캐시                     │
└─────────────────────────────────────────────────┘
```

이러한 **HTTP의 기본 구조와 특성**을 이해하면 **현대 웹 애플리케이션 개발에서 효율적인 API 설계와 성능 최적화**를 할 수 있는 탄탄한 기초를 갖출 수 있습니다.