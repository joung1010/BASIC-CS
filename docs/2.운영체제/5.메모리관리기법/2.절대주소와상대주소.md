### 절대주소와 상대주소

**메모리의 최소 관리단위는 1byte이고 이 최소 공간마다 주소를 붙여서 관리하게 됩니다**. **이 메모리는 물리적인 저장공간 RAM의 H/W 수준의 주소 체계와 application 프로세스 수준의 주소 체계가 다릅니다**. **서로 다른 주소 체계를 사용하며, 최종적으로는 이 둘 모두 가상 메모리에서 관리되기 때문에 실제 서로의 주소는 다릅니다**.

### 메모리 주소의 두 가지 기준

**메모리의 주소에 대해 이야기할 때 2가지 기준이 있습니다**:

- **절대 주소 (Absolute Address)**
- **상대 주소 (Relative Address)**

```
📍 메모리 주소 체계

물리 메모리 구조:
┌─────────────────────────────────────────────────────┐
│  주소 0                                             │
│  ┌─────────────────────────────────────────────┐   │
│  │         운영체제 영역                       │   │
│  │         (시스템 예약)                       │   │
│  │                                             │   │
│  └─────────────────────────────────────────────┘   │
│  주소 360 ← 경계 레지스터 (Boundary Register)       │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │         사용자 영역                         │   │
│  │         (프로세스 할당 가능)                │   │
│  │                                             │   │
│  └─────────────────────────────────────────────┘   │
│  주소 999                                           │
└─────────────────────────────────────────────────────┘

특정 메모리 주소 400의 경우:
- 절대주소: 0번부터 실제 떨어진 거리 = 400
- 상대주소: 경계 레지스터(360)부터의 거리 = 40
```

**이때 특정 메모리 주소가 400일 때 0부터 시작하면 그 위치는 400이지만 운영체제가 사용하는 부분을 제외하고 경계 레지스터에서부터는 해당 거리가 40입니다**.

**그래서 절대 주소는 전체 주소를 0번부터 실제 떨어진 거리를 의미하고 상대 주소는 운영체제 영역을 제외한 부분부터 재설정해서 그 재설정된 위치에서부터 떨어진 거리를 의미합니다**.

### 경계 레지스터 (Boundary Register)

**경계 레지스터(boundary register)란 운영체제(OS)가 메모리 보호와 관리를 위해 사용하는 하드웨어 레지스터입니다**. **주요 역할은 프로세스가 할당받은 메모리 영역의 경계, 즉 끝 주소(혹은 접근 가능한 최대 주소)를 저장합니다**.

```
🔒 경계 레지스터의 기능

메모리 보호 체계:
┌─────────────────────────────────────────────────────┐
│  하드웨어 레벨에서 메모리 접근 제어:                │
│                                                     │
│  • 기준 레지스터: 프로세스 시작 주소 저장           │
│  • 경계 레지스터: 프로세스 끝 주소 저장             │
│  • 모든 메모리 접근 시 하드웨어가 자동 검사         │
│                                                     │
│  접근 위반 시:                                      │
│  → 하드웨어 인터럽트 발생                           │
│  → 운영체제가 프로세스 종료                         │
└─────────────────────────────────────────────────────┘
```

### 배열로 이해하는 주소 개념

**그래서 상대 주소는 논리 주소 공간입니다**. **그래서 이 절대 주소와 상대 주소를 이해할 때 배열을 생각하면 이해하기 쉽습니다. 배열의 이름은 주소이고 이 배열의 이름을 기준으로 데이터를 가져옵니다(인덱스)**.

```
🧩 배열로 이해하는 주소 체계

메모리 상황:
절대주소: 0  1  2  3  4  5  6  7  8  9  10 11 12 13
데이터 :              [  arr 배열  ]
                      ↑
                   arr 시작점 (절대주소 8)

배열 접근:
- arr[0] → 절대주소 8  = 상대주소 0
- arr[1] → 절대주소 9  = 상대주소 1  
- arr[3] → 절대주소 11 = 상대주소 3
```

```java
*// 배열로 이해하는 절대주소와 상대주소*
public class AddressExample {
    public static void main(String[] args) {
        int[] arr = new int[5];
        
        *// 배열 시작 주소가 절대주소 기준점// arr 이름 자체가 시작 주소를 가리킴*
        
        arr[0] = 100;  *// 상대주소 0 (배열 기준)*
        arr[3] = 400;  *// 상대주소 3 (배열 기준)*
        
        System.out.println("배열 참조 주소: " + arr);
        System.out.println("상대주소 0의 값: " + arr[0]);
        System.out.println("상대주소 3의 값: " + arr[3]);
        
        *// 배열명 = 절대주소 기준점// 인덱스 = 상대주소 (배열 시작점부터의 거리)*
    }
}
```

### 다중 프로세스 환경에서의 주소 할당

**이때 OS는 0~3번까지 주소를 사용하고 있고 P1은 7번 주소에 할당되어 있습니다. 그러면 절대 주소 7번이 프로세스 기준에는 0번이 됩니다. 이 말은 절대주소 7번을 기준으로 P1은 0번의 상대주소로 사용하고 있습니다. P1는 7번의 절대주소를 0번을 기준으로 사용할래! P2는 19번의 절대주소를 0번을 기준으로 사용할래! 이렇게 되는 것입니다**.

```
🏢 다중 프로세스 메모리 할당

H/W 물리 메모리 (절대주소):
┌─────────────────────────────────────────────────────┐
│  0~6   │  7~18  │  19~30 │  31~50 │  51~999        │
│   OS   │   P1   │   P2   │   기타 │   Available     │
└─────────────────────────────────────────────────────┘

각 프로세스의 논리 주소 공간 (상대주소):
┌─────────────────────────────────────────────────────┐
│  P1 프로세스:                                       │
│  • "나는 7번 절대주소를 0번 기준으로 사용할래!"     │
│  • 절대주소 7  → 논리주소 0 (P1의 시작점)           │
│  • 절대주소 8  → 논리주소 1                         │
│  • 절대주소 18 → 논리주소 11                        │
│                                                     │
│  P2 프로세스:                                       │
│  • "나는 19번 절대주소를 0번 기준으로 사용할래!"    │
│  • 절대주소 19 → 논리주소 0 (P2의 시작점)           │
│  • 절대주소 20 → 논리주소 1                         │
│  • 절대주소 30 → 논리주소 11                        │
└─────────────────────────────────────────────────────┘
```

```java
*// 다중 프로세스 주소 공간 시뮬레이션*
public class MultiProcessAddress {
    
    *// 프로세스별 독립 주소 공간*
    static class Process {
        private String name;
        private int baseAddress;      *// 물리 메모리 시작 주소*
        private int[] logicalMemory;  *// 논리 주소 공간 (0부터 시작)*
        
        public Process(String name, int baseAddress, int size) {
            this.name = name;
            this.baseAddress = baseAddress;
            this.logicalMemory = new int[size];
        }
        
        *// 논리 주소로 데이터 저장*
        public void store(int logicalAddr, int value) {
            logicalMemory[logicalAddr] = value;
            int physicalAddr = baseAddress + logicalAddr;
            
            System.out.printf("%s: 논리주소[%d] → 물리주소[%d]에 값 %d 저장\n", 
                name, logicalAddr, physicalAddr, value);
        }
        
        *// 논리 주소로 데이터 읽기*
        public int load(int logicalAddr) {
            int value = logicalMemory[logicalAddr];
            int physicalAddr = baseAddress + logicalAddr;
            
            System.out.printf("%s: 논리주소[%d] → 물리주소[%d]에서 값 %d 읽음\n", 
                name, logicalAddr, physicalAddr, value);
            return value;
        }
        
        public void printAddressInfo() {
            System.out.printf("%s - 기준점: 물리주소 %d를 논리주소 0으로 사용\n", 
                name, baseAddress);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("🔄 다중 프로세스 주소 변환 시뮬레이션\n");
        
        *// OS는 0~6번 주소 사용*
        System.out.println("OS: 물리주소 0~6 사용 중");
        
        *// 각 프로세스 생성*
        Process p1 = new Process("P1", 7, 12);   *// 물리주소 7~18*
        Process p2 = new Process("P2", 19, 12);  *// 물리주소 19~30*
        
        p1.printAddressInfo();
        p2.printAddressInfo();
        
        System.out.println("\n=== 메모리 접근 테스트 ===");
        
        *// 모든 프로세스가 논리주소 0에 접근// 하지만 실제로는 서로 다른 물리주소에 접근*
        p1.store(0, 100);  *// 물리주소 7*
        p2.store(0, 200);  *// 물리주소 19*
        
        *// 논리주소 5에 접근*
        p1.store(5, 150);  *// 물리주소 12*
        p2.store(5, 250);  *// 물리주소 24*
        
        System.out.println("\n=== 데이터 읽기 ===");
        p1.load(0);  *// 논리주소 0 → 물리주소 7*
        p2.load(0);  *// 논리주소 0 → 물리주소 19*
        
        System.out.println("\n💡 핵심:");
        System.out.println("• 각 프로세스는 0번부터 시작하는 독립적인 논리 주소 사용");
        System.out.println("• 실제로는 서로 다른 물리 주소에 매핑됨");
        System.out.println("• 프로세스는 자신만의 주소 공간이 있다고 착각");
    }
}
```

### 주소 변환의 핵심 원리

이러한 **절대주소와 상대주소 시스템**은 다음과 같은 중요한 특징을 가집니다:

```
🎯 주소 변환 시스템의 장점

독립성:
┌─────────────────────────────────────────────────────┐
│  • 각 프로세스는 0번부터 시작하는 주소 공간 사용    │
│  • 다른 프로세스의 존재를 모름                      │
│  • 메모리 충돌 방지                                 │
└─────────────────────────────────────────────────────┘

유연성:
┌─────────────────────────────────────────────────────┐
│  • 프로세스를 물리 메모리 어디에든 배치 가능        │
│  • 메모리 재배치 시 프로세스 코드 수정 불필요       │
│  • 동적 메모리 관리 가능                            │
└─────────────────────────────────────────────────────┘

보안성:
┌─────────────────────────────────────────────────────┐
│  • 경계 레지스터를 통한 하드웨어 수준 보호          │
│  • 프로세스 간 메모리 격리                          │
│  • 시스템 메모리 보호                               │
└─────────────────────────────────────────────────────┘
```

**이렇게 절대주소와 상대주소의 개념**은 **현대 컴퓨터 시스템에서 다중 프로세스 환경을 안전하고 효율적으로 관리하기 위한 기본 원리**입니다. **각 프로세스가 독립적인 논리 주소 공간을 가지면서도 실제로는 공유된 물리 메모리를 효율적으로 사용할 수 있게 하는 핵심 메커니즘**이라고 할 수 있습니다.