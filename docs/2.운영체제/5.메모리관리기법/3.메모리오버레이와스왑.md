# 메모리 오버레이와 스왑

## 메모리 오버레이 (Memory Overlay)

**메모리 오버레이(Memory Overlay)는 실제 주기억장치(메모리)보다 더 큰 프로그램을 실행하기 위해 사용하는 메모리 관리 기술입니다**.

### 초기 컴퓨터 환경의 메모리 제약

**예전에 컴퓨터 성능이 매우 안 좋았던 시절**에는 다음과 같은 극도로 제한된 환경이었습니다:

```
💻 1980년대 초기 PC 스펙

하드웨어 사양:
┌─────────────────────────────────────────────────────┐
│  RAM: 640KB (655,360 bytes)                        │
│  CPU: Intel 8088 XT 10MHz                          │
│  저장장치: 플로피 디스크 360KB                      │
│  HDD: 10MB (고급 사양)                              │
└─────────────────────────────────────────────────────┘

메모리 구조:
┌─────────────────────────────────────────────────────┐
│  640KB RAM 구성                                     │
│  ┌─────────────────────────────────────────────┐   │
│  │  운영체제 영역 (DOS): ~100KB               │   │
│  ├─────────────────────────────────────────────┤   │
│  │  공통 모듈 영역 (DLL류): ~50KB             │   │
│  ├─────────────────────────────────────────────┤   │
│  │  사용자 프로그램 영역: ~490KB              │   │
│  │  (실제 프로그램이 사용할 수 있는 공간)     │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

문제 상황:
• 워드프로세서 프로그램: 400KB
• 스프레드시트 프로그램: 350KB
• 게임 프로그램: 300KB
→ 동시 실행 불가능!

```

### 오버레이의 동작 원리

**운영체제 영역과 공통 모듈 영역(DLL 같은 것)을 제외한 메모리 공간이 그렇게 넉넉하지 않았습니다**. **그래서 어떠한 프로그램을 동작하고 다른 프로그램을 동작시킬 때 기존에 사용하던 프로그램의 메모리를 지우고 새롭게 동작할 프로그램의 메모리를 올립니다**. **그래서 메모리 위에 메모리가 overwrite 해서 겹겹이 쌓여서 동작하게 됩니다**.

```
🔄 메모리 오버레이 동작 과정

초기 상태:
┌─────────────────────────────────────────────────────┐
│  RAM (640KB)                                        │
│  ┌─────────────────────────────────────────────┐   │
│  │  운영체제 (100KB)                          │   │
│  ├─────────────────────────────────────────────┤   │
│  │  프로그램 A (400KB)                        │   │
│  │  • 워드프로세서 실행 중                    │   │
│  ├─────────────────────────────────────────────┤   │
│  │  빈 공간 (140KB)                           │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

프로그램 B 실행 요청:
┌─────────────────────────────────────────────────────┐
│  사용자: "게임을 실행하고 싶어요!"                  │
│  게임 프로그램 B: 300KB 필요                        │
│  사용 가능 공간: 140KB                              │
│  → 공간 부족! 오버레이 필요                         │
└─────────────────────────────────────────────────────┘

오버레이 실행:
┌─────────────────────────────────────────────────────┐
│  1단계: 기존 프로그램 제거                          │
│  ┌─────────────────────────────────────────────┐   │
│  │  운영체제 (100KB)                          │   │
│  ├─────────────────────────────────────────────┤   │
│  │  [프로그램 A 제거됨]                       │   │
│  │                                             │   │
│  ├─────────────────────────────────────────────┤   │
│  │  빈 공간 (540KB)                           │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  2단계: 새 프로그램 로드                            │
│  ┌─────────────────────────────────────────────┐   │
│  │  운영체제 (100KB)                          │   │
│  ├─────────────────────────────────────────────┤   │
│  │  프로그램 B (300KB)                        │   │
│  │  • 게임 실행 중                            │   │
│  ├─────────────────────────────────────────────┤   │
│  │  빈 공간 (240KB)                           │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

특징:
✅ 큰 프로그램도 실행 가능
❌ 이전 프로그램의 데이터 손실
❌ 프로그램 간 빠른 전환 불가
❌ 멀티태스킹 불가능

```

## 스왑 (Swap) 메모리 관리

### 스왑의 등장 배경

**그래서 이러한 문제를 해결하기 위해서 보조기억 장치인 HDD로 기존에 동작하던 프로세스의 정보를 HDD에 보내고 동작시키고를 반복해서 이 문제를 해결했었는데 이를 스왑이라고 합니다**.

```
💾 스왑 시스템의 개념

기본 아이디어:
┌─────────────────────────────────────────────────────┐
│  "RAM이 부족하면 HDD를 임시 메모리로 사용하자!"     │
│                                                     │
│  RAM (고속, 소용량) + HDD (저속, 대용량)            │
│  = 가상적으로 큰 메모리 공간 확보                   │
└─────────────────────────────────────────────────────┘

스왑 영역 설정:
┌─────────────────────────────────────────────────────┐
│  HDD (10MB)                                         │
│  ┌─────────────────────────────────────────────┐   │
│  │  일반 파일 시스템 (8MB)                    │   │
│  ├─────────────────────────────────────────────┤   │
│  │  스왑 영역 (2MB)                           │   │
│  │  • RAM 내용을 임시 저장하는 공간           │   │
│  │  • 운영체제가 직접 관리                    │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

```

### 스왑의 동작 방식

**그래서 HDD에서 스왑영역을 따로 지정하고 RAM과 이 HDD 영역을 합쳐서 컴퓨터가 실제 사용할 수 있는 메모리 공간인 것입니다**.

```
🔄 스왑 동작 메커니즘

전체 메모리 공간:
┌─────────────────────────────────────────────────────┐
│  가상 메모리 = RAM (640KB) + 스왑 영역 (2MB)        │
│  총 사용 가능: 약 2.6MB                             │
└─────────────────────────────────────────────────────┘

스왑 과정:
┌─────────────────────────────────────────────────────┐
│  1️⃣ 초기 상태                                      │
│  ┌─────────────┐    ┌─────────────┐                │
│  │    RAM      │    │ HDD 스왑영역 │                │
│  │ 프로그램 A  │    │    비어있음  │                │
│  │ 프로그램 B  │    │             │                │
│  └─────────────┘    └─────────────┘                │
│                                                     │
│  2️⃣ 메모리 부족 시 스왑 아웃                       │
│  ┌─────────────┐    ┌─────────────┐                │
│  │    RAM      │ →  │ HDD 스왑영역 │                │
│  │ 프로그램 B  │    │ 프로그램 A  │                │
│  │    빈공간   │    │ (백업됨)    │                │
│  └─────────────┘    └─────────────┘                │
│                                                     │
│  3️⃣ 새 프로그램 로드                               │
│  ┌─────────────┐    ┌─────────────┐                │
│  │    RAM      │    │ HDD 스왑영역 │                │
│  │ 프로그램 B  │    │ 프로그램 A  │                │
│  │ 프로그램 C  │    │ (대기 중)   │                │
│  └─────────────┘    └─────────────┘                │
│                                                     │
│  4️⃣ 필요 시 스왑 인                                │
│  ┌─────────────┐    ┌─────────────┐                │
│  │    RAM      │ ←  │ HDD 스왑영역 │                │
│  │ 프로그램 A  │    │ 프로그램 C  │                │
│  │    빈공간   │    │ (백업됨)    │                │
│  └─────────────┘    └─────────────┘                │
└─────────────────────────────────────────────────────┘

```

### 스왑 인/아웃 용어 정리

**그래서 HDD의 스왑영역에서 데이터를 가져오면 스왑인, RAM에서 HDD로 데이터를 보내면 스왑 아웃이라고 부릅니다**.

```
📝 스왑 용어 정리

스왑 아웃 (Swap Out):
┌─────────────────────────────────────────────────────┐
│  RAM → HDD 스왑영역                                 │
│  • 메모리 부족 시 사용하지 않는 프로세스를 HDD로   │
│  • 메모리 공간 확보 목적                            │
│  • 해당 프로세스는 일시 중단 상태                   │
└─────────────────────────────────────────────────────┘

스왑 인 (Swap In):
┌─────────────────────────────────────────────────────┐
│  HDD 스왑영역 → RAM                                 │
│  • 스왑 아웃된 프로세스를 다시 실행할 때           │
│  • 저장된 프로세스 상태를 RAM으로 복원             │
│  • 프로세스 실행 재개                               │
└─────────────────────────────────────────────────────┘

성능 특성:
⚡ RAM 접근 시간: 50-100ns
💾 HDD 접근 시간: 10-20ms (200,000배 느림!)
→ 스왑 발생 시 심각한 성능 저하

```

## 최대 절전 모드 (Hibernation)

### 절전 모드의 스왑 활용

**대표적인 사용 예시가 최대 절전 모드입니다. 절전 모드일 때 RAM에 있는 정보를 HDD로 옮겨두고 다시 전원이 들어오면 스왑인 하여 절전모드 이전에 작업했던 내용 그대로 이어서 처리할 수 있는 것입니다**.

```
🔋 최대 절전 모드 (Hibernation) 과정

절전 모드 진입:
┌─────────────────────────────────────────────────────┐
│  1단계: 현재 상태 백업                              │
│  ┌─────────────┐                                   │
│  │    RAM      │  모든 내용을                      │
│  │ • 열린 문서 │  ──────────→                      │
│  │ • 실행 중   │              ┌─────────────┐     │
│  │   프로그램  │              │ hiberfil.sys│     │
│  │ • 시스템    │              │  (HDD 파일) │     │
│  │   상태      │              └─────────────┘     │
│  └─────────────┘                                   │
│                                                     │
│  2단계: 전원 완전 차단                              │
│  • CPU, RAM 전력 공급 중단                          │
│  • 소비전력 0W                                      │
└─────────────────────────────────────────────────────┘

절전 모드 해제:
┌─────────────────────────────────────────────────────┐
│  1단계: 시스템 부팅                                 │
│  • 기본 하드웨어 초기화                             │
│  • 운영체제 기본 로딩                               │
│                                                     │
│  2단계: 저장된 상태 복원                            │
│  ┌─────────────┐              ┌─────────────┐     │
│  │    RAM      │  ←──────────  │ hiberfil.sys│     │
│  │ • 열린 문서 │              │  복원       │     │
│  │ • 실행 중   │              └─────────────┘     │
│  │   프로그램  │                                   │
│  │ • 시스템    │                                   │
│  │   상태      │                                   │
│  └─────────────┘                                   │
│                                                     │
│  결과: 절전 전 상태 그대로 복원!                    │
└─────────────────────────────────────────────────────┘

일반 절전 vs 최대 절전:
┌─────────────────────────────────────────────────────┐
│  일반 절전(Sleep):                                  │
│  • RAM 내용 유지 (소량 전력 소비)                   │
│  • 빠른 복원 (1-2초)                               │
│  • 전력 차단 시 데이터 손실                         │
│                                                     │
│  최대 절전(Hibernation):                            │
│  • RAM 내용을 HDD에 저장                            │
│  • 전력 소비 0W                                     │
│  • 복원 시간 느림 (10-30초)                         │
│  • 전력 차단되어도 데이터 안전                      │
└─────────────────────────────────────────────────────┘

```

## 현대적 메모리 관리와의 비교

### 과거와 현재의 차이점

```
📊 메모리 관리 기술의 발전

과거 (1980년대):
┌─────────────────────────────────────────────────────┐
│  • 물리 메모리: 640KB                               │
│  • 오버레이: 프로그램 교체로 공간 확보              │
│  • 스왑: HDD 활용으로 가상 메모리 구현              │
│  • 단일 프로그램 실행                               │
│  • 수동적 메모리 관리                               │
└─────────────────────────────────────────────────────┘

현재 (2020년대):
┌─────────────────────────────────────────────────────┐
│  • 물리 메모리: 16GB 이상                           │
│  • 가상 메모리: 프로세스별 독립 주소 공간          │
│  • 페이징: 세밀한 메모리 관리                       │
│  • 멀티태스킹: 수백 개 프로세스 동시 실행          │
│  • 자동적 메모리 관리 (OS + 하드웨어)              │
└─────────────────────────────────────────────────────┘

공통점:
✅ 스왑 개념은 여전히 사용됨 (SSD 기반)
✅ 절전 모드 원리는 동일
✅ 물리 메모리 한계 극복이라는 목적 동일

차이점:
🔄 오버레이 → 페이징으로 발전
🔄 단순 교체 → 정교한 가상 메모리 시스템
🔄 수동 관리 → 하드웨어/OS 자동 관리

```

### 현대 시스템에서의 스왑

```java
// 현대적 스왑 시스템 시뮬레이션
public class ModernSwapSystem {

    static class MemoryManager {
        private int physicalRAM;      // 물리 RAM 크기 (MB)
        private int swapSpace;        // 스왑 공간 크기 (MB)
        private int usedRAM;          // 사용 중인 RAM
        private int usedSwap;         // 사용 중인 스왑

        public MemoryManager(int ramSize, int swapSize) {
            this.physicalRAM = ramSize;
            this.swapSpace = swapSize;
            this.usedRAM = 0;
            this.usedSwap = 0;
        }

        public boolean allocateMemory(String processName, int size) {
            System.out.printf("\n🔄 %s 메모리 할당 요청: %dMB\n", processName, size);

            if (usedRAM + size <= physicalRAM) {
                // RAM에 직접 할당 가능
                usedRAM += size;
                System.out.printf("✅ RAM에 할당 완료: %dMB\n", size);
                printMemoryStatus();
                return true;
            } else {
                // 스왑 필요
                int needToSwap = (usedRAM + size) - physicalRAM;
                if (usedSwap + needToSwap <= swapSpace) {
                    System.out.printf("💾 스왑 아웃 필요: %dMB\n", needToSwap);
                    swapOut(needToSwap);
                    usedRAM = physicalRAM - size;
                    usedRAM += size;
                    System.out.printf("✅ 스왑 후 RAM에 할당: %dMB\n", size);
                    printMemoryStatus();
                    return true;
                } else {
                    System.out.printf("❌ 메모리 부족: 할당 실패\n");
                    return false;
                }
            }
        }

        private void swapOut(int size) {
            usedRAM -= size;
            usedSwap += size;
            System.out.printf("📤 %dMB를 스왅 영역으로 이동\n", size);
        }

        public void hibernate() {
            System.out.println("\n🔋 최대 절전 모드 진입...");
            System.out.printf("💾 현재 RAM 상태 (%dMB)를 hiberfil.sys에 저장\n", usedRAM);
            System.out.println("⚡ 전원 차단");
        }

        public void resumeFromHibernation() {
            System.out.println("\n🔌 전원 복구");
            System.out.println("📥 hiberfil.sys에서 이전 상태 복원 중...");
            System.out.printf("✅ RAM 상태 복원 완료: %dMB\n", usedRAM);
        }

        private void printMemoryStatus() {
            System.out.printf("📊 메모리 상태 - RAM: %d/%dMB, 스왑: %d/%dMB\n",
                usedRAM, physicalRAM, usedSwap, swapSpace);
        }
    }

    public static void main(String[] args) {
        // 16GB RAM, 32GB 스왑 시스템
        MemoryManager memManager = new MemoryManager(16384, 32768);

        System.out.println("🖥️  현대적 메모리 관리 시스템 시뮬레이션");
        memManager.printMemoryStatus();

        // 일반적인 메모리 할당
        memManager.allocateMemory("Chrome", 2048);
        memManager.allocateMemory("IntelliJ", 4096);
        memManager.allocateMemory("Photoshop", 6144);

        // 메모리 초과 상황
        memManager.allocateMemory("게임", 8192);

        // 절전 모드 시뮬레이션
        memManager.hibernate();
        memManager.resumeFromHibernation();

        System.out.println("\n💡 현대 vs 과거 스왑 시스템:");
        System.out.println("과거: 640KB RAM + 2MB HDD 스왑");
        System.out.println("현재: 16GB RAM + 32GB SSD 스왑");
        System.out.println("→ 4만 배 이상의 메모리 용량 증가!");
    }
}

```

이렇게 **메모리 오버레이와 스왑**은 컴퓨터 역사상 **제한된 메모리 자원을 효율적으로 활용하기 위한 핵심 기술**이었으며, **현대의 가상 메모리 시스템의 기초**가 되었습니다. 특히 **스왑의 개념**은 현재도 **SSD 기반의 가상 메모리 시스템**과 **절전 모드 구현**에서 계속 활용되고 있습니다.