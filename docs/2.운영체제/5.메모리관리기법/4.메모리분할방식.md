# 메모리 분할 방식

## 메모리 분할의 필요성

**실제 물리 메모리를 사용해야 되는 경우 S/W 기계언어가 저장될 때 필요합니다**. **이때 우리는 이 프로그램마다 크기가 제각각이기 때문에 이 크기를 예측하기는 어렵습니다**.

```
📊 프로그램별 메모리 요구량 (예시)

다양한 프로그램 크기:
┌─────────────────────────────────────────────────────┐
│  • 텍스트 에디터: 50KB                              │
│  • 웹 브라우저: 200MB                               │
│  • 게임: 4GB                                        │
│  • 동영상 플레이어: 150MB                           │
│  • 시스템 드라이버: 5KB                             │
│  • 데이터베이스: 1GB                                │
└─────────────────────────────────────────────────────┘

문제점:
❓ 각 프로그램이 필요로 하는 메모리 크기가 다름
❓ 실행 시점에 정확한 크기를 예측하기 어려움
❓ 효율적인 메모리 배치 방법이 필요
```

## 가변 분할 방식 (Variable Partitioning)

**메모리에 프로세스를 연속적인 메모리 공간에 할당합니다**. **이때 할당받는 프로세스의 크기는 각각 다릅니다**.

**가변 분할 방식에서 메모리 공간을 세그멘테이션이라고 합니다**.

```
🧩 가변 분할 방식의 동작

프로세스 할당 과정:
┌─────────────────────────────────────────────────────┐
│  물리 메모리 (1GB)                                  │
│  ┌─────────────────────────────────────────────┐   │
│  │  운영체제 (100MB)                          │   │
│  ├─────────────────────────────────────────────┤   │
│  │  프로세스 A (200MB)                        │   │
│  │  ┌───────────────────────┐                 │   │
│  │  │ 연속적인 메모리 공간  │                 │   │
│  │  └───────────────────────┘                 │   │
│  ├─────────────────────────────────────────────┤   │
│  │  프로세스 B (150MB)                        │   │
│  │  ┌───────────────────────┐                 │   │
│  │  │ 연속적인 메모리 공간  │                 │   │
│  │  └───────────────────────┘                 │   │
│  ├─────────────────────────────────────────────┤   │
│  │  프로세스 C (300MB)                        │   │
│  │  ┌───────────────────────┐                 │   │
│  │  │ 연속적인 메모리 공간  │                 │   │
│  │  └───────────────────────┘                 │   │
│  ├─────────────────────────────────────────────┤   │
│  │  남은 공간 (250MB)                         │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

특징:
✅ 각 프로세스는 정확히 필요한 만큼만 할당
✅ 프로세스별로 연속된 메모리 주소 사용
✅ 세그멘테이션 기법 활용
```

### 가변 분할 방식의 장단점

```
📈 가변 분할 방식 장단점 분석

장점:
┌─────────────────────────────────────────────────────┐
│  ✅ 메모리 효율성                                   │
│     • 프로세스 크기에 정확히 맞춤                   │
│     • 내부 단편화 없음                              │
│     • 메모리 낭비 최소화                            │
│                                                     │
│  ✅ 유연한 할당                                     │
│     • 다양한 크기의 프로세스 수용 가능              │
│     • 동적 메모리 관리 지원                         │
│                                                     │
│  ✅ 논리적 구조                                     │
│     • 프로세스별 독립된 세그먼트                    │
│     • 보안 및 보호 기능 구현 용이                   │
└─────────────────────────────────────────────────────┘

단점:
┌─────────────────────────────────────────────────────┐
│  ❌ 외부 단편화 발생                                │
│     • 프로세스 종료 시 빈 공간 조각화               │
│     • 연속된 큰 공간 확보 어려움                    │
│                                                     │
│  ❌ 복잡한 관리                                     │
│     • 가변 크기 메모리 블록 관리 복잡               │
│     • 할당/해제 알고리즘 복잡                       │
│                                                     │
│  ❌ 압축(Compaction) 필요                           │
│     • 주기적인 메모리 정리 작업 필요                │
│     • 압축 과정에서 성능 저하                       │
└─────────────────────────────────────────────────────┘
```

## 고정 분할 방식 (Fixed Partitioning)

**지정된 페이지 크기만큼만 프로세스를 할당합니다**. **만약에 지정된 크기보다 큰 프로세스는 다른 페이지에 할당됩니다**. **따라서 메모리 공간에 연속적으로 할당되지 않고 페이지의 지정된 크기만큼만 할당합니다**.

**그래서 고정 분할 방식은 중간중간마다 빈 공간이 발생할 수 있고 이를 프래그먼트라고 합니다**.

```
📄 고정 분할 방식의 동작

고정 크기 페이지 할당:
┌─────────────────────────────────────────────────────┐
│  물리 메모리를 동일한 크기로 분할 (예: 64MB 페이지)  │
│  ┌─────────┬─────────┬─────────┬─────────┬─────────┐ │
│  │ Page 0  │ Page 1  │ Page 2  │ Page 3  │ Page 4  │ │
│  │ 64MB    │ 64MB    │ 64MB    │ 64MB    │ 64MB    │ │
│  └─────────┴─────────┴─────────┴─────────┴─────────┘ │
└─────────────────────────────────────────────────────┘

프로세스 할당 예시:
┌─────────────────────────────────────────────────────┐
│  프로세스 A (50MB) → Page 0에 할당                  │
│  ┌─────────┐                                       │
│  │Process A│ 내부 단편화                            │
│  │  50MB   │ (14MB 낭비)                           │
│  │ ─ ─ ─ ─ │                                       │
│  │   빈공간 │                                       │
│  └─────────┘                                       │
│                                                     │
│  프로세스 B (100MB) → Page 1, 2에 분산 할당        │
│  ┌─────────┬─────────┐                             │
│  │Process B│Process B│ 내부 단편화                  │
│  │  64MB   │  36MB   │ (28MB 낭비)                 │
│  │         │ ─ ─ ─ ─ │                             │
│  │         │   빈공간 │                             │
│  └─────────┴─────────┘                             │
└─────────────────────────────────────────────────────┘

내부 단편화 (Internal Fragmentation):
• 할당된 페이지 내부의 사용하지 않는 공간
• 프로세스 크기 < 페이지 크기일 때 발생
• 메모리 낭비의 주요 원인
```

### 고정 분할 방식의 장단점

```
📊 고정 분할 방식 장단점 분석

장점:
┌─────────────────────────────────────────────────────┐
│  ✅ 관리의 단순성                                   │
│     • 동일한 크기의 블록으로 관리 용이              │
│     • 할당/해제 알고리즘 단순                       │
│     • 하드웨어 지원 우수 (페이징 하드웨어)          │
│                                                     │
│  ✅ 외부 단편화 없음                                │
│     • 모든 페이지가 동일 크기                       │
│     • 압축(Compaction) 불필요                       │
│                                                     │
│  ✅ 빠른 주소 변환                                  │
│     • 하드웨어 MMU 지원                             │
│     • 페이지 테이블을 통한 효율적 변환              │
│                                                     │
│  ✅ 멀티태스킹 지원                                 │
│     • 프로세스 별 독립적인 페이지 할당              │
│     • 메모리 보호 기능 구현 용이                    │
└─────────────────────────────────────────────────────┘

단점:
┌─────────────────────────────────────────────────────┐
│  ❌ 내부 단편화 발생                                │
│     • 페이지 내부의 사용하지 않는 공간 낭비         │
│     • 작은 프로세스일수록 낭비 심각                 │
│                                                     │
│  ❌ 페이지 크기 결정의 어려움                       │
│     • 너무 크면: 내부 단편화 증가                   │
│     • 너무 작으면: 관리 오버헤드 증가               │
│                                                     │
│  ❌ 메모리 활용도 저하                              │
│     • 프로세스 크기와 페이지 크기 불일치 시         │
│     • 전체적인 메모리 효율성 감소                   │
└─────────────────────────────────────────────────────┘
```

## 외부 단편화 문제와 해결책

### 외부 단편화 발생 과정

```
🔧 외부 단편화 발생 시나리오

초기 메모리 상태:
┌─────────────────────────────────────────────────────┐
│  프로세스 A (40KB) │ 프로세스 B (18KB) │ 프로세스 C (30KB) │
│  ──────────────────┼──────────────────┼──────────────────┤
│  프로세스 D (17KB) │ 프로세스 E (20KB) │    빈 공간       │
└─────────────────────────────────────────────────────┘

프로세스 B, D 종료 후:
┌─────────────────────────────────────────────────────┐
│  프로세스 A (40KB) │ [빈공간 18KB]   │ 프로세스 C (30KB) │
│  ──────────────────┼──────────────────┼──────────────────┤
│  [빈공간 17KB]     │ 프로세스 E (20KB) │    빈 공간       │
└─────────────────────────────────────────────────────┘

외부 단편화 문제:
• 총 빈 공간: 18KB + 17KB = 35KB
• 하지만 연속되지 않아서 35KB 프로그램 실행 불가
• 조각난 빈 공간들이 활용되지 못함
```

### 조각 모음 (Compaction) 해결책

**그래서 이러한 빈 공간을 모아서 사용할 수 있는 공간으로 만들어주는 조각 모음이 필요합니다**.

**이렇게 조각 모음이 발생하면 기존에 있던 프로세스 B와 D를 합쳐서 E 뒤쪽에 새롭게 공간을 만들어 주는데 이때 기존에 있던 프로세스 C와 E는 본인의 크기만큼 메모리 이동 발생하게 됩니다**.

```
🔄 조각 모음 (Compaction) 과정

압축 전 상태:
┌─────────────────────────────────────────────────────┐
│  프로세스 A (40KB) │ [빈공간 18KB]   │ 프로세스 C (30KB) │
│  ──────────────────┼──────────────────┼──────────────────┤
│  [빈공간 17KB]     │ 프로세스 E (20KB) │    빈 공간       │
└─────────────────────────────────────────────────────┘

압축 과정:
1단계: 프로세스들을 메모리 앞쪽으로 이동
┌─────────────────────────────────────────────────────┐
│  프로세스 A (40KB) │ 프로세스 C (30KB) │ 프로세스 E (20KB) │
│  ──────────────────┼──────────────────┼──────────────────┤
│                    연속된 빈 공간 (35KB)              │
└─────────────────────────────────────────────────────┘

2단계: 주소 재매핑
• 프로세스 C: 주소 58KB → 주소 40KB로 이동
• 프로세스 E: 주소 105KB → 주소 70KB로 이동
• 모든 포인터와 주소 참조 업데이트 필요

압축 후 결과:
✅ 35KB 연속 공간 확보
✅ 새로운 35KB 프로그램 실행 가능
❌ 프로세스 이동 비용 발생
❌ 주소 재매핑 오버헤드
```

### 조각 모음의 성능 고려사항

**근데 이때 이 조각모음을 하는 것에 대해서는 잘 판단해야 봐야 합니다**. **어쨌든 이 조각 모음 또한 CPU의 연산이 필요하기 때문에 프로세스가 빈번하게 종료되지 않는다면 불필요한 작업에 자원을 지나치게 사용하는 작업이 될 수 있는 것입니다**.

```
⚖️ 조각 모음 성능 분석

조각 모음 비용:
┌─────────────────────────────────────────────────────┐
│  💰 CPU 비용                                        │
│     • 메모리 복사 연산: O(사용중인 메모리 크기)     │
│     • 주소 재매핑: O(프로세스 수 × 참조 수)         │
│                                                     │
│  ⏱️ 시간 비용                                       │
│     • 모든 프로세스 일시 중단                       │
│     • 수 초에서 수 분 소요 가능                     │
│                                                     │
│  🔒 시스템 중단                                     │
│     • 압축 중 새로운 할당 불가                      │
│     • 사용자 응답성 저하                            │
└─────────────────────────────────────────────────────┘

조각 모음 실행 전략:
┌─────────────────────────────────────────────────────┐
│  🎯 언제 실행할 것인가?                             │
│     • 단편화율이 임계치 초과 시                     │
│     • 큰 프로세스 할당 실패 시                      │
│     • 시스템 유휴 시간 활용                         │
│                                                     │
│  📊 실행 기준                                       │
│     • 단편화율 > 30%                                │
│     • 최대 빈 공간 < 요청 크기                      │
│     • CPU 사용률 < 20% (유휴 시간)                  │
└─────────────────────────────────────────────────────┘
```

## 현대적 해결책: 페이지드 세그멘테이션

**현재는 이 두 가지 방식을 합성하여 사용하고 있습니다**.

```
🔄 페이지드 세그멘테이션 (Paged Segmentation)

하이브리드 접근법:
┌─────────────────────────────────────────────────────┐
│  세그멘테이션 + 페이징 결합                         │
│                                                     │
│  1단계: 논리적 세그먼트 생성                        │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Code Segment │Data Segment │Stack Segment│       │
│  └─────────────┴─────────────┴─────────────┘       │
│                                                     │
│  2단계: 각 세그먼트를 페이지로 분할                 │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Page│Page│..│Page│Page│..│Page│Page│..  │       │
│  └─────────────┴─────────────┴─────────────┘       │
│                                                     │
│  3단계: 페이지를 물리 메모리에 분산 배치            │
│  ┌─────────────────────────────────────────────┐   │
│  │     물리 메모리 (비연속적 배치)             │   │
│  │ Page3│Page1│Page5│Page2│Page7│Page4│Page6 │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

장점 결합:
✅ 세그멘테이션: 논리적 보호, 공유 용이
✅ 페이징: 외부 단편화 해결, 관리 단순
✅ 압축 불필요: 페이지 단위 할당으로 해결
✅ 효율적 메모리 활용: 두 방식의 장점만 취함
```

## 메모리 분할 방식 비교 정리

### 방식별 특성 요약

```
📊 메모리 분할 방식 종합 비교

┌─────────────────────────────────────────────────────┐
│  가변 분할 (세그멘테이션)                           │
│  ✅ 메모리 효율성 최고                              │
│  ✅ 내부 단편화 없음                                │
│  ❌ 외부 단편화 발생                                │
│  ❌ 복잡한 관리, 압축 필요                          │
│                                                     │
│  고정 분할 (페이징)                                 │
│  ✅ 관리 단순성                                     │
│  ✅ 외부 단편화 없음                                │
│  ❌ 내부 단편화 발생                                │
│  ❌ 페이지 크기 결정의 어려움                       │
│                                                     │
│  페이지드 세그멘테이션 (현대 방식)                  │
│  ✅ 두 방식의 장점 결합                             │
│  ✅ 단편화 문제 최소화                              │
│  ✅ 효율적이고 관리 용이                            │
│  ❌ 구현 복잡성 증가                                │
└─────────────────────────────────────────────────────┘
```

### 실제 운영체제에서의 적용

```
🖥️ 운영체제별 메모리 관리 방식

Linux:
┌─────────────────────────────────────────────────────┐
│  • 페이지 크기: 4KB (기본)                          │
│  • 세그멘테이션 + 페이징 혼합 사용                  │
│  • 가상 메모리: 프로세스당 독립적 주소 공간        │
│  • 스왑: 디스크 기반 가상 메모리 확장               │
└─────────────────────────────────────────────────────┘

Windows:
┌─────────────────────────────────────────────────────┐
│  • 페이지 크기: 4KB (x86), 8KB (x64)               │
│  • 가상 메모리 관리자 (Virtual Memory Manager)     │
│  • 페이지 파일: Windows의 스왑 파일                 │
│  • 힙 관리: 세그멘테이션 기반 동적 할당             │
└─────────────────────────────────────────────────────┘

macOS:
┌─────────────────────────────────────────────────────┐
│  • 페이지 크기: 4KB (Intel), 16KB (Apple Silicon)  │
│  • Mach 가상 메모리 시스템                          │
│  • 압축 메모리: 스왑 대신 메모리 압축 사용         │
│  • 통합 버퍼 캐시: 파일 시스템과 메모리 통합       │
└─────────────────────────────────────────────────────┘
```

### 성능 최적화 전략

```
⚡ 메모리 분할 성능 최적화

페이지 크기 최적화:
┌─────────────────────────────────────────────────────┐
│  작은 페이지 (4KB):                                 │
│  ✅ 내부 단편화 최소화                              │
│  ✅ 세밀한 메모리 보호                              │
│  ❌ 페이지 테이블 크기 증가                         │
│  ❌ TLB 미스율 증가                                 │
│                                                     │
│  큰 페이지 (2MB, 1GB):                              │
│  ✅ 페이지 테이블 크기 감소                         │
│  ✅ TLB 효율성 증가                                 │
│  ❌ 내부 단편화 증가                                │
│  ❌ 메모리 낭비 가능성                              │
└─────────────────────────────────────────────────────┘

적응적 관리 전략:
┌─────────────────────────────────────────────────────┐
│  🎯 워크로드별 최적화                               │
│     • 서버: 큰 페이지 (2MB) 사용                    │
│     • 데스크톱: 표준 페이지 (4KB) 사용              │
│     • 모바일: 압축 메모리 + 작은 페이지             │
│                                                     │
│  📊 동적 조정                                       │
│     • 메모리 사용 패턴 분석                         │
│     • 단편화율 모니터링                             │
│     • 실시간 페이지 크기 조정                       │
└─────────────────────────────────────────────────────┘
```

## 메모리 할당 알고리즘

메모리 분할 방식에서는 **어떤 빈 공간에 프로세스를 할당할지** 결정하는 알고리즘이 중요합니다:

```
🔍 메모리 할당 알고리즘

First Fit (최초 적합):
┌─────────────────────────────────────────────────────┐
│  • 첫 번째로 발견되는 충분한 크기의 블록에 할당     │
│  • 빠른 할당 속도                                   │
│  • 메모리 앞부분에 작은 조각들 생성 경향            │
└─────────────────────────────────────────────────────┘

Best Fit (최적 적합):
┌─────────────────────────────────────────────────────┐
│  • 요청 크기와 가장 비슷한 크기의 블록에 할당       │
│  • 메모리 효율성 높음                               │
│  • 검색 시간 오래 걸림                              │
│  • 매우 작은 조각들 생성 가능                       │
└─────────────────────────────────────────────────────┘

Worst Fit (최악 적합):
┌─────────────────────────────────────────────────────┐
│  • 가장 큰 블록에 할당                              │
│  • 큰 빈 공간 유지 가능                             │
│  • 전체적으로 비효율적                              │
│  • 실제로 거의 사용되지 않음                        │
└─────────────────────────────────────────────────────┘

Next Fit (다음 적합):
┌─────────────────────────────────────────────────────┐
│  • 이전 할당 위치부터 검색 시작                     │
│  • 메모리 전체에 고르게 분산                        │
│  • First Fit보다 약간 느림                          │
└─────────────────────────────────────────────────────┘
```

## 현대적 메모리 관리의 발전 방향

```
🚀 미래의 메모리 관리 기술

지능형 메모리 관리:
┌─────────────────────────────────────────────────────┐
│  🤖 AI 기반 예측                                    │
│     • 프로세스 메모리 사용 패턴 학습                │
│     • 선제적 메모리 할당/해제                       │
│     • 최적의 페이지 크기 자동 결정                  │
│                                                     │
│  📈 적응적 시스템                                   │
│     • 실시간 워크로드 분석                          │
│     • 동적 알고리즘 전환                            │
│     • 성능 지표 기반 자동 튜닝                      │
└─────────────────────────────────────────────────────┘

새로운 메모리 기술:
┌─────────────────────────────────────────────────────┐
│  🧠 영구 메모리 (Persistent Memory)                 │
│     • RAM과 스토리지의 경계 모호화                  │
│     • 새로운 메모리 계층 구조                       │
│     • 메모리 분할 방식의 근본적 변화                │
│                                                     │
│  ⚡ 고대역폭 메모리 (HBM)                           │
│     • 극고속 메모리 접근                            │
│     • 새로운 최적화 전략 필요                       │
│     • 메모리 지역성의 중요성 증대                   │
└─────────────────────────────────────────────────────┘
```

이렇게 **메모리 분할 방식**은 컴퓨터 시스템에서 **제한된 메모리 자원을 효율적으로 활용하기 위한 핵심 기술**로, **과거의 단순한 오버레이 방식에서 현대의 정교한 페이지드 세그멘테이션까지 지속적으로 발전**해왔습니다.

**메모하신 내용의 핵심인 외부 단편화 문제와 조각 모음의 트레이드오프**는 현재도 **가상 메모리 시스템 설계에서 중요한 고려사항**으로 남아있으며, 이를 해결하기 위해 **다양한 하이브리드 접근법**들이 계속 연구되고 있습니다.