## 해커가 암호 없이 관리자 권한을 얻응 방법

## 원격 코드 실행 취약점의 심각성

**우리가 뉴스에서 어떤 취약점이 발견되었다 특히 원격 코드 실행에 관련된 내용이면 이는 매우 크리티컬한 보안 이슈입니다**. **인증 자격 없는 공격자가 루트 권한으로 임의 코드를 실행 가능하다는 의미는 관리자 권한으로 시스템을 장악했다는 말과 같습니다 (해커한테 서버를 빼겼다)**.

```
🚨 원격 코드 실행 취약점의 위험도

CVSS (Common Vulnerability Scoring System) 기준:
┌─────────────────────────────────────────────────────┐
│  원격 코드 실행 + 권한 상승 = CVSS 9.0-10.0         │
│                                                     │
│  공격 벡터: Network (네트워크를 통한 원격 공격)     │
│  공격 복잡도: Low (쉬운 공격)                       │
│  필요 권한: None (인증 불필요)                      │
│  사용자 상호작용: None (자동 공격)                  │
│  영향도: Complete (완전한 시스템 장악)              │
│                                                     │
│  결과:                                              │
│  • 기밀성 손실: 모든 데이터 유출 가능               │
│  • 무결성 손실: 시스템 파일 변조 가능               │
│  • 가용성 손실: 서비스 중단, 랜섬웨어 설치 가능     │
└─────────────────────────────────────────────────────┘

실제 사례:
- EternalBlue (MS17-010): WannaCry 랜섬웨어의 전파 경로
- Log4Shell (CVE-2021-44228): 전 세계 Java 애플리케이션 영향
- BlueKeep (CVE-2019-0708): Windows RDP 원격 코드 실행
```

## 시스템 프로세스와 권한 구조

**리눅스 유닉스 계열에는 데몬, 윈도우는 서비스라고 부르는 시스템 프로세스가 있습니다. OS가 이들을 실행시켜 줍니다**. **이들은 컴퓨터가 국가라 할 때 이 시스템 프로세스들은 한 공무원들이라고 생각하면 됩니다**.

```
🏛️ 시스템 프로세스 권한 구조

컴퓨터 = 국가, 프로세스 = 시민/공무원:
┌─────────────────────────────────────────────────────┐
│  커널 (대통령/국왕)                                 │
│  ┌─────────────────────────────────────────────┐   │
│  │ 시스템 프로세스 (고위 공무원들)             │   │
│  │ • root/SYSTEM 권한 보유                     │   │
│  │ • 핵심 시스템 서비스 담당                   │   │
│  │                                             │   │
│  │ Linux 데몬 예시:                            │   │
│  │ - systemd (pid 1): 시스템 초기화            │   │
│  │ - sshd: 원격 접속 서비스                    │   │
│  │ - httpd/nginx: 웹 서버                      │   │
│  │ - mysqld: 데이터베이스 서버                 │   │
│  │                                             │   │
│  │ Windows 서비스 예시:                        │   │
│  │ - System (pid 4): 커널 시스템 프로세스      │   │
│  │ - csrss.exe: 윈도우 서브시스템              │   │
│  │ - winlogon.exe: 로그온 서비스               │   │
│  │ - services.exe: 서비스 제어 관리자          │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │ 사용자 프로세스 (일반 시민들)               │   │
│  │ • 제한된 권한                               │   │
│  │ • 시스템 리소스 접근 제한                   │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

## 게임 캐릭터 비유와 프로세스 정체성

**게임 같은 컴퓨터라는 월드에서 우리가 로그인을 했다면 해당 게임속에 또다른 나가 존재합니다(게임 캐릭터)**. **이러한 형태로 게임이라는 세상에서 나를 대신하는 존재가 있는데 컴퓨터 역시 로그인했을 때 나를 대신해서 존재하는 무언가가 존재하지 않을까?? 아마도 그건 프로세스 형태로 존재할 것입니다**.

```
🎮 게임 캐릭터 vs 컴퓨터 프로세스 비유

게임 세계에서:
┌─────────────────────────────────────────────────────┐
│  실제 나 (플레이어)                                 │
│       ↓ 게임 로그인                                 │
│  게임 캐릭터 (아바타)                               │
│  • 레벨, 직업, 권한 보유                            │
│  • 게임 내 행동 수행                                │
│  • 게임 규칙에 따라 제약                            │
└─────────────────────────────────────────────────────┘

컴퓨터 세계에서:
┌─────────────────────────────────────────────────────┐
│  실제 나 (사용자)                                   │
│       ↓ 시스템 로그인                               │
│  쉘 프로세스 (디지털 아바타)                        │
│  • UID/GID, 권한 보유                               │
│  • 시스템 명령 수행                                 │
│  • OS 보안 정책에 따라 제약                         │
└─────────────────────────────────────────────────────┘

프로세스 정체성 (Process Identity):
- UID (User ID): 프로세스 소유자
- GID (Group ID): 프로세스 그룹  
- EUID (Effective UID): 실제 권한 검사에 사용
- Capabilities: 세분화된 권한 단위
```

## 권한 상속과 로그인 프로세스

**그러면 앞에서 이러한 시스템 프로세스들은 권한을 가지고 있다 했습니다. 이 권한을 로그인 프로세스가 부여합니다**. **만약 내가 관리자로 로그인을 했다면 그 실행하는 프로세스는 관리자 권한을 가지게 됩니다**. **그렇게 실행한 프로세스 안에서 또다른 명령어를 실행합니다. 이때 부모의 권한을 자식 프로세스가 상속받습니다**.

```
👨‍👩‍👧‍👦 프로세스 권한 상속 트리

login process (로그인 프로세스)
├─ 사용자 인증 검증
├─ UID/GID 설정
└─ shell 프로세스 실행

shell process (bash, cmd.exe)
├─ 부모(login)의 권한 상속
├─ 사용자 명령 해석
└─ 자식 프로세스들 실행
    ├─ ls, cat, vim (일반 명령어)
    ├─ sudo, su (권한 상승 명령어)
    └─ 사용자 프로그램들

권한 상속 예시:
┌─────────────────────────────────────────────────────┐
│  admin 계정으로 로그인:                             │
│  login → shell (admin 권한)                         │
│         └─ vim (admin 권한)                         │
│            └─ 시스템 파일 편집 가능                 │
│                                                     │
│  guest 계정으로 로그인:                             │  
│  login → shell (guest 권한)                         │
│         └─ vim (guest 권한)                         │
│            └─ 시스템 파일 편집 불가                 │
└─────────────────────────────────────────────────────┘
```

```java
*// 프로세스 권한 상속 시뮬레이션*
public class ProcessPrivilegeInheritance {
    
    enum PrivilegeLevel {
        GUEST(1, "Guest"), 
        USER(2, "User"), 
        ADMIN(3, "Administrator"), 
        SYSTEM(4, "System");
        
        final int level;
        final String name;
        
        PrivilegeLevel(int level, String name) {
            this.level = level;
            this.name = name;
        }
    }
    
    static class Process {
        private String name;
        private PrivilegeLevel privilege;
        private Process parent;
        private List<Process> children;
        
        public Process(String name, PrivilegeLevel privilege, Process parent) {
            this.name = name;
            this.privilege = privilege;
            this.parent = parent;
            this.children = new ArrayList<>();
            
            if (parent != null) {
                parent.children.add(this);
            }
        }
        
        public Process createChildProcess(String childName) {
            *// 자식 프로세스는 부모의 권한을 상속*
            Process child = new Process(childName, this.privilege, this);
            System.out.printf("✅ %s가 %s 생성 (권한 상속: %s)\n", 
                name, childName, privilege.name);
            return child;
        }
        
        public boolean canAccess(String resource, PrivilegeLevel requiredLevel) {
            boolean hasAccess = privilege.level >= requiredLevel.level;
            System.out.printf("%s %s: %s 접근 시도 (필요: %s, 보유: %s)\n",
                hasAccess ? "✅" : "❌", name, resource, 
                requiredLevel.name, privilege.name);
            return hasAccess;
        }
        
        public void executeCommand(String command) {
            System.out.printf("🔧 %s가 명령 실행: %s (권한: %s)\n", 
                name, command, privilege.name);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("👨‍👩‍👧‍👦 프로세스 권한 상속 시뮬레이션\n");
        
        *// 로그인 프로세스 시뮬레이션*
        System.out.println("=== 관리자 로그인 시나리오 ===");
        Process loginProcess = new Process("login", PrivilegeLevel.SYSTEM, null);
        
        *// 관리자 쉘 생성 (권한 상속)*
        Process adminShell = new Process("bash", PrivilegeLevel.ADMIN, loginProcess);
        
        *// 관리자 쉘에서 명령어 실행*
        adminShell.executeCommand("cat /etc/passwd");
        adminShell.canAccess("/etc/shadow", PrivilegeLevel.ADMIN);
        
        *// 자식 프로세스들 생성*
        Process vim = adminShell.createChildProcess("vim");
        Process systemctl = adminShell.createChildProcess("systemctl");
        
        vim.canAccess("/etc/hosts", PrivilegeLevel.ADMIN);
        systemctl.canAccess("restart service", PrivilegeLevel.ADMIN);
        
        System.out.println("\n=== 일반 사용자 로그인 시나리오 ===");
        Process userLoginProcess = new Process("login", PrivilegeLevel.SYSTEM, null);
        Process userShell = new Process("bash", PrivilegeLevel.USER, userLoginProcess);
        
        userShell.executeCommand("ls -la");
        userShell.canAccess("/etc/shadow", PrivilegeLevel.ADMIN); *// 실패*
        
        Process userVim = userShell.createChildProcess("vim");
        userVim.canAccess("/home/user/document.txt", PrivilegeLevel.USER); *// 성공*
        userVim.canAccess("/etc/hosts", PrivilegeLevel.ADMIN); *// 실패*
        
        System.out.println("\n💡 핵심 원리:");
        System.out.println("• 자식 프로세스는 부모의 권한을 상속받음");
        System.out.println("• 로그인 프로세스가 초기 권한을 결정");
        System.out.println("• 권한 상승은 특별한 메커니즘(sudo, setuid) 필요");
    }
}
```

## 프로세스 인젝션 공격 시나리오

**소위 해킹을 한다라는 말은 이 삼바든 어떤 특정 프로세스든 이 관리자 권한을 가지고 있는 프로세스에 어떤 것을 주입합니다**. **그래서 1차적으로 주입된 정보를 가지고 기존 프로세스가 오작동하게 만들어서 쉘 프로세스를 실행하게 유도합니다**. **그러면 이 실행된 쉘은 관리자 권한을 가진 채로 동작하게 됩니다**.

```
🎯 Samba 프로세스 인젝션 공격 시나리오

정상 상황:
┌─────────────────────────────────────────────────────┐
│  Samba 서비스 (smbd)                                │
│  ├─ root 권한으로 실행                              │
│  ├─ 네트워크 파일 공유 처리                         │
│  ├─ 포트 445 리스닝                                 │
│  └─ 정상적인 SMB 프로토콜 처리                      │
└─────────────────────────────────────────────────────┘

공격 과정:
┌─────────────────────────────────────────────────────┐
│  1️⃣ 취약점 발견 (예: 버퍼 오버플로우)               │
│     • smbd 프로세스의 입력 검증 취약점              │
│     • 특정 SMB 패킷 처리 시 버퍼 오버런             │
│                                                     │
│  2️⃣ 악성 페이로드 전송                             │
│     공격자 → 특조된 SMB 패킷 → smbd 프로세스        │
│     [정상 데이터][NOP sled][shellcode][ret addr]    │
│                                                     │
│  3️⃣ 프로세스 실행 흐름 탈취                         │
│     • 리턴 주소 덮어쓰기                            │
│     • shellcode 영역으로 점프                       │
│     • smbd의 root 권한으로 임의 코드 실행           │
│                                                     │
│  4️⃣ 쉘 실행 (Reverse Shell)                        │
│     system("/bin/bash");                            │
│     → root 권한 bash 쉘 실행                        │
│     → 공격자에게 네트워크로 쉘 연결                 │
└─────────────────────────────────────────────────────┘

결과: 🔓 시스템 완전 장악
```

```java
// 프로세스 인젝션 공격 시뮬레이션 (교육 목적)
public class ProcessInjectionDemo {
    
    static class SystemProcess {
        private String name;
        private String privilege;
        private boolean vulnerable;
        private String[] allowedCommands;
        
        public SystemProcess(String name, String privilege, boolean vulnerable) {
            this.name = name;
            this.privilege = privilege;
            this.vulnerable = vulnerable;
            this.allowedCommands = new String[]{"normal_operation", "file_serve", "network_listen"};
        }
        
        public void processInput(String input) {
            System.out.printf("📥 %s 프로세스가 입력 처리: %s\n", name, 
                input.length() > 50 ? input.substring(0, 50) + "..." : input);
            
            // 취약점 시뮬레이션: 버퍼 오버플로우
            if (vulnerable && input.length() > 100) {
                System.out.println("⚠️  버퍼 오버플로우 감지!");
                
                // 악성 코드 패턴 검사
                if (input.contains("SHELLCODE") || input.contains("system(")) {
                    System.out.println("🚨 악성 코드 인젝션 시도 감지!");
                    executeInjectedCode(input);
                    return;
                }
            }
            
            // 정상 처리
            System.out.printf("✅ %s: 정상 입력 처리 완료\n", name);
        }
        
        private void executeInjectedCode(String maliciousInput) {
            System.out.println("💀 프로세스 실행 흐름 탈취됨!");
            
            // 인젝션된 코드가 프로세스 권한으로 실행
            if (maliciousInput.contains("system(/bin/bash)")) {
                spawnMaliciousShell();
            } else if (maliciousInput.contains("reverse_shell")) {
                createReverseShell();
            }
        }
        
        private void spawnMaliciousShell() {
            System.out.printf("🐚 악성 쉘 실행! (권한: %s)\n", privilege);
            System.out.println("   └─ 공격자가 시스템 명령 실행 가능");
            System.out.println("   └─ 파일 시스템 전체 접근 가능");
            System.out.println("   └─ 다른 서비스 조작 가능");
            
            // 시스템 장악 시뮬레이션
            System.out.println("\n🔓 시스템 장악 완료:");
            System.out.println("   • /etc/passwd 읽기 ✓");
            System.out.println("   • 백도어 설치 ✓");
            System.out.println("   • 로그 삭제 ✓");
            System.out.println("   • 추가 취약점 스캔 ✓");
        }
        
        private void createReverseShell() {
            System.out.printf("🔗 리버스 쉘 연결! (권한: %s)\n", privilege);
            System.out.println("   └─ 공격자 서버로 쉘 연결");
            System.out.println("   └─ 방화벽 우회 (내부→외부 연결)");
            System.out.println("   └─ 지속적인 원격 제어 가능");
        }
    }
    
    static class SecurityMonitor {
        public void detectSuspiciousActivity(String activity) {
            System.out.printf("🛡️  보안 모니터링: %s\n", activity);
            
            // 비정상 프로세스 실행 감지
            if (activity.contains("unexpected_shell") || activity.contains("privilege_escalation")) {
                System.out.println("🚨 비정상 활동 차단!");
                System.out.println("   └─ 프로세스 강제 종료");
                System.out.println("   └─ 관리자 알림 발송");
                System.out.println("   └─ 시스템 격리 모드 전환");
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("🎯 프로세스 인젝션 공격 시뮬레이션 (교육용)\n");
        
        // 취약한 시스템 프로세스 생성
        SystemProcess sambaProcess = new SystemProcess("smbd", "root", true);
        SecurityMonitor monitor = new SecurityMonitor();
        
        System.out.println("=== 정상 동작 테스트 ===");
        sambaProcess.processInput("GET /share/file.txt");
        sambaProcess.processInput("AUTH user:password");
        
        System.out.println("\n=== 공격 시나리오 1: 버퍼 오버플로우 ===");
        String attack1 = "A".repeat(120) + "SHELLCODE" + "system(/bin/bash)" + "RETURN_ADDRESS";
        sambaProcess.processInput(attack1);
        
        monitor.detectSuspiciousActivity("unexpected_shell");
        
        System.out.println("\n=== 공격 시나리오 2: 리버스 쉘 ===");
        String attack2 = "NORMAL_REQUEST" + "A".repeat(100) + "reverse_shell:attacker.com:4444";
        sambaProcess.processInput(attack2);
        
        System.out.println("\n💡 방어 방법:");
        System.out.println("• 입력 검증 및 길이 제한");
        System.out.println("• ASLR, DEP, Stack Canary 적용");
        System.out.println("• 최소 권한 원칙 (Principle of Least Privilege)");
        System.out.println("• 시스템 프로세스 모니터링");
        System.out.println("• 정기적 보안 업데이트");
    }
}
```

## Secure OS와 방어 메커니즘

**그래서 관리자 권한을 가진 시스템 프로세스의 실행을 제한하고 OS 수준에서 모니터링해서 지정되지 않는 프로세스가 동작하면 차단하는 기술을 Secure OS라고 합니다**.

```
🛡️ Secure OS 방어 메커니즘

MAC (Mandatory Access Control):
┌─────────────────────────────────────────────────────┐
│  SELinux (Security-Enhanced Linux):                 │
│  • Type Enforcement: 프로세스별 타입 라벨           │
│  • Role-Based Access Control                        │
│  • Multi-Level Security                             │
│                                                     │
│  예시 정책:                                         │
│  httpd_t 타입 프로세스는:                           │
│  • httpd_config_t 파일만 읽기 가능                  │
│  • httpd_log_t 파일만 쓰기 가능                     │
│  • /bin/bash 실행 금지                              │
│  • 네트워크 80, 443 포트만 바인딩 가능              │
└─────────────────────────────────────────────────────┘

AppArmor (Application Armor):
┌─────────────────────────────────────────────────────┐
│  Path-based Access Control:                         │
│  • 프로그램별 프로파일 정의                         │
│  • 파일 시스템 경로 기반 제어                       │
│                                                     │
│  /usr/sbin/apache2 프로파일:                        │
│  capability net_bind_service,                       │
│  /var/www/** r,                                     │
│  /var/log/apache2/** rw,                            │
│  deny /bin/bash x,                                  │
│  deny /etc/passwd r,                                │
└─────────────────────────────────────────────────────┘

Windows Defender Application Control:
┌─────────────────────────────────────────────────────┐
│  Code Integrity Policies:                           │
│  • 서명된 바이너리만 실행 허용                      │
│  • 관리자가 승인한 애플리케이션만 실행              │
│  • 스크립트 실행 제한                               │
│                                                     │
│  Control Flow Guard (CFG):                          │
│  • 간접 호출 검증                                   │
│  • ROP/JOP 공격 차단                                │
└─────────────────────────────────────────────────────┘

실시간 모니터링:
┌─────────────────────────────────────────────────────┐
│  System Call Monitoring:                            │
│  • execve() 호출 감시                               │
│  • 비정상적인 프로세스 생성 탐지                    │
│  • 권한 상승 시도 모니터링                          │
│                                                     │
│  Behavioral Analysis:                               │
│  • 프로세스 행동 패턴 분석                          │
│  • 기준선 대비 이상 행동 탐지                       │
│  • 머신러닝 기반 이상 탐지                          │
└─────────────────────────────────────────────────────┘
```

## 현대적 공격과 방어의 발전

```
⚔️ 공격 기법의 진화

전통적 공격 (2000년대):
- 단순 버퍼 오버플로우
- 쉘코드 직접 실행
- 고정된 주소 활용

현대적 공격 (2020년대):
- Return-Oriented Programming (ROP)
- Jump-Oriented Programming (JOP)  
- Blind ROP (BROP)
- Heap Feng Shui
- Time-of-Check-to-Time-of-Use (TOCTOU)

차세대 공격 (미래):
- AI 기반 자동 익스플로잇 생성
- 양자 컴퓨팅 활용 암호 공격
- 하드웨어 사이드 채널 공격

🛡️ 방어 기법의 진화

기본 방어:
- DEP/NX, ASLR, Stack Canary

고급 방어:
- Intel CET, ARM Pointer Authentication
- Control Flow Integrity (CFI)
- Kernel Address Space Layout Randomization (KASLR)

AI 기반 방어:
- 머신러닝 이상 탐지
- 행동 기반 분석
- Zero-day 공격 예측
```