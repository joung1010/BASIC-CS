## 가상 메모리

## 가상 메모리의 필요성

**컴퓨터마다 물리 메모리가 다를 수 있습니다. 기본적으로 주기억장치인 RAM과 보조기억장치 HDD(SSD)가 있는데 이는 컴퓨터마다 용량과 스펙이 다를 수 있습니다**. **그렇다면 이렇게 용량과 스펙이 달라질 때마다 특정 S/W에 의존해서 코드를 수정해야 하면 매우 번거로운 일이 될 것입니다**. **그래서 H/W가 달라지더라도 정상적으로 동작할 수 있게끔 하기 위해서 가상 메모리가 필요합니다**.

```
💻 하드웨어 다양성 문제

시나리오 1: 개발 환경
┌─────────────────────────────────────────────────────┐
│  개발자 PC: 32GB RAM                                │
│  프로그램: "메모리 주소 0x12345678에 데이터 저장"   │
└─────────────────────────────────────────────────────┘

시나리오 2: 사용자 환경  
┌─────────────────────────────────────────────────────┐
│  사용자 PC: 8GB RAM                                 │
│  프로그램: "메모리 주소 0x12345678에 데이터 저장"   │
│  → 해당 주소가 존재하지 않을 수 있음!               │
└─────────────────────────────────────────────────────┘

가상 메모리 해결책:
┌─────────────────────────────────────────────────────┐
│  모든 프로그램: "가상 주소 0x00001000에 저장"       │
│  → 가상 메모리가 실제 물리 주소로 자동 변환         │
│  → 하드웨어 독립적인 프로그래밍 가능                │
└─────────────────────────────────────────────────────┘
```

## 가상 메모리의 추상화 이점

**또한 관리적인 측면에서 높은 추상성을 제공해 줍니다. 즉 추상성을 제공함으로써 해당 자원에 대한 접근 제어가 가능하고 이에 따라 보안적 이점을 얻을 수 있습니다**.

**주요 이점:**

- **하드웨어적 1차, 2차 메모리에 대한 의존성 제거**
- **추상성 제공**

```
🛡️ 가상 메모리의 보안 및 관리 이점

보안 이점:
┌─────────────────────────────────────────────────────┐
│  프로세스 격리:                                     │
│  • 프로세스 A가 프로세스 B의 메모리에 접근 불가     │
│  • 악성 프로그램의 시스템 메모리 침범 방지          │
│  • 메모리 보호 위반 시 자동 프로세스 종료           │
│                                                     │
│  권한 제어:                                         │
│  • 읽기 전용, 쓰기 전용, 실행 전용 페이지 설정      │
│  • 커널 메모리와 사용자 메모리 엄격 분리            │
│  • 시스템 호출을 통한 제어된 커널 접근              │
└─────────────────────────────────────────────────────┘

관리 이점:
┌─────────────────────────────────────────────────────┐
│  투명성:                                            │
│  • 프로그래머는 물리 메모리 크기를 신경 쓸 필요 없음│
│  • 메모리 부족 시 자동 스왑 처리                    │
│  • 메모리 단편화 자동 해결                          │
│                                                     │
│  유연성:                                            │
│  • 물리 메모리보다 큰 프로그램 실행 가능            │
│  • 여러 프로그램의 동시 실행 지원                   │
│  • 동적 메모리 할당/해제 자동 관리                  │
└─────────────────────────────────────────────────────┘
```

## 32bit 시스템의 가상 주소 공간

**메모리의 최소 관리 단위는 1byte이고 cpu나 운영체제가 32bit, 64bit에 따라 주소 체계가 달라집니다. 32bit 기준 용량으로 계산했을 때 4GB입니다**.

**이때 기본적으로 32bit 응용 S/W 기준 VMS의 크기를 반으로 나눠서 관리합니다**:

```
📏 32bit 시스템 가상 주소 공간 구조

전체 가상 주소 공간 (4GB = 2^32):
┌─────────────────────────────────────────────────────┐
│  0x00000000                                         │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │         User Mode 영역                      │   │
│  │            (2GB)                            │   │
│  │                                             │   │
│  │  ┌─────────────────────────────────────┐   │   │
│  │  │ OS 사용 영역 (~200MB)              │   │   │
│  │  ├─────────────────────────────────────┤   │   │
│  │  │ 실제 사용자 프로그램 영역           │   │   │
│  │  │ (~1.8GB)                           │   │   │
│  │  └─────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│  0x7FFFFFFF                                         │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │         Kernel Mode 영역                    │   │
│  │            (2GB)                            │   │
│  │                                             │   │
│  │  • 운영체제 코드                           │   │
│  │  • 시스템 드라이버                         │   │
│  │  • 메모리 관리자                           │   │
│  │  • 하드웨어 추상화 계층                    │   │
│  └─────────────────────────────────────────────┘   │
│  0xFFFFFFFF                                         │
└─────────────────────────────────────────────────────┘

실제 사용 가능 공간:
- 이론적 사용자 공간: 2GB
- OS가 사용하는 부분: ~200MB  
- 실제 프로그램 사용 가능: ~1.8GB
```

## 메모리 관리자와 동적 주소 변환

**가상메모리에서 이 메모리 매니저는 커널쪽에 위치해 있고 이 메모리 매니저가 관리할 수 있는 메모리의 최대 크기가 실제 메모리의 크기입니다(RAM + Swap 영역의 HDD)**. **가상 메모리에서 메모리 매니저는 물리 메모리와 swap 영역을 합쳐서 프로세스가 사용하는 가상 주소공간을 실제 물리 메모리 주소로 변환하는데 이러한 작업을 동적 주소 변환이라고 합니다**.

```
🔄 동적 주소 변환 (Dynamic Address Translation)

메모리 관리자의 역할:
┌─────────────────────────────────────────────────────┐
│  가상 주소 공간 관리:                               │
│  • 프로세스별 독립적인 4GB 가상 주소 공간 제공      │
│  • 가상 주소 → 물리 주소 매핑 테이블 관리          │
│                                                     │
│  물리 메모리 관리:                                  │
│  • RAM (16GB) + 스왑 공간 (32GB) = 총 48GB         │
│  • 페이지 할당/해제 관리                            │
│  • 스왑 인/아웃 결정                                │
│                                                     │
│  주소 변환 과정:                                    │
│  프로세스 A의 가상주소 0x1000                       │
│  → 매핑 테이블 검사                                 │
│  → 물리주소 0x5F2000으로 변환                       │
│  → 실제 메모리 접근                                 │
└─────────────────────────────────────────────────────┘
```

## 하이브리드 메모리 관리 방식

**그래서 가상 메모리 시스템에서 가변분할 방식을 이용한 메모리 관리 기법은 세그멘테이션과 고정분할 방식의 페이지 처리를 적절히 혼용하여 사용합니다**.

```
🔧 페이지드 세그멘테이션 구조

논리적 구조 (세그멘테이션):
┌─────────────────────────────────────────────────────┐
│  프로세스 가상 주소 공간                            │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Code Segment │Data Segment │Stack Segment│       │
│  │   (읽기전용) │  (읽기쓰기)  │  (동적증가)  │       │
│  └─────────────┴─────────────┴─────────────┘       │
└─────────────────────────────────────────────────────┘
              ↓ 각 세그먼트를 페이지로 분할
┌─────────────────────────────────────────────────────┐
│  물리적 구조 (페이징)                               │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐       │
│  │Page │Page │Page │Page │Page │Page │Page │       │
│  │ 0   │ 1   │ 2   │ 3   │ 4   │ 5   │ 6   │       │
│  │4KB  │4KB  │4KB  │4KB  │4KB  │4KB  │4KB  │       │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┘       │
│              ↓ 물리 메모리에 분산 배치               │
│  실제 RAM: [Page2][Page0][Page5][Page1][Page3]...   │
└─────────────────────────────────────────────────────┘
```

## 프로세스별 독립적 가상 주소 공간

**이 프로세스마다 할당된 가상 메모리공간은 항상 그 시작은 0번으로 시작합니다**. **프로세스마다 독립된 메모리 공간을 할당받기 때문에 프로세스마다 할당받은 공간의 주소 30번은 실제 프로세스 1번의 30번과 프로세스 2번의 30번 주소는 실제 물리주소의 위치는 서로 다른 주소를 가리킬 수 있습니다**.

**즉, 프로세스 1,2,3의 같은 주소를 논한다 하여 물리 메모리 상에서도 같은 주소냐 하면 절대 그렇지 않습니다**.

```java
*// 가상 주소 공간 시뮬레이션*
public class VirtualMemoryDemo {
    
    static class Process {
        private String name;
        private Map<Integer, Integer> virtualToPhysical; *// 가상주소 → 물리주소 매핑*
        
        public Process(String name) {
            this.name = name;
            this.virtualToPhysical = new HashMap<>();
        }
        
        public void mapVirtualToPhysical(int virtualAddr, int physicalAddr) {
            virtualToPhysical.put(virtualAddr, physicalAddr);
        }
        
        public void accessMemory(int virtualAddr) {
            Integer physicalAddr = virtualToPhysical.get(virtualAddr);
            if (physicalAddr != null) {
                System.out.printf("%s: 가상주소 0x%04X → 물리주소 0x%04X 접근\n", 
                    name, virtualAddr, physicalAddr);
            } else {
                System.out.printf("%s: 가상주소 0x%04X → 페이지 폴트 발생!\n", 
                    name, virtualAddr);
            }
        }
    }
    
    static class VirtualMemoryManager {
        private Map<String, Process> processes;
        private int nextPhysicalAddr;
        
        public VirtualMemoryManager() {
            this.processes = new HashMap<>();
            this.nextPhysicalAddr = 0x1000; *// 물리 메모리 시작 주소*
        }
        
        public void createProcess(String processName) {
            processes.put(processName, new Process(processName));
            System.out.printf("✅ %s 생성: 가상 주소 0x0000부터 시작\n", processName);
        }
        
        public void allocateMemory(String processName, int virtualAddr, int size) {
            Process process = processes.get(processName);
            if (process != null) {
                *// 가상 주소를 물리 주소에 매핑*
                process.mapVirtualToPhysical(virtualAddr, nextPhysicalAddr);
                System.out.printf("📦 %s: 가상주소 0x%04X → 물리주소 0x%04X 할당 (%d bytes)\n", 
                    processName, virtualAddr, nextPhysicalAddr, size);
                nextPhysicalAddr += size;
            }
        }
        
        public void accessMemory(String processName, int virtualAddr) {
            Process process = processes.get(processName);
            if (process != null) {
                process.accessMemory(virtualAddr);
            }
        }
    }
    
    public static void main(String[] args) {
        VirtualMemoryManager vmm = new VirtualMemoryManager();
        
        System.out.println("🖥️  가상 메모리 시스템 시뮬레이션\n");
        
        *// 3개 프로세스 생성 (모두 가상주소 0x0000부터 시작)*
        vmm.createProcess("프로세스A");
        vmm.createProcess("프로세스B");  
        vmm.createProcess("프로세스C");
        
        System.out.println("\n=== 메모리 할당 ===");
        *// 모든 프로세스가 같은 가상주소 0x0030에 메모리 할당*
        vmm.allocateMemory("프로세스A", 0x0030, 100);
        vmm.allocateMemory("프로세스B", 0x0030, 200);
        vmm.allocateMemory("프로세스C", 0x0030, 150);
        
        System.out.println("\n=== 같은 가상주소 접근 테스트 ===");
        *// 모든 프로세스가 같은 가상주소 0x0030 접근*
        vmm.accessMemory("프로세스A", 0x0030);
        vmm.accessMemory("프로세스B", 0x0030);
        vmm.accessMemory("프로세스C", 0x0030);
        
        System.out.println("\n💡 결과 분석:");
        System.out.println("• 모든 프로세스가 가상주소 0x0030 사용");
        System.out.println("• 하지만 실제로는 서로 다른 물리주소에 매핑됨");
        System.out.println("• 프로세스 간 메모리 격리 보장");
    }
}
```

## 매핑 테이블과 메모리 관리

**그래서 메모리 관리자가 이 매핑 테이블이라는 자료구조를 가지고 있습니다. 이 매핑테이블은 프로세스 A가 어떠한 위치에 있고 그 위치는 몇 번 세그먼트에 있어요 하는 정보를 가지고 있습니다**.

```
📋 매핑 테이블 구조

세그먼트 테이블 예시:
┌─────────────────────────────────────────────────────┐
│  프로세스 | 가상주소 | 물리위치  | 상태              │
│  ───────┼─────────┼─────────┼──────────────       │
│     A    │   0x0000 │ 세그먼트0 │ 메모리 적재        │
│     B    │   0x0000 │ 세그먼트1 │ 메모리 적재        │  
│     C    │   0x0000 │ 세그먼트2 │ 메모리 적재        │
│     D    │   0x0000 │   스왑    │ 디스크 대기        │
└─────────────────────────────────────────────────────┘

페이지 테이블 예시:
┌─────────────────────────────────────────────────────┐
│  프로세스A 페이지 테이블:                           │
│  ┌────────────┬─────────────┬──────────────┐       │
│  │ 가상페이지 │  물리페이지 │    상태      │       │
│  ├────────────┼─────────────┼──────────────┤       │
│  │     0      │      5      │   Present    │       │
│  │     1      │      12     │   Present    │       │
│  │     2      │     Swap    │   Swapped    │       │
│  │     3      │      8      │   Present    │       │
│  └────────────┴─────────────┴──────────────┘       │
└─────────────────────────────────────────────────────┘
```

**매핑 테이블은 세그멘테이션으로 분할된 경우뿐만 아니라 페이징으로 분할된 경우도 똑같은 방식으로 적용됩니다**.

## 메모리 회수와 관리 이점

**이렇게 매핑 테이블을 OS에서 관리하면 좋은 점은 프로세스A가 연산 중에 장애나 특정이유로 죽는다면 매핑테이블에서 이를 제거하고 빈공간으로 만들면 됩니다(메모리 회수). 이러한 부분이 바로 앞에서 언급했던 관리적인 측면에서의 이점입니다**.

```
🔄 자동 메모리 회수 과정

프로세스 종료 전:
┌─────────────────────────────────────────────────────┐
│  매핑 테이블:                                       │
│  프로세스A → 물리주소 0x1000-0x2000 (4KB)          │
│  프로세스B → 물리주소 0x3000-0x4000 (4KB)          │
│  프로세스C → 물리주소 0x5000-0x6000 (4KB)          │
│                                                     │
│  물리 메모리 상태: [A][빈공간][B][빈공간][C]        │
└─────────────────────────────────────────────────────┘

프로세스A 비정상 종료 후:
┌─────────────────────────────────────────────────────┐
│  1. 매핑 테이블에서 프로세스A 엔트리 제거            │
│  2. 해당 물리 메모리 영역을 "빈 공간"으로 표시      │
│  3. 다른 프로세스가 해당 영역 재사용 가능           │
│                                                     │
│  업데이트된 매핑 테이블:                            │
│  프로세스B → 물리주소 0x3000-0x4000 (4KB)          │
│  프로세스C → 물리주소 0x5000-0x6000 (4KB)          │
│                                                     │
│  물리 메모리 상태: [빈공간][빈공간][B][빈공간][C]    │
└─────────────────────────────────────────────────────┘

자동 회수의 장점:
✅ 메모리 누수 방지
✅ 시스템 안정성 향상  
✅ 자원 효율성 극대화
✅ 개발자의 메모리 관리 부담 감소
```

## 현대적 확장: 64bit 시스템

참고로 현재는 대부분 **64bit 시스템**을 사용하므로 주소 공간이 훨씬 큽니다:

```
📈 32bit vs 64bit 가상 주소 공간 비교

32bit 시스템:
- 총 주소 공간: 4GB (2^32)
- 사용자 공간: 2GB (실제 ~1.8GB)
- 커널 공간: 2GB

64bit 시스템:
- 총 주소 공간: 16EB (2^64) - 이론적
- 실제 사용: 256TB (48bit 주소 사용)
- 사용자 공간: 128TB
- 커널 공간: 128TB

현실적 의미:
- 32bit: 메모리 부족 문제 빈번
- 64bit: 실질적으로 무제한 메모리 공간
- 대용량 데이터 처리 가능
- 메모리 관리 정책 변화
```

메모하신 **가상 메모리 개념**은 현대 컴퓨터 시스템의 **핵심 기반 기술**로, **프로그램의 이식성, 보안성, 효율성**을 동시에 보장하는 중요한 추상화 계층입니다!