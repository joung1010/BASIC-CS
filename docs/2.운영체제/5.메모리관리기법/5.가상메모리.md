## 가상 메모리

## 가상 메모리의 필요성

**컴퓨터마다 물리 메모리가 다를 수 있습니다. 기본적으로 주기억장치인 RAM과 보조기억장치 HDD(SSD)가 있는데 이는 컴퓨터마다 용량과 스펙이 다를 수 있습니다**. **그렇다면 이렇게 용량과 스펙이 달라질 때마다 특정 S/W에 의존해서 코드를 수정해야 하면 매우 번거로운 일이 될 것입니다**. **그래서 H/W가 달라지더라도 정상적으로 동작할 수 있게끔 하기 위해서 가상 메모리가 필요합니다**.

```
💻 하드웨어 다양성 문제

시나리오 1: 개발 환경
┌─────────────────────────────────────────────────────┐
│  개발자 PC: 32GB RAM                                │
│  프로그램: "메모리 주소 0x12345678에 데이터 저장"   │
└─────────────────────────────────────────────────────┘

시나리오 2: 사용자 환경  
┌─────────────────────────────────────────────────────┐
│  사용자 PC: 8GB RAM                                 │
│  프로그램: "메모리 주소 0x12345678에 데이터 저장"   │
│  → 해당 주소가 존재하지 않을 수 있음!               │
└─────────────────────────────────────────────────────┘

가상 메모리 해결책:
┌─────────────────────────────────────────────────────┐
│  모든 프로그램: "가상 주소 0x00001000에 저장"       │
│  → 가상 메모리가 실제 물리 주소로 자동 변환         │
│  → 하드웨어 독립적인 프로그래밍 가능                │
└─────────────────────────────────────────────────────┘
```

## 가상 메모리의 추상화 이점

**또한 관리적인 측면에서 높은 추상성을 제공해 줍니다. 즉 추상성을 제공함으로써 해당 자원에 대한 접근 제어가 가능하고 이에 따라 보안적 이점을 얻을 수 있습니다**.

**주요 이점:**

- **하드웨어적 1차, 2차 메모리에 대한 의존성 제거**
- **추상성 제공**

```
🛡️ 가상 메모리의 보안 및 관리 이점

보안 이점:
┌─────────────────────────────────────────────────────┐
│  프로세스 격리:                                     │
│  • 프로세스 A가 프로세스 B의 메모리에 접근 불가     │
│  • 악성 프로그램의 시스템 메모리 침범 방지          │
│  • 메모리 보호 위반 시 자동 프로세스 종료           │
│                                                     │
│  권한 제어:                                         │
│  • 읽기 전용, 쓰기 전용, 실행 전용 페이지 설정      │
│  • 커널 메모리와 사용자 메모리 엄격 분리            │
│  • 시스템 호출을 통한 제어된 커널 접근              │
└─────────────────────────────────────────────────────┘

관리 이점:
┌─────────────────────────────────────────────────────┐
│  투명성:                                            │
│  • 프로그래머는 물리 메모리 크기를 신경 쓸 필요 없음│
│  • 메모리 부족 시 자동 스왑 처리                    │
│  • 메모리 단편화 자동 해결                          │
│                                                     │
│  유연성:                                            │
│  • 물리 메모리보다 큰 프로그램 실행 가능            │
│  • 여러 프로그램의 동시 실행 지원                   │
│  • 동적 메모리 할당/해제 자동 관리                  │
└─────────────────────────────────────────────────────┘
```

## 32bit 시스템의 가상 주소 공간

**메모리의 최소 관리 단위는 1byte이고 cpu나 운영체제가 32bit, 64bit에 따라 주소 체계가 달라집니다. 32bit 기준 용량으로 계산했을 때 4GB입니다**.

**이때 기본적으로 32bit 응용 S/W 기준 VMS의 크기를 반으로 나눠서 관리합니다**:

```
📏 32bit 시스템 가상 주소 공간 구조

전체 가상 주소 공간 (4GB = 2^32):
┌─────────────────────────────────────────────────────┐
│  0x00000000                                         │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │         User Mode 영역                      │   │
│  │            (2GB)                            │   │
│  │                                             │   │
│  │  ┌─────────────────────────────────────┐   │   │
│  │  │ OS 사용 영역 (~200MB)              │   │   │
│  │  ├─────────────────────────────────────┤   │   │
│  │  │ 실제 사용자 프로그램 영역           │   │   │
│  │  │ (~1.8GB)                           │   │   │
│  │  └─────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────┘   │
│  0x7FFFFFFF                                         │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │
│  │         Kernel Mode 영역                    │   │
│  │            (2GB)                            │   │
│  │                                             │   │
│  │  • 운영체제 코드                           │   │
│  │  • 시스템 드라이버                         │   │
│  │  • 메모리 관리자                           │   │
│  │  • 하드웨어 추상화 계층                    │   │
│  └─────────────────────────────────────────────┘   │
│  0xFFFFFFFF                                         │
└─────────────────────────────────────────────────────┘

실제 사용 가능 공간:
- 이론적 사용자 공간: 2GB
- OS가 사용하는 부분: ~200MB  
- 실제 프로그램 사용 가능: ~1.8GB
```

## 메모리 관리자와 동적 주소 변환

**가상메모리에서 이 메모리 매니저는 커널쪽에 위치해 있고 이 메모리 매니저가 관리할 수 있는 메모리의 최대 크기가 실제 메모리의 크기입니다(RAM + Swap 영역의 HDD)**. **가상 메모리에서 메모리 매니저는 물리 메모리와 swap 영역을 합쳐서 프로세스가 사용하는 가상 주소공간을 실제 물리 메모리 주소로 변환하는데 이러한 작업을 동적 주소 변환이라고 합니다**.

```
🔄 동적 주소 변환 (Dynamic Address Translation)

메모리 관리자의 역할:
┌─────────────────────────────────────────────────────┐
│  가상 주소 공간 관리:                               │
│  • 프로세스별 독립적인 4GB 가상 주소 공간 제공      │
│  • 가상 주소 → 물리 주소 매핑 테이블 관리          │
│                                                     │
│  물리 메모리 관리:                                  │
│  • RAM (16GB) + 스왑 공간 (32GB) = 총 48GB         │
│  • 페이지 할당/해제 관리                            │
│  • 스왑 인/아웃 결정                                │
│                                                     │
│  주소 변환 과정:                                    │
│  프로세스 A의 가상주소 0x1000                       │
│  → 매핑 테이블 검사                                 │
│  → 물리주소 0x5F2000으로 변환                       │
│  → 실제 메모리 접근                                 │
└─────────────────────────────────────────────────────┘
```

## 하이브리드 메모리 관리 방식

**그래서 가상 메모리 시스템에서 가변분할 방식을 이용한 메모리 관리 기법은 세그멘테이션과 고정분할 방식의 페이지 처리를 적절히 혼용하여 사용합니다**.

```
🔧 페이지드 세그멘테이션 구조

논리적 구조 (세그멘테이션):
┌─────────────────────────────────────────────────────┐
│  프로세스 가상 주소 공간                            │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Code Segment │Data Segment │Stack Segment│       │
│  │   (읽기전용) │  (읽기쓰기)  │  (동적증가)  │       │
│  └─────────────┴─────────────┴─────────────┘       │
└─────────────────────────────────────────────────────┘
              ↓ 각 세그먼트를 페이지로 분할
┌─────────────────────────────────────────────────────┐
│  물리적 구조 (페이징)                               │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐       │
│  │Page │Page │Page │Page │Page │Page │Page │       │
│  │ 0   │ 1   │ 2   │ 3   │ 4   │ 5   │ 6   │       │
│  │4KB  │4KB  │4KB  │4KB  │4KB  │4KB  │4KB  │       │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┘       │
│              ↓ 물리 메모리에 분산 배치               │
│  실제 RAM: [Page2][Page0][Page5][Page1][Page3]...   │
└─────────────────────────────────────────────────────┘
```

## 프로세스별 독립적 가상 주소 공간

**이 프로세스마다 할당된 가상 메모리공간은 항상 그 시작은 0번으로 시작합니다**. **프로세스마다 독립된 메모리 공간을 할당받기 때문에 프로세스마다 할당받은 공간의 주소 30번은 실제 프로세스 1번의 30번과 프로세스 2번의 30번 주소는 실제 물리주소의 위치는 서로 다른 주소를 가리킬 수 있습니다**.

**즉, 프로세스 1,2,3의 같은 주소를 논한다 하여 물리 메모리 상에서도 같은 주소냐 하면 절대 그렇지 않습니다**.

```java
*// 가상 주소 공간 시뮬레이션*
public class VirtualMemoryDemo {
    
    static class Process {
        private String name;
        private Map<Integer, Integer> virtualToPhysical; *// 가상주소 → 물리주소 매핑*
        
        public Process(String name) {
            this.name = name;
            this.virtualToPhysical = new HashMap<>();
        }
        
        public void mapVirtualToPhysical(int virtualAddr, int physicalAddr) {
            virtualToPhysical.put(virtualAddr, physicalAddr);
        }
        
        public void accessMemory(int virtualAddr) {
            Integer physicalAddr = virtualToPhysical.get(virtualAddr);
            if (physicalAddr != null) {
                System.out.printf("%s: 가상주소 0x%04X → 물리주소 0x%04X 접근\n", 
                    name, virtualAddr, physicalAddr);
            } else {
                System.out.printf("%s: 가상주소 0x%04X → 페이지 폴트 발생!\n", 
                    name, virtualAddr);
            }
        }
    }
    
    static class VirtualMemoryManager {
        private Map<String, Process> processes;
        private int nextPhysicalAddr;
        
        public VirtualMemoryManager() {
            this.processes = new HashMap<>();
            this.nextPhysicalAddr = 0x1000; *// 물리 메모리 시작 주소*
        }
        
        public void createProcess(String processName) {
            processes.put(processName, new Process(processName));
            System.out.printf("✅ %s 생성: 가상 주소 0x0000부터 시작\n", processName);
        }
        
        public void allocateMemory(String processName, int virtualAddr, int size) {
            Process process = processes.get(processName);
            if (process != null) {
                *// 가상 주소를 물리 주소에 매핑*
                process.mapVirtualToPhysical(virtualAddr, nextPhysicalAddr);
                System.out.printf("📦 %s: 가상주소 0x%04X → 물리주소 0x%04X 할당 (%d bytes)\n", 
                    processName, virtualAddr, nextPhysicalAddr, size);
                nextPhysicalAddr += size;
            }
        }
        
        public void accessMemory(String processName, int virtualAddr) {
            Process process = processes.get(processName);
            if (process != null) {
                process.accessMemory(virtualAddr);
            }
        }
    }
    
    public static void main(String[] args) {
        VirtualMemoryManager vmm = new VirtualMemoryManager();
        
        System.out.println("🖥️  가상 메모리 시스템 시뮬레이션\n");
        
        *// 3개 프로세스 생성 (모두 가상주소 0x0000부터 시작)*
        vmm.createProcess("프로세스A");
        vmm.createProcess("프로세스B");  
        vmm.createProcess("프로세스C");
        
        System.out.println("\n=== 메모리 할당 ===");
        *// 모든 프로세스가 같은 가상주소 0x0030에 메모리 할당*
        vmm.allocateMemory("프로세스A", 0x0030, 100);
        vmm.allocateMemory("프로세스B", 0x0030, 200);
        vmm.allocateMemory("프로세스C", 0x0030, 150);
        
        System.out.println("\n=== 같은 가상주소 접근 테스트 ===");
        *// 모든 프로세스가 같은 가상주소 0x0030 접근*
        vmm.accessMemory("프로세스A", 0x0030);
        vmm.accessMemory("프로세스B", 0x0030);
        vmm.accessMemory("프로세스C", 0x0030);
        
        System.out.println("\n💡 결과 분석:");
        System.out.println("• 모든 프로세스가 가상주소 0x0030 사용");
        System.out.println("• 하지만 실제로는 서로 다른 물리주소에 매핑됨");
        System.out.println("• 프로세스 간 메모리 격리 보장");
    }
}
```

## 매핑 테이블과 메모리 관리

**그래서 메모리 관리자가 이 매핑 테이블이라는 자료구조를 가지고 있습니다. 이 매핑테이블은 프로세스 A가 어떠한 위치에 있고 그 위치는 몇 번 세그먼트에 있어요 하는 정보를 가지고 있습니다**.

```
📋 매핑 테이블 구조

세그먼트 테이블 예시:
┌─────────────────────────────────────────────────────┐
│  프로세스 | 가상주소 | 물리위치  | 상태              │
│  ───────┼─────────┼─────────┼──────────────       │
│     A    │   0x0000 │ 세그먼트0 │ 메모리 적재        │
│     B    │   0x0000 │ 세그먼트1 │ 메모리 적재        │  
│     C    │   0x0000 │ 세그먼트2 │ 메모리 적재        │
│     D    │   0x0000 │   스왑    │ 디스크 대기        │
└─────────────────────────────────────────────────────┘

페이지 테이블 예시:
┌─────────────────────────────────────────────────────┐
│  프로세스A 페이지 테이블:                           │
│  ┌────────────┬─────────────┬──────────────┐       │
│  │ 가상페이지 │  물리페이지 │    상태      │       │
│  ├────────────┼─────────────┼──────────────┤       │
│  │     0      │      5      │   Present    │       │
│  │     1      │      12     │   Present    │       │
│  │     2      │     Swap    │   Swapped    │       │
│  │     3      │      8      │   Present    │       │
│  └────────────┴─────────────┴──────────────┘       │
└─────────────────────────────────────────────────────┘
```

**매핑 테이블은 세그멘테이션으로 분할된 경우뿐만 아니라 페이징으로 분할된 경우도 똑같은 방식으로 적용됩니다**.

## 메모리 회수와 관리 이점

**이렇게 매핑 테이블을 OS에서 관리하면 좋은 점은 프로세스A가 연산 중에 장애나 특정이유로 죽는다면 매핑테이블에서 이를 제거하고 빈공간으로 만들면 됩니다(메모리 회수). 이러한 부분이 바로 앞에서 언급했던 관리적인 측면에서의 이점입니다**.

```
🔄 자동 메모리 회수 과정

프로세스 종료 전:
┌─────────────────────────────────────────────────────┐
│  매핑 테이블:                                       │
│  프로세스A → 물리주소 0x1000-0x2000 (4KB)          │
│  프로세스B → 물리주소 0x3000-0x4000 (4KB)          │
│  프로세스C → 물리주소 0x5000-0x6000 (4KB)          │
│                                                     │
│  물리 메모리 상태: [A][빈공간][B][빈공간][C]        │
└─────────────────────────────────────────────────────┘

프로세스A 비정상 종료 후:
┌─────────────────────────────────────────────────────┐
│  1. 매핑 테이블에서 프로세스A 엔트리 제거            │
│  2. 해당 물리 메모리 영역을 "빈 공간"으로 표시      │
│  3. 다른 프로세스가 해당 영역 재사용 가능           │
│                                                     │
│  업데이트된 매핑 테이블:                            │
│  프로세스B → 물리주소 0x3000-0x4000 (4KB)          │
│  프로세스C → 물리주소 0x5000-0x6000 (4KB)          │
│                                                     │
│  물리 메모리 상태: [빈공간][빈공간][B][빈공간][C]    │
└─────────────────────────────────────────────────────┘

자동 회수의 장점:
✅ 메모리 누수 방지
✅ 시스템 안정성 향상  
✅ 자원 효율성 극대화
✅ 개발자의 메모리 관리 부담 감소
```

## 현대적 확장: 64bit 시스템

참고로 현재는 대부분 **64bit 시스템**을 사용하므로 주소 공간이 훨씬 큽니다:

```
📈 32bit vs 64bit 가상 주소 공간 비교

32bit 시스템:
- 총 주소 공간: 4GB (2^32)
- 사용자 공간: 2GB (실제 ~1.8GB)
- 커널 공간: 2GB

64bit 시스템:
- 총 주소 공간: 16EB (2^64) - 이론적
- 실제 사용: 256TB (48bit 주소 사용)
- 사용자 공간: 128TB
- 커널 공간: 128TB

현실적 의미:
- 32bit: 메모리 부족 문제 빈번
- 64bit: 실질적으로 무제한 메모리 공간
- 대용량 데이터 처리 가능
- 메모리 관리 정책 변화
```

**가상 메모리 개념**은 현대 컴퓨터 시스템의 **핵심 기반 기술**로, **프로그램의 이식성, 보안성, 효율성**을 동시에 보장하는 중요한 추상화 계층입니다!

## 가상 메모리의 선형 구조

**VMS(32bit) 기준 4GB 배열인 것입니다. 쉽게 말해서 character가 있는 배열인데 여기에 사이즈가 42억9천만... 하는 배열입니다**. **가상 메모리라는 것 자체는 논리적으로 봤을 때 완벽하게 선형 구조입니다**. **그래서 이 배열 안에 우리가 알고 있는 stack, heap 그 외 정적 영역, 코드 등 모든 게 이 배열 안에 속해 있는 것입니다**.

## 페이지와 프레임의 매핑 관계

**가상 메모리는 프로세스마다 독립적으로 존재하며 위에 물리 주소는 실제 RAM을 말합니다**.

**이때 프로세스 1 ~ n 개가 존재했을 때 각 프로세스의 가상주소 100번이 실제 가리키는 물리 주소는 각각 다릅니다**.

```
🔄 페이지-프레임 매핑 구조

프로세스 A의 가상 메모리:           물리 메모리 (실제 RAM):
┌─────────────────────────┐         ┌─────────────────────────┐
│ 페이지 0 (0x0000-0x0FFF)│ ────┐   │ 프레임 0 (비어있음)     │
│ 페이지 1 (0x1000-0x1FFF)│ ──┐ │   │ 프레임 1 (프로세스 B)   │
│ 페이지 2 (0x2000-0x2FFF)│ ┐ │ └──►│ 프레임 2 (프로세스 A)   │
│ 페이지 3 (0x3000-0x3FFF)│ │ └────►│ 프레임 3 (프로세스 A)   │
│ 페이지 4 (0x4000-0x4FFF)│ └──────►│ 프레임 4 (프로세스 A)   │
│ 페이지 5 (0x5000-0x5FFF)│ INVALID │ 프레임 5 (프로세스 C)   │
└─────────────────────────┘         └─────────────────────────┘

페이지 테이블 (프로세스 A):
┌──────────┬────────────┬──────────┐
│ 페이지 # │ 프레임 #   │ 상태     │
├──────────┼────────────┼──────────┤
│    0     │     2      │ Present  │
│    1     │     3      │ Present  │  
│    2     │     4      │ Present  │
│    3     │     1      │ Present  │
│    4     │  Invalid   │ Swapped  │
│    5     │  Invalid   │ Not Used │
└──────────┴────────────┴──────────┘

특징:
- 가상 페이지 순서 ≠ 물리 프레임 순서
- 여러 프로세스가 같은 물리 메모리 공유 가능
- Invalid 페이지는 디스크에 저장되거나 미사용
```

## 페이지 단위화의 중요성

**페이지란 뭘까? 라고 한다면 32bit 체제에서는 0부터 시작해서 0xFFFFFFFF만큼의 주소를 가질 것입니다**.

**윈도우 운영체제 기준 페이지라 하면 기본적으로 4KB 단위로 끊어서 처리합니다**. **이때 물리 주소에서 프레임이든 세그먼트든 어떤 특정한 단위로 메모리를 끊어서 관리하는 것인데 특별한 경우가 없던 페이지의 사이즈와 프레임의 사이즈 크기를 맞춰서 관리합니다**. **즉 프레임 또한 동일하게 4KB 크기를 가진다는 것입니다**.

### **왜 단위화해서 관리하는 것이 중요한가?**

```
🧩 페이지 단위화의 핵심 이유

1️⃣ 메모리 관리 효율성:
┌─────────────────────────────────────────────────────┐
│  단위화 없이 관리한다면:                            │
│  • 1바이트씩 개별 관리 → 4GB = 40억 개 엔트리       │
│  • 메모리 테이블 크기: 40억 × 8바이트 = 32GB        │
│  • 메모리보다 관리 구조가 더 큼!                    │
│                                                     │
│  4KB 페이지로 관리한다면:                           │
│  • 4GB ÷ 4KB = 100만 개 페이지                      │
│  • 페이지 테이블 크기: 100만 × 8바이트 = 8MB        │
│  • 관리 가능한 크기로 축소!                         │
└─────────────────────────────────────────────────────┘

2️⃣ 하드웨어 최적화:
┌─────────────────────────────────────────────────────┐
│  • CPU 캐시 라인과 맞춤 (보통 64바이트 단위)        │
│  • 메모리 접근 패턴 최적화 (지역성 활용)            │
│  • MMU(Memory Management Unit) 하드웨어 지원        │
│  • TLB(Translation Lookaside Buffer) 효율성         │
└─────────────────────────────────────────────────────┘

3️⃣ 외부 단편화 해결:
┌─────────────────────────────────────────────────────┐
│  가변 크기 할당의 문제:                             │
│  [프로세스A 200KB][빈공간 50KB][프로세스B 300KB]   │
│  → 새로운 100KB 프로세스 할당 불가                  │
│                                                     │
│  고정 페이지 크기 할당:                             │
│  [페이지][페이지][빈페이지][페이지][페이지]         │
│  → 빈 페이지에 언제든 새 프로세스 할당 가능         │
└─────────────────────────────────────────────────────┘

4️⃣ 스왑 효율성:
┌─────────────────────────────────────────────────────┐
│  • 디스크와 메모리 간 이동이 페이지 단위로 일어남   │
│  • 4KB는 디스크 섹터 크기와 잘 맞음                 │
│  • 부분적 스왑 가능 (프로세스 전체가 아닌)          │
│  • 지역성 원리에 의해 필요한 부분만 로드            │
└─────────────────────────────────────────────────────┘
```

## 아파트 단지 비유

**예를 들어 VMS가 아파트 단지라고 했을 때 페이지는 몇동 몇호고 생각하면 됩니다**. **그래서 처음 시작점인 0번 주소(절대적인 기준)를 기준으로 얼마만큼 떨어졌는지 상대적인 위치를 말하게 됩니다**.

**그래서 이 절대적인 기준을 기점으로 상대적인 위치를 영어로 offset 또는 distance라고 부릅니다**.

```
🏢 아파트 단지 비유로 이해하는 페이징

가상 메모리 = 거대한 아파트 단지 (4GB)
┌─────────────────────────────────────────────────────┐
│  아파트 단지 "가상 메모리 타워"                     │
│                                                     │
│  📍 101동 (페이지 0): 0x0000 ~ 0x0FFF              │
│     • 101호: 0x0000 (distance = 0)                 │
│     • 102호: 0x0001 (distance = 1)                 │
│     • ...                                           │
│     • 1024호: 0x0FFF (distance = 4095)             │
│                                                     │
│  📍 102동 (페이지 1): 0x1000 ~ 0x1FFF              │  
│     • 101호: 0x1000 (distance = 0)                 │
│     • 102호: 0x1001 (distance = 1)                 │
│     • ...                                           │
│                                                     │
│  📍 103동 (페이지 2): 0x2000 ~ 0x2FFF              │
│  ...                                                │
└─────────────────────────────────────────────────────┘

주소 계산 예시:
- 가상주소 0x1234를 찾으려면?
- 페이지 번호 = 0x1234 ÷ 0x1000 = 1 (102동)
- 오프셋 = 0x1234 % 0x1000 = 0x234 (564호)
- 결과: "102동 564호를 찾아가세요!"
```

## 정형화된 주소 구조

**페이징 기법의 정형화된 주소: 가상 주소는 VA= <P,D>입니다**

- **VA는 Virtual Address**
- **P는 페이지 번호, D는 Distance입니다**

**페이지 번호를 가지고 페이지를 찾은 다음에 그 페이지를 기준으로 얼마만큼 떨어져 있다라는 의미입니다**.

**실제 가상메모리 주소를 가지고 페이지 테이블과 연결 실제 물리적인 주소 프레임을 찾아서 프레임을 기준으로 한다면 PA = <F,D>**

- **PA는 물리적 주소**
- **F는 프레임, D는 Distance입니다**

```
🔢 주소 변환 과정 (Address Translation)

32bit 시스템에서 4KB 페이지 기준:
┌─────────────────────────────────────────────────────┐
│  가상 주소 (32bit):                                 │
│  ┌──────────────────┬──────────────────────────────┐ │
│  │  페이지 번호 (P) │     오프셋 (D)              │ │
│  │     20 bit       │      12 bit                  │ │
│  └──────────────────┴──────────────────────────────┘ │
│        │                      │                      │
│        │                      └─────────────────┐    │
│        ▼                                        │    │
│  ┌──────────────┐                               │    │  
│  │ 페이지 테이블 │                               │    │
│  │    검색      │                               │    │
│  └──────────────┘                               │    │
│        │                                        │    │
│        ▼                                        │    │
│  ┌──────────────────────────────────────────────┼────┤ │
│  │  프레임 번호 (F) │     오프셋 (D)            │    │ │
│  │     20 bit       │      12 bit (동일)        │    │ │
│  └──────────────────┴──────────────────────────────┘ │
│                                                     │
│  물리 주소 (32bit)                                  │
└─────────────────────────────────────────────────────┘

주소 변환 예시:
가상주소 0x12345678 변환:
- 페이지 번호: 0x12345678 >> 12 = 0x12345
- 오프셋: 0x12345678 & 0xFFF = 0x678
- 페이지 테이블에서 페이지 0x12345 → 프레임 0xABCDE 매핑
- 물리주소: (0xABCDE << 12) | 0x678 = 0xABCDE678
```

```java
// 주소 변환 시뮬레이션
public class AddressTranslation {
    private static final int PAGE_SIZE = 4096; // 4KB
    private static final int OFFSET_BITS = 12;  // 4KB = 2^12
    private static final int OFFSET_MASK = 0xFFF; // 12bit 마스크
    
    static class PageTable {
        private Map<Integer, Integer> pageToFrame; // 페이지 → 프레임 매핑
        private Map<Integer, Boolean> validity;    // 페이지 유효성
        
        public PageTable() {
            this.pageToFrame = new HashMap<>();
            this.validity = new HashMap<>();
        }
        
        public void mapPage(int pageNumber, int frameNumber) {
            pageToFrame.put(pageNumber, frameNumber);
            validity.put(pageNumber, true);
        }
        
        public void invalidatePage(int pageNumber) {
            validity.put(pageNumber, false);
        }
        
        public int translateAddress(int virtualAddress) {
            // VA = <P, D> 분해
            int pageNumber = virtualAddress >>> OFFSET_BITS;  // 상위 20bit
            int offset = virtualAddress & OFFSET_MASK;        // 하위 12bit
            
            System.out.printf("🔍 가상주소 0x%08X 분석:\n", virtualAddress);
            System.out.printf("   페이지 번호(P): 0x%05X\n", pageNumber);
            System.out.printf("   오프셋(D): 0x%03X (%d bytes)\n", offset, offset);
            
            // 페이지 유효성 검사
            if (!validity.getOrDefault(pageNumber, false)) {
                System.out.println("   ❌ 페이지 폴트 발생! (Invalid Page)");
                return -1; // 페이지 폴트
            }
            
            // 프레임 번호 조회
            Integer frameNumber = pageToFrame.get(pageNumber);
            if (frameNumber == null) {
                System.out.println("   ❌ 페이지 폴트 발생! (Page Not Found)");
                return -1; // 페이지 폴트
            }
            
            // PA = <F, D> 조합
            int physicalAddress = (frameNumber << OFFSET_BITS) | offset;
            
            System.out.printf("   프레임 번호(F): 0x%05X\n", frameNumber);
            System.out.printf("   ✅ 물리주소: 0x%08X\n", physicalAddress);
            
            return physicalAddress;
        }
    }
    
    public static void main(String[] args) {
        PageTable pageTable = new PageTable();
        
        System.out.println("📋 페이지 테이블 설정:");
        pageTable.mapPage(0x12345, 0xABCDE);  // 페이지 → 프레임 매핑
        pageTable.mapPage(0x67890, 0x11111);
        pageTable.mapPage(0xAAAAA, 0x22222);
        pageTable.invalidatePage(0xBBBBB);     // Invalid 페이지
        
        System.out.println("\n🔄 주소 변환 테스트:");
        
        // 정상 변환
        pageTable.translateAddress(0x12345678);
        System.out.println();
        
        // 다른 페이지
        pageTable.translateAddress(0x67890ABC);
        System.out.println();
        
        // Invalid 페이지 접근
        pageTable.translateAddress(0xBBBBB123);
        System.out.println();
        
        // 존재하지 않는 페이지
        pageTable.translateAddress(0xCCCCC456);
    }
}
```

```
Invalid 페이지 처리
그리고 실제 페이지를 찾았는데 위에처럼 invalid일 때에 대한 설명이 필요합니다.
⚠️ Invalid 페이지 상황과 처리

Invalid 페이지가 발생하는 경우들:
┌─────────────────────────────────────────────────────┐
│  1️⃣ 스왑 아웃된 페이지:                             │
│     • 메모리 부족으로 디스크로 이동됨               │
│     • 필요 시 다시 메모리로 로드 (스왑 인)          │
│                                                     │
│  2️⃣ 아직 할당되지 않은 페이지:                      │
│     • 프로세스가 아직 접근하지 않은 영역            │
│     • 필요 시 새로운 물리 메모리 할당               │
│                                                     │
│  3️⃣ 권한 위반:                                     │
│     • 읽기 전용 페이지에 쓰기 시도                  │
│     • 실행 불가 페이지에서 코드 실행 시도           │
│                                                     │
│  4️⃣ 해제된 페이지:                                 │
│     • free()나 delete로 해제된 메모리 영역          │
│     • 접근 시 세그멘테이션 폴트 발생                │
└─────────────────────────────────────────────────────┘

페이지 폴트 처리 과정:
┌─────────────────────────────────────────────────────┐
│  1. CPU가 Invalid 페이지 접근 감지                  │
│  2. 하드웨어 인터럽트 발생 (페이지 폴트)            │
│  3. 운영체제 페이지 폴트 핸들러 실행                │
│  4. 원인 분석:                                      │
│     → 스왑된 페이지면 디스크에서 로드               │
│     → 미할당 페이지면 새 메모리 할당                │
│     → 권한 위반이면 프로세스 종료                   │
│  5. 페이지 테이블 업데이트                          │
│  6. 프로세스 실행 재개                              │
└─────────────────────────────────────────────────────┘
```

**페이징 기법**은 현대 가상 메모리 시스템의 **핵심 메커니즘**으로, **효율적인 메모리 관리와 프로세스 보호**를 동시에 제공하는 중요한 기술입니다! 특히 **VA=<P,D>, PA=<F,D>의 정형화된 구조**는 하드웨어 MMU가 빠른 주소 변환을 수행할 수 있게 하는 핵심 원리입니다.