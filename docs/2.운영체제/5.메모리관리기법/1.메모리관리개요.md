## 메모리 관리 기법

### 메모리 관리 개요

**메모리는 특정한 공간에 일련번호를 부여하여 관리하는데 이때 메모리의 일련번호를 주소라고 합니다**.

```
🗄️ 메모리의 구조 (개인 락커룸과 유사)

메모리 주소 체계:
┌─────────────────────────────────────────────────────┐
│  주소 0x00000000: [1 Byte]                         │
│  주소 0x00000001: [1 Byte]                         │  
│  주소 0x00000002: [1 Byte]                         │
│  주소 0x00000003: [1 Byte]                         │
│       ...                                           │
│  주소 0xFFFFFFFF: [1 Byte]                         │
└─────────────────────────────────────────────────────┘

특징:
- 각 주소는 정확히 1 Byte (8 bit) 크기
- 순차적인 일련번호로 관리
- 개인 락커룸처럼 고유한 번호 보유
```

**마치 우리가 개인 락커룸처럼 일련번호가 부여된 이 공간 하나의 크기는 1 byte입니다**. **그래서 이 주소를 32bit 숫자로 표현 가능하면 이를 32bit 시스템이라고 합니다**. **이 숫자가 64bit면 64bit 시스템이라고 합니다**.

### 컴퓨터의 용량과 단위

| 단위 | 크기 | 특징 |
| --- | --- | --- |
| 1 Bit | 전기 스위치 1개 | 용량이 아니라 표현의 최소 수준 |
| 1 Byte | 8비트 한 묶음 | 영문자 한 글자를 저장할 수 있는 기억공간의 최소 단위. 컴퓨터는 기억 공간을 관리할 때 1 바이트 단위로 관리한다. |
| 1 KB | 1024 byte | JPEG 사진 파일 하나가 몇백 KB 정도 된다. |
| 1MB | 1024 KB | MP3 파일 하나가 4~5 MB 정도 한다. |
| 1 GB | 1024 MB | mp4, .avi 파일 하나가 대략 2~3GB 정도 크기다 |
| 1 TB | 1024 GB | 하드디스크 용량이 대략 1~2TB 정도이다. |
| 1 PB(페타 바이트) | 1024 테라 바이트 | 네이버 IDC 센터 각의 규모가 900PB 정도 |
| 1 EB(엑사 바이트) | 1024 페타바이트 | 64 비트를 용량으로 계산하면 16EB |
| 1 ZB(제타 바이트) | 1024 엑사 바이트 | 2017년 기준 전 세계 데이터 센터 트래픽이 약 7.7 제타 바이트이다 |
| 1 YB(요타 바이트) | 1024 제타바이트 | 현재 상상하기 힘든 용량 |

### 64bit 플랫폼과 실제 메모리 한계

**우리가 CPU 64bit + OS 64bit를 사용하면 이를 64bit platform이라고 합니다**. **그러면 64비트를 용량으로 계산하면 16EB인데 실제 엑사바이트 크기의 메모리를 사용하면 운영체제에서 인식이 가능한가? 그렇지는 않습니다**.

```
💻 OS별 실제 메모리 인식 한계

이론적 64bit 주소 공간: 2^64 = 16 EB

실제 OS 제약사항:
┌─────────────────────────────────────────────────────┐
│  Windows 10 Home                                    │
│  • 32bit: 최대 4GB                                 │
│  • 64bit: 최대 128GB                               │
│                                                     │
│  Windows 10 Pro                                    │
│  • 64bit: 최대 2TB                                 │
│                                                     │
│  Linux (x86_64)                                    │
│  • 이론적: 256TB (48bit 가상 주소)                 │
│  • 실제: 하드웨어와 커널 설정에 따라 제한           │
│                                                     │
│  macOS                                              │
│  • 64bit: 최대 수백 TB (버전에 따라 다름)          │
└─────────────────────────────────────────────────────┘

현실적 제약 요인:
🔧 하드웨어 제약: 메모리 컨트롤러, 마더보드 슬롯 수
💰 경제적 제약: 메모리 가격, 시스템 비용
⚡ 성능 제약: 메모리 대역폭, 레이턴시
```

**운영 체제별 인식할 수 있는 메모리 크기가 정해져 있습니다**. **예를 들면 Windows 10 Home의 경우 32비트면 4GB, 64비트면 128GB까지 인식할 수 있습니다**.

### CPU와 메모리의 상호작용

**연산의 주체인 CPU가 연산을 합니다**. **이때 이 처리 속도는 매우 빠릅니다**. **CPU도 메모리에서 연산할 데이터를 가져다가 연산을 하게 되는데 이때 어느 누군가는 계속 연산할 데이터를 추가해 줘야 합니다**.

```
⚡ CPU와 메모리 간의 데이터 흐름

CPU (3GHz = 초당 30억 번 연산)
 ↕ 데이터 요청/응답
RAM (접근 시간: 50-100ns)
 ↕ 데이터 로딩
Storage (SSD: 0.1ms, HDD: 10ms)

문제점:
┌─────────────────────────────────────────────────────┐
│  CPU 처리량 > 메모리 공급량                         │
│  → CPU가 놀고 있음 (자원 낭비)                      │
│                                                     │
│  CPU 처리량 < 메모리 공급량                         │
│  → 메모리 부족, 처리 지연                           │
└─────────────────────────────────────────────────────┘
```

**만약 CPU가 처리하는 양보다 남아있는 연산의 양이 많다면 연산을 처리하는 속도가 더디다는 의미이고 추가되는 양이 항상 비어있으면 자원을 낭비하고 있는 것이 됩니다**. **그래서 CPU 자원을 낭비하지 않기 위해 캐시 메모리, CPU의 예측 처리 등을 합니다**.

### 프로그램 실행과 기계어 변환

**CPU가 실행하기 위해서는 CPU가 이해할 수 있는 기계어를 읽어서 연산을 합니다**. **그러면 일반적으로 우리가 말하는 소프트웨어 프로그램 예를 들면 C, Python, Java 등으로 만들어진 소프트웨어도 CPU가 이해할 수 있는 기계어로 변환해야만 실행으로 이어집니다**. **그래서 빠른 실행을 하기 위해서 RAM이라는 기억공간에 미리 올려두고 실행을 하게 됩니다**.

### 인터프리터 vs 컴파일러

**프로그래밍 언어를 기계어로 변환하는 방식**에는 두 가지가 있습니다:

```
🔧 컴파일러 방식 (C, C++, Rust 등)

소스코드 (.c) → 컴파일러 → 기계어 (.exe) → 실행
┌─────────────┐    ┌─────────┐    ┌─────────┐
│ int main()  │    │  gcc    │    │01001010 │
│ {           │ →  │         │ →  │10110101 │
│   return 0; │    │         │    │11010011 │
│ }           │    └─────────┘    └─────────┘
└─────────────┘

특징:
✅ 실행 속도 매우 빠름
✅ 배포 시 소스코드 노출 안됨
❌ 컴파일 시간 소요
❌ 플랫폼별 별도 컴파일 필요

🔧 인터프리터 방식 (Python, JavaScript, Ruby 등)

소스코드 → 인터프리터 → 실시간 실행
┌─────────────┐    ┌─────────┐
│ print("Hi") │    │ Python  │
│ x = 10      │ →  │ 인터프리터│ → 즉시 실행
│ print(x)    │    │         │
└─────────────┘    └─────────┘

특징:
✅ 개발/테스트 빠름
✅ 플랫폼 독립적
❌ 실행 속도 상대적으로 느림
❌ 소스코드 노출됨

🔧 하이브리드 방식 (Java, C# 등)

소스코드 → 중간 코드 → 가상머신 → 실행
┌─────────────┐    ┌─────────┐    ┌─────────┐
│ Java 코드   │    │ Bytecode│    │   JVM   │
│ (.java)     │ →  │ (.class)│ →  │         │ → 실행
│             │    │         │    │         │
└─────────────┘    └─────────┘    └─────────┘

특징:
✅ 플랫폼 독립적
✅ 최적화 가능 (JIT 컴파일)
❌ 가상머신 필요
❌ 메모리 사용량 증가
```

### 메모리 관리자의 역할

**그래서 이러한 작업을 처리하는 메모리 관리자가 있습니다**. **주 업무는 가져오기, 배치하기, 재배치하기입니다**.

```
🧠 메모리 관리자 (Memory Manager)

주요 기능:
┌─────────────────────────────────────────────────────┐
│  1️⃣ 가져오기 (Fetch)                               │
│     • 디스크에서 RAM으로 프로그램 로딩              │
│     • 필요한 데이터를 적절한 시점에 메모리로 이동   │
│                                                     │
│  2️⃣ 배치하기 (Placement)                          │
│     • RAM의 어느 위치에 프로그램을 올릴지 결정      │
│     • 메모리 단편화 최소화                          │
│     • 효율적인 공간 활용                            │
│                                                     │
│  3️⃣ 재배치하기 (Replacement)                       │
│     • 메모리 부족 시 어떤 프로그램을 제거할지 결정  │
│     • 스왑(Swap) 메커니즘 관리                      │
│     • LRU, FIFO 등의 교체 알고리즘 적용            │
└─────────────────────────────────────────────────────┘
```

**이 중 가장 중요한 역할은 배치 정책입니다**.

### 메모리 배치 정책의 중요성

**RAM이라는 공간은 매우 한정적인 자원입니다**. **이 한정된 자원에서 동작을 원하는 여러 프로세스들이 존재하고 당연히 이는 속도 때문입니다**. **하지만 해당 자원은 한정적이기 때문에 모든 프로세스들이 사용하기 위해서는 RAM 공간을 적절하게 배치하는 작업을 하게 됩니다**. **만약 RAM이 가득 차게 되고 이를 사용하고자 하는 프로세스가 있다면 이때 재배치 작업을 하게 됩니다**.

```
🏢 RAM 공간 배치 문제

현실적 상황:
┌─────────────────────────────────────────────────────┐
│  사용 가능한 RAM: 16GB                              │
│  실행하려는 프로세스들:                             │
│  • Chrome: 2GB                                     │
│  • VS Code: 1GB                                    │
│  • Photoshop: 4GB                                  │
│  • 게임: 8GB                                       │
│  • 기타 시스템: 3GB                                │
│  ────────────────────────                          │
│  총 필요량: 18GB > 16GB (부족!)                     │
└─────────────────────────────────────────────────────┘

해결 방법:
1. 가상 메모리 사용 (스왑)
2. 메모리 압축
3. 프로세스 우선순위 조정
4. 메모리 효율적 배치
```

### 페이징과 세그멘테이션

**그래서 배치 정책은 가져온 프로세스를 어떤 위치에 올려놓을지 정하는 정책이고 메모리를 같은 크기로 자르는 것을 page(페이지)라고 합니다**. **또한 프로세스의 크기에 맞게 자르는 것을 segmentation(세그멘테이션)이라고 합니다**.

```
📄 페이징 (Paging) - 고정 크기 분할

RAM을 동일한 크기의 페이지로 분할:
┌─────────────────────────────────────────────────────┐
│  RAM (16GB)                                         │
│  ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐ │
│  │ 4KB │ 4KB │ 4KB │ 4KB │ 4KB │ 4KB │ 4KB │ 4KB │ │
│  │Page0│Page1│Page2│Page3│Page4│Page5│Page6│Page7│ │
│  └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘ │
└─────────────────────────────────────────────────────┘

프로세스 배치:
┌─────────────────────────────────────────────────────┐
│  프로세스 A (10KB) → Page0, Page1, Page2에 배치     │
│  프로세스 B (6KB)  → Page3, Page4에 배치           │
│  프로세스 C (15KB) → Page5, Page6, Page7에 배치     │
└─────────────────────────────────────────────────────┘

장점:
✅ 관리 단순함
✅ 외부 단편화 없음
✅ 하드웨어 지원 우수

단점:
❌ 내부 단편화 발생 (페이지 내 빈 공간)
❌ 고정 크기로 인한 비효율

🧩 세그멘테이션 (Segmentation) - 가변 크기 분할

RAM을 프로세스 크기에 맞게 가변 분할:
┌─────────────────────────────────────────────────────┐
│  RAM (16GB)                                         │
│  ┌─────────┬──────┬────────────┬──────────────────┐ │
│  │Process A│ 빈공간│ Process B  │    Process C     │ │
│  │  (10KB) │(2KB) │   (6KB)    │      (15KB)      │ │
│  └─────────┴──────┴────────────┴──────────────────┘ │
└─────────────────────────────────────────────────────┘

장점:
✅ 내부 단편화 없음
✅ 논리적 단위로 관리
✅ 보안 및 보호 용이

단점:
❌ 외부 단편화 발생 (빈 공간 조각화)
❌ 관리 복잡함
❌ 압축(Compaction) 필요
```

### 현대적 메모리 관리

현대 운영체제는 **페이징과 세그멘테이션을 결합한 방식**을 사용합니다:

```
🔄 페이지드 세그멘테이션 (Paged Segmentation)

논리적 주소: 세그먼트 + 페이지 + 오프셋
┌─────────────────────────────────────────────────────┐
│  프로세스                                           │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Code Segment │Data Segment │Stack Segment│       │
│  └─────────────┴─────────────┴─────────────┘       │
│         ↓             ↓             ↓               │
│  ┌─────────────┬─────────────┬─────────────┐       │
│  │Page│Page│..│Page│Page│..│Page│Page│..  │       │
│  └─────────────┴─────────────┴─────────────┘       │
└─────────────────────────────────────────────────────┘

물리적 메모리에 페이지 단위로 배치
↓
RAM의 임의 위치에 흩어져서 저장 가능

장점:
✅ 두 방식의 장점 결합
✅ 유연한 메모리 관리
✅ 효율적인 공간 활용
```

이러한 **복합적인 메모리 관리 기법**을 통해 현대 운영체제는 **제한된 물리 메모리를 효율적으로 활용**하면서 **다수의 프로세스가 안정적으로 동시 실행**될 수 있도록 지원합니다.