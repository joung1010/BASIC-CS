## 🏗️ 운영체제 계층 구조와 동작 원리

### 1. 전체 아키텍처 Overview

```
┌─────────────────────────────────────┐
│         APPLICATION LAYER           │  ← User Process 영역
│    ┌─────────┐ ┌─────────┐         │
│    │ Chrome  │ │ VS Code │ ...     │
│    └─────────┘ └─────────┘         │
├─────────────────────────────────────┤
│          SYSTEM API LAYER           │  ← 시스템 API 계층
│  printf() malloc() fopen() socket() │
├═════════════════════════════════════┤  ← USER MODE / KERNEL MODE 경계
│        FILE INTERFACE LAYER         │  ← 파일 추상화 계층
│  stdout, stdin, /dev/tty, /dev/sda  │
├─────────────────────────────────────┤
│             KERNEL CORE             │  ← 커널 핵심 구성요소
│   Process Scheduler │ Memory Mgr    │
│   File System      │ Network Stack │
├─────────────────────────────────────┤
│          DEVICE DRIVER              │  ← 하드웨어 추상화 계층
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐   │
│  │Video│ │Audio│ │Disk │ │Net  │   │
│  └─────┘ └─────┘ └─────┘ └─────┘   │
├─────────────────────────────────────┤
│            HARDWARE                 │  ← 물리적 하드웨어
│  ┌─────┐ ┌─────┐ ┌─────────────┐   │
│  │ CPU │ │ RAM │ │  I/O Devices│   │
│  └─────┘ └─────┘ └─────────────┘   │
└─────────────────────────────────────┘

```

### 2. 핵심 개념 정의

### 🔧 하드웨어 vs 소프트웨어 구분

**Physical Hardware (물리적 하드웨어)**

- **CPU**: 실제 연산을 수행하는 프로세서 칩
- **RAM**: 데이터를 임시 저장하는 물리적 메모리 모듈
- **Storage**: SSD/HDD 등 영구 저장 장치
- **I/O Devices**: 키보드, 마우스, 그래픽카드, 네트워크카드 등

**Virtual/Logical Resources (가상화된 자원)**

- **가상 메모리**: 8GB 물리 RAM으로 40GB+ 논리 메모리 공간 제공
- **가상 CPU**: 멀티태스킹으로 하나의 CPU가 여러 프로세스를 동시 실행하는 것처럼 보임
- **파일 시스템**: 블록 단위 저장장치를 파일/디렉토리 구조로 추상화

### 🎯 운영체제의 이중 역할

**상향 역할 (Application Support)**

- 응용 프로그램들이 안정적으로 실행될 수 있는 환경 제공
- 프로세스 스케줄링, 메모리 관리, 리소스 할당
- 다양한 시스템 API를 통한 서비스 제공

**하향 역할 (Hardware Management)**

- 디바이스 드라이버를 통한 하드웨어 제어
- 하드웨어 자원의 효율적 분배 및 보호
- 인터럽트 처리 및 I/O 관리

## ⚡ Interrupt 시스템의 이해

### 1. Interrupt 기본 개념

**일상생활 비유**

```
상황: 집에서 중요한 업무 처리 중
이벤트: 택배 벨이 울림
처리: 업무 중단 → 택배 수령 → 업무 재개

```

**컴퓨터에서의 Interrupt**

```
CPU 상태: 프로그램 A 실행 중
이벤트: 키보드 입력 발생
처리: A 실행 중단 → 키보드 입력 처리 → A 실행 재개

```

### 2. IRQ (Interrupt Request) 번호 시스템

```
IRQ 0  : System Timer (최고 우선순위)
IRQ 1  : Keyboard Controller
IRQ 2  : Cascade (다른 IRQ 연결용)
IRQ 3  : Serial Port 2 (COM2)
IRQ 4  : Serial Port 1 (COM1)
IRQ 6  : Floppy Disk Controller
IRQ 8  : Real-time Clock
IRQ 12 : PS/2 Mouse
IRQ 14 : Primary IDE Controller (HDD)
IRQ 16 : Graphics Card

```

## 📝 "Hello World" 출력 과정 상세 분석

### 단계별 실행 과정

```c
// 1단계: 애플리케이션에서 API 호출
printf("Hello World");

```

**2단계: 라이브러리 함수 내부 처리**

```c
// printf() 내부에서 실제로 실행되는 코드
int result = write(STDOUT_FILENO, "Hello World", 11);
//             ↑ 파일 디스크립터 1 (표준 출력)

```

**3단계: 시스템 콜 진입점**

- User Mode → Kernel Mode 권한 전환
- CPU는 특별한 명령어(int 0x80, syscall 등)로 커널 진입
- 보안: 일반 프로그램이 하드웨어에 직접 접근하는 것을 차단

**4단계: 커널 내부 처리**

```c
// 커널 내부 sys_write() 함수 실행
sys_write(int fd, const char *buf, size_t count) {
    struct file *file = get_file(fd);  // fd=1 → stdout 파일 구조체
    return file->f_op->write(file, buf, count);  // 해당 디바이스 드라이버 호출
}

```

**5단계: 디바이스 드라이버 호출**

- VFS(Virtual File System)가 stdout을 실제 터미널/콘솔 디바이스와 매핑
- 적절한 비디오 드라이버 선택 및 호출

**6단계: 하드웨어 제어**

```
Driver → CPU: IRQ 16번 요청 (Graphics Card)
CPU: 현재 실행중인 프로세스 Context 저장
CPU → Graphics Card: 문자 렌더링 명령 전송
Graphics Card: 메모리 버퍼에 픽셀 데이터 작성
Monitor: 화면에 "Hello World" 표시

```

**7단계: 완료 처리**

```
Graphics Card → CPU: 작업 완료 IRQ 발생
CPU: 원래 프로세스 Context 복원
Kernel → User: write() 시스템 콜 반환값 (11)
Library: printf() 함수 정상 종료

```

### 3. Blocking vs Non-Blocking 처리

**Blocking (동기식) 처리**

```c
printf("Step 1");  // 완료까지 대기
printf("Step 2");  // Step 1 완료 후 실행
printf("Step 3");  // Step 2 완료 후 실행

```

**Non-Blocking (비동기식) 처리**

```c
async_printf("Step 1");  // 즉시 반환
async_printf("Step 2");  // 병렬 실행 가능
async_printf("Step 3");  // 순서 보장 안됨
// 나중에 완료 콜백으로 결과 확인

```

## 🔗 핵심 용어 및 개념 정리

### 1. API (Application Programming Interface)

**정의**: 응용 프로그램이 운영체제 기능을 사용하기 위한 함수 인터페이스

**주요 카테고리**

```c
// 파일 I/O
FILE *fp = fopen("data.txt", "r");
fread(buffer, 1, 100, fp);
fclose(fp);

// 메모리 관리
void *ptr = malloc(1024);
free(ptr);

// 프로세스 제어
pid_t pid = fork();
wait(&status);

// 네트워크
int sock = socket(AF_INET, SOCK_STREAM, 0);
connect(sock, &addr, sizeof(addr));

```

### 2. 파일 인터페이스 (Everything is a File)

**Unix 철학**: 모든 것을 파일로 추상화하여 일관된 인터페이스 제공

```bash
# 일반 파일
echo "data" > /tmp/test.txt

# 디바이스 파일
echo "Hello" > /dev/tty1        # 터미널1에 출력
cat < /dev/random               # 랜덤 데이터 읽기

# 네트워크 (일부 시스템)
echo "GET /" > /dev/tcp/google.com/80

# 프로세스 정보
cat /proc/1/status              # PID 1 프로세스 상태

```

### 3. System Call (시스템 호출)

**보안 메커니즘**: User Mode와 Kernel Mode 사이의 안전한 경계

```c
// 직접 시스템 콜 (보통은 라이브러리가 래핑)
#include <sys/syscall.h>
#include <unistd.h>

// write() 시스템 콜을 직접 호출
long result = syscall(SYS_write, 1, "Hello", 5);

```

**권한 레벨**:

- **Ring 0 (Kernel Mode)**: 모든 하드웨어 접근 가능
- **Ring 3 (User Mode)**: 제한된 명령어만 실행 가능

### 4. Context Switching (문맥 교환)

**CPU 상태 보존/복원 과정**

```
Process A 실행중:
├─ 레지스터 상태: EAX=100, EBX=200, PC=0x1000
├─ 인터럽트 발생!
├─ A의 상태를 PCB(Process Control Block)에 저장
├─ Interrupt Handler 실행
├─ A의 상태를 PCB에서 복원
└─ A 실행 재개: EAX=100, EBX=200, PC=0x1000

```

## 📚 핵심 요약

**운영체제의 3대 핵심 가치**:

1. **추상화**: 복잡한 하드웨어 → 간단한 API
2. **가상화**: 제한된 물리 자원 → 논리적 무한 자원
3. **보호**: 프로세스 격리 → 시스템 안정성

**"Hello World" 한 줄이 실행되는 동안**:

- 최소 2번의 모드 전환 (User ↔ Kernel)
- 여러 계층의 추상화 통과
- 하드웨어 인터럽트 처리
- 컨텍스트 스위칭

