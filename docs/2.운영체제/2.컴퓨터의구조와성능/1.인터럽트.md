## 인터럽트란?

사전적 의미는 끼어들다, 중단시키다 의미를 가진 말로 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행 중인 작업으로 복귀하는 것을 말한다.

### 인터럽트의 종류

외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트

### 외부 인터럽트 (Hardware Interrupt)

- **전원 이상 인터럽트(Power fail interrupt)**: 정전, 파워 이상 - NMI(Non-Maskable Interrupt) 사용, 가장 높은 우선순위
- **기계 착오 인터럽트(Machine check interrupt)**: CPU가 기능적인 오류 감지 시 발생
- **외부 신호 인터럽트(External interrupt)**
    - **타이머 인터럽트(IRQ 0)**: 스케줄링의 핵심, 보통 1ms마다 발생하여 프로세스 전환 시점 결정
    - **키보드 인터럽트(IRQ 1)**: 키를 누른 경우, 대표적인 Control + Alt + Delete
    - **외부 장치 인터럽트**: 네트워크 카드, USB 장치 등에서 발생하는 신호
- **입출력 인터럽트(I/O interrupt)**
    - 입출력 장치가 데이터 **전송을 요구**하거나 **전송이 끝**나 다음 동작이 수행되어야 하는 경우
    - 입출력 데이터에 이상이 있는 경우
    - **DMA 완료 인터럽트**: Direct Memory Access 작업 완료 시 발생

**I/O 인터럽트 추가 설명**: 컴퓨터의 CPU는 주기억장치인 RAM과 매우 밀접한 관계가 있다. 예전에는 CPU가 RAM을 직접 관리했지만 지금은 **IMC(Integrated Memory Controller)**를 통해서 RAM을 관리하게 된다. 마찬가지로 I/O 역시 **I/O 컨트롤러**를 통해 관리하는데 이런 상황에서 발생하는 것이 I/O 인터럽트이다.

### 내부 인터럽트 (Exception/Trap)

잘못된 명령이나 잘못된 데이터를 사용할 때 발생하며 **Trap** 또는 **Exception**이라고 부른다.

- **프로그램 검사 인터럽트(Program check interrupt)**
    - **0으로 나눌 때**: CPU가 나눗셈 명령어 실행 시 피제수가 0인 것을 감지하면 즉시 **Division by Zero Exception** 발생 (무한루프가 아님)
    - **Overflow/Underflow**: 연산 결과가 레지스터 범위를 벗어날 때
    - **메모리 보호 위반**: 접근 권한이 없는 메모리 영역 접근 시
    - **페이지 폴트**: 가상 메모리에서 요청한 페이지가 물리 메모리에 없을 때
    - **기타 Exception**: 잘못된 명령어, 정렬되지 않은 메모리 접근 등

### 소프트웨어 인터럽트 (SVC: SuperVisor Call)

- 사용자가 프로그램을 실행시키거나 **시스템 서비스**를 요청하는 경우
- **시스템 콜**: `printf()`, `malloc()`, `fopen()` 등의 API 호출 시 내부적으로 발생
- 소프트웨어 이용 중 다른 프로세스를 실행시키면 **스케줄링**을 위해 자원 할당 등의 동작이 수행
- **x86에서는 INT 0x80**, **x86-64에서는 SYSCALL** 명령어 사용

### 인터럽트 동작 순서

1. **인터럽트 요청**: 하드웨어 또는 소프트웨어에서 IRQ 신호 발생
2. **프로그램 실행 중단**: 현재 실행 중이던 CPU 연산을 중단(일시 정지), **인터럽트 플래그** 확인
3. **현재 프로그램 상태 백업**: **PCB(Process Control Block)**에 레지스터, **PC(Program Counter)**, 스택 포인터 등 저장
4. **인터럽트 벡터 테이블 조회**: IRQ 번호를 이용해 해당 **인터럽트 핸들러** 주소 찾기
5. **인터럽트 서비스 루틴(ISR) 실행**: 인터럽트 원인을 파악하고 실질적인 처리 작업 수행. **Top Half**(긴급 처리)와 **Bottom Half**(지연 처리)로 구분
6. **상태 복구**: 인터럽트 발생 시 저장한 레지스터와 PC를 다시 복구
7. **중지된 프로그램 실행 재개**: **컨텍스트 스위칭**을 통해 원래 프로세스로 복귀

### 인터럽트 우선순위

**전원 이상(Power fail) > 기계 착오(Machine Check) > 외부 신호(External) > 입출력(I/O) > 내부 인터럽트(Exception) > 프로그램 검사(Program Check) > SVC(SuperVisor Call)**

**우선순위 처리 방식**:

- **인터럽트 마스킹**: 높은 우선순위 인터럽트 처리 중에는 낮은 우선순위 인터럽트 차단
- **네스티드 인터럽트**: 더 높은 우선순위 인터럽트 발생 시 현재 처리 중단하고 새로운 인터럽트 처리

### 이해를 위한 추가 설명

컴퓨터 조립 시에 CPU와 RAM을 사고 이를 제어하는 장치가 포함된 **Mainboard** 위에 해당 부품들을 조립함.

만약 CPU와 RAM을 좋은 부품으로 사고 이 Mainboard의 성능이 맞지 않을 경우 사용하면 이 메모리 매니저와 같은 컨트롤러의 성능이 떨어져서 해당 H/W 부품의 온전한 성능을 쓸 수 없음.

**예전 아키텍처 (Chipset 시대)**:

```
CPU ↔ Northbridge(메모리 컨트롤러) ↔ RAM
     ↕
     Southbridge(I/O 컨트롤러) ↔ 주변기기
```

**현재 아키텍처**:

```
CPU(IMC 내장) ↔ RAM (직접 연결)
 ↕
PCH(Platform Controller Hub) ↔ 주변기기
```

예전에는 이러한 장치들(메모리 매니저, 입출력 매니저)을 **브릿지**라고 했다. **노스 브릿지**는 CPU와 RAM 같은 고속 장치 간 통신을, **사우스 브릿지**는 USB 같은 저속 주변기기와의 I/O를 관리했다.

**Intel**이 CPU 성능이 외부 장치에 의존하게 되면서 **2008년부터 노스 브릿지 기능(IMC)을 CPU에 통합**했다. **AMD**는 **2003년부터** 이미 도입했었다.

### I/O 처리 과정

```
User Mode     HelloWorld   1. printf() API 호출
────────────────────────────────────────────
Kernel Mode   Video Driver  2. write() SystemCall
              ↓
              Device Driver 3. 하드웨어 제어 명령
────────────────────────────────────────────
Hardware      Video Card ← RAM  4. DMA를 통한 데이터 전송
              ↓         
              Monitor           5. 화면 출력
```

**처리 단계**:

1. **Hello World 출력** - `printf()` API 실행
2. **printf 내부적으로 시스템 콜 호출** - `write(1, "Hello World", 11)`
3. **데이터를 RAM에 저장** (모든 경우는 아니지만 버퍼링된 출력의 경우)
4. **DMA 설정**: 고성능 장치는 CPU 개입 없이 직접 메모리 접근
5. **주변기기로 전달**: DMA 컨트롤러가 RAM에서 비디오 메모리로 데이터 전송
6. **모니터로 출력**: 그래픽 카드가 픽셀 렌더링
7. **출력 완료 인터럽트 발생**: DMA 완료 또는 디바이스 작업 완료 신호

**성능 차이**:

- **동기식(Blocking)**: 각 단계가 완료될 때까지 대기 (전체 처리 시간: ~3ms)
- **비동기식(Non-Blocking)**: 요청 후 즉시 반환, 백그라운드에서 처리 (응답 시간: ~0.1ms)

고성능 장치의 경우 시스템 콜 호출 후 드라이버에 "이 데이터 출력해줘" 요청하고 **바로 반환**(비동기 호출)한다. CPU는 다른 작업을 수행하고, 실제 화면 출력은 **DMA와 GPU가 병렬로** 처리한다.

주변기기 성능이 좋으면 **CPU 개입을 최소화**하여 전체 시스템 성능이 향상된다.

### DirectX와 고성능 그래픽스

비디오 카드를 통해 화면에 많은 양의 데이터와 그래픽 작업을 요구하는 작업에서는 위처럼 여러 단계를 거쳐서 출력하는 방식은 속도가 느리다.

**전통적인 방식의 문제점**:

```
User App → System Call → Kernel → Driver → GPU
매번 모드 전환 비용 발생 (수백~수천 사이클)
```

**DirectX/Vulkan의 해결책**:

```
User App → DirectX Runtime → GPU Driver (User Mode) → GPU
커널 모드 전환 최소화, 명령어 배치(Command Buffer) 사용
```

그래서 나온 것이 직접 **User Mode에서 GPU 드라이버를 제어**할 수 있게 해주는 시스템이 바로 우리가 게임할 때 많이 설치하는 **DirectX**이다. DirectX는 **입출력 성능을 극단적으로 끌어올릴** 수 있게 해주는 **저수준 그래픽스 API**였다.

**성능 차이**:

- **일반 출력**: 픽셀당 시스템 콜 (60fps에서 수백만 번 호출)
- **DirectX**: 한 프레임당 몇 개의 명령어 배치로 처리

### 멀티코어에서의 인터럽트 분산

현대 멀티코어 시스템에서는 **인터럽트 어피니티(Interrupt Affinity)**를 통해 특정 IRQ를 특정 CPU 코어에 바인딩할 수 있다:

```bash
# 네트워크 카드 IRQ를 CPU 2번에만 할당
echo 4 > /proc/irq/24/smp_affinity  # (1<<2 = 4)

# 모든 CPU에 분산
echo f > /proc/irq/24/smp_affinity  # 0xF = 1111 (4코어)
```

### 정리

인터럽트는 **이벤트 기반 컴퓨팅**의 핵심으로, **폴링 방식 대비 100배 이상** 효율적이다. 현대 고성능 시스템에서는 **DMA, 비동기 처리, GPU 가속**을 통해 인터럽트 오버헤드를 최소화하면서 성능을 극대화한다.