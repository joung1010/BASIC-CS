## 프로세스간 통신 개요

### IPC(Inter-Process Communication)의 필요성

**프로세스는 독립된 메모리 공간을 가지는데 이때 이 메모리 공간에 대해서 외부의 접근이 불가능하도록 OS에서 이를 보장**합니다. **간혹 특수한 케이스의 경우 외부에서 메모리에 대한 값을 변경해야만 하는 경우가 있는데 그 경우를 제외하고서 메모리에 있는 값이 변조된다면 이는 해킹**입니다.

```
프로세스 메모리 격리
┌─────────────────┐    ┌─────────────────┐
│   프로세스 A     │    │   프로세스 B     │
│                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │   독립적인   │ │🚫 │ │   독립적인   │ │
│ │ 메모리 공간  │ │ ↔ │ │ 메모리 공간  │ │
│ │             │ │    │ │             │ │
│ │ int data=10 │ │    │ │ int data=20 │ │
│ │             │ │    │ │             │ │
│ └─────────────┘ │    │ └─────────────┘ │
│                 │    │                 │
│    PID: 100     │    │    PID: 200     │
└─────────────────┘    └─────────────────┘
      직접 접근 불가능!
      
❓ 문제: 어떻게 데이터를 주고받을까?
💡 해답: IPC (Inter-Process Communication)
```

### 프로세스 내부 vs 프로세스 간 데이터 통신

**프로세스 내부 데이터 통신**은 같은 프로세스 내의 스레드들이 Heap, Data 영역을 공유하여 쉽게 이루어집니다. 하지만 **프로세스 간 데이터 통신**은 보안과 안정성을 위해 특별한 메커니즘이 필요합니다.

```
프로세스 내부 통신 (쉬움)
┌─────────────────────────────────────────────────────┐
│                프로세스 A                            │
│  👨 스레드1   👩 스레드2   👦 스레드3               │
│    ↓           ↓           ↓                       │
│  ┌─────────────────────────────────────────────┐   │
│  │           공유 메모리 영역                  │   │
│  │  전역변수: shared_data = 100              │   │
│  │  동적할당: malloc()으로 생성된 데이터       │   │
│  └─────────────────────────────────────────────┘   │
│              ✅ 자유롭게 접근 가능                   │
└─────────────────────────────────────────────────────┘

🏠 프로세스 간 통신 (복잡함)
┌─────────────────┐           ┌─────────────────┐
│   프로세스 A     │    🚫     │   프로세스 B     │
│   data = 100    │ ←──╳──→   │   data = ???    │
└─────────────────┘           └─────────────────┘
         ↓                             ↑
    ┌─────────────────────────────────────────────┐
    │         🛤️ IPC 메커니즘 필요              │
    │  • Pipe  • Shared Memory  • Socket        │
    └─────────────────────────────────────────────┘
```

### 저장 매체별 IPC 방식 분류

**메모리 하면 1차 메모리인 RAM과 함께 2차 SSD 또는 USB와 같은 File 형태의 2차 메모리가 있습니다**.

**저장 매체별 IPC 방식**

**RAM 기반 (빠름, 제한적):**

```
┌─────────────────────────────────────────────────────┐
│  특징:                                              │
│  • 매우 빠른 속도 (나노초 단위)                      │
│  • 고정된 크기 제한                                 │
│  • 휘발성 (전원 꺼지면 사라짐)                       │
│  • OS가 엄격하게 관리                               │
│                                                     │
│  IPC 방식:                                          │
│  • Shared Memory (공유 메모리)                      │
│  • Message Queue (메시지 큐)                        │
│  • Semaphore (세마포어)                             │
│                                                     │
│  사용 사례:                                         │
│  • 고성능이 필요한 실시간 통신                       │
│  • 같은 서버 내 프로세스 간 통신                     │
│  • 멀티미디어 스트리밍                              │
└─────────────────────────────────────────────────────┘
```

**File 기반 (느림, 유연함):**

```
┌─────────────────────────────────────────────────────┐
│  특징:                                              │
│  • 상대적으로 느린 속도 (밀리초 단위)                │
│  • 동적 크기 조절 가능                              │
│  • 영구 저장 (전원 꺼져도 유지)                      │
│  • 파일 시스템이 관리                               │
│                                                     │
│  IPC 방식:                                          │
│  • Named Pipe (명명된 파이프)                       │
│  • Regular File (일반 파일)                         │
│  • Unix Domain Socket                              │
│                                                     │
│  사용 사례:                                         │
│  • 로그 파일 기반 통신                              │
│  • 설정 파일 공유                                   │
│  • 다른 서버 간 비동기 통신                         │
└─────────────────────────────────────────────────────┘
```

### Pipe를 통한 File 기반 통신

**이러한 파일 형태로 프로세스 간 통신을 하는 방식이 바로 파이프**입니다.

**이때 우리는 파일이라는 단어를 마주했을 때 가장 먼저 stream이라는 단어를 떠올려야 합니다**. **이 파일은 시작이 있고 끝이 좀 모호**합니다. **맨 처음 파일을 쓰기 시작하면 size가 0으로 시작해서 자동으로 이 size가 증가하게 됩니다**.

```
Stream 기반 파일 특성

파일 생성 시점:
┌─────────────────────────────────────────────────────┐
│  파일명: communication.pipe                         │
│  크기: 0 bytes                                      │
│  ┌─────────────────────────────────────────────┐   │
│  │                                             │   │ ← 비어있음
│  └─────────────────────────────────────────────┘   │
│  시작 포인터: 0 │                   끝 포인터: 0    │
└─────────────────────────────────────────────────────┘

데이터 쓰기 과정:
┌─────────────────────────────────────────────────────┐
│  Process A가 "Hello" 쓰기                           │
│  크기: 5 bytes                                      │
│  ┌─────────────────────────────────────────────┐   │
│  │ H │ e │ l │ l │ o │                         │   │
│  └─────────────────────────────────────────────┘   │
│  시작: 0        │           끝: 5                   │
└─────────────────────────────────────────────────────┘

계속 데이터 추가:
┌─────────────────────────────────────────────────────┐
│  Process A가 " World!" 추가                         │
│  크기: 12 bytes                                     │
│  ┌─────────────────────────────────────────────┐   │
│  │ H │ e │ l │ l │ o │   │ W │ o │ r │ l │ d │!│   │
│  └─────────────────────────────────────────────┘   │
│  시작: 0                    │           끝: 12      │
│                             ↑                       │
│                    계속 확장 가능                   │
│              (파일 시스템 한계까지)                  │
└─────────────────────────────────────────────────────┘
```

**그러면 얼마만큼 증가하냐는 사용하는 파일 시스템이 제공하는 한계까지 증가할 수 있습니다**.

**반면 RAM을 사용하는 방식은 고정적인 길이를 이용하는 방식**입니다. **RAM은 매우 한정된 자원으로 OS에서 Memory를 사용하려고 할 때 매우 깐깐하게 이를 검사**합니다.

### IPC 범위의 확장: 소켓과 RPC

**그러면 이 IPC라는 개념, 2개의 프로세스가 서로 통신한다고 하면, 이 범위가 이제 네트워크의 범위까지 확장되면 이를 소켓**이라고 합니다.

```
IPC 범위의 확장

로컬 IPC (같은 컴퓨터 내):
┌─────────────────────────────────────────────────────┐
│              단일 컴퓨터                             │
│  ┌─────────────┐         ┌─────────────┐           │
│  │ 프로세스 A   │  ←───→  │ 프로세스 B   │           │
│  └─────────────┘         └─────────────┘           │
│                                                     │
│  사용 방식:                                         │
│  • Shared Memory                                   │
│  • Named Pipe                                      │
│  • Message Queue                                   │
│  • Unix Domain Socket                              │
└─────────────────────────────────────────────────────┘
                    ↓ 범위 확장
네트워크 IPC (원격 통신):
┌─────────────────┐           ┌─────────────────┐
│   컴퓨터 A       │           │   컴퓨터 B       │
│ ┌─────────────┐ │           │ ┌─────────────┐ │
│ │ 프로세스 A   │ │  ←─────→  │ │ 프로세스 B   │ │
│ └─────────────┘ │           │ └─────────────┘ │
│                 │           │                 │
│  IP: 192.168.1.10│          │  IP: 192.168.1.20│
└─────────────────┘           └─────────────────┘
              Internet/LAN 연결
```

사용 방식:
- TCP/UDP Socket
- HTTP/HTTPS
- WebSocket
- gRPC (RPC over HTTP/2)

- 이 소켓을 이용해서 TCP 통신을 한 상태에서 또 다른 개념이 등장하게 되는데 그것이 RPC(Remote Procedure Call)입니다. **풀어서 말하면 원격 함수를 호출한다는 것**입니다.

```
RPC (Remote Procedure Call) 진화

전통적인 RPC (1980년대):
┌─────────────────────────────────────────────────────┐
│  클라이언트                    서버                  │
│  ┌─────────────┐             ┌─────────────┐       │
│  │함수 호출:    │   TCP/UDP   │실제 함수:    │       │
│  │add(3, 5)    │ ───────────→│int add(a,b) │       │
│  │             │             │{return a+b;}│       │
│  │결과: 8      │←─────────── │return 8     │       │
│  └─────────────┘             └─────────────┘       │
│                                                     │
│  특징: 마치 로컬 함수 호출하는 것처럼 느껴짐        │
└─────────────────────────────────────────────────────┘

현대의 RPC (HTTP/2, HTTP/3 기반):
┌─────────────────────────────────────────────────────┐
│  • gRPC (Google) - HTTP/2 + Protocol Buffers       │
│  • Apache Thrift - 다중 언어 지원                   │
│  • JSON-RPC - HTTP + JSON                          │
│                                                     │
│  장점:                                              │
│  • 타입 안전성                                      │
│  • 자동 코드 생성                                   │
│  • 스트리밍 지원                                    │
│  • 다중 언어 호환                                   │
└─────────────────────────────────────────────────────┘
```

**해당 개념은 잘 사용하지 않다가 최근에 HTTP/3와 만나면서 다시 급부상하기 시작했습니다**. **그래서 현재 HTTP는 예전의 TCP의 기능도 대체하고 있습니다**.

### Pipe 방식의 특성과 장점

**그래서 이 파이프 방식은 파일을 통해서 서로의 데이터를 주고받고, 파일의 특성상 시작은 있지만 끝이 모호하기 때문에 어떤 데이터를 직렬화해서 데이터를 주고받을 때 큰 이점을 가집니다**. **(한쪽에서 쓰고 다른 한쪽에서는 읽는다.)**

```
Pipe의 Producer-Consumer 패턴

Named Pipe 동작:
┌─────────────────────────────────────────────────────┐
│  📝 Writer Process (Producer)                       │
│  ┌─────────────────────────────────────────────┐   │
│  │ 1. 데이터 직렬화                            │   │
│  │    객체 → JSON/XML/Binary                   │   │
│  │                                             │   │
│  │ 2. 파이프에 순차적 쓰기                     │   │
│  │    write("data1")                           │   │
│  │    write("data2")                           │   │
│  │    write("data3")                           │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                    ↓ Pipe File
┌─────────────────────────────────────────────────────┐
│  📄 /tmp/my_pipe                                    │
│  ┌─────────────────────────────────────────────┐   │
│  │ data1│data2│data3│                          │   │ ← FIFO 구조
│  └─────────────────────────────────────────────┘   │
│    ↑읽기 위치      ↑쓰기 위치                       │
└─────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────┐
│  📖 Reader Process (Consumer)                       │
│  ┌─────────────────────────────────────────────┐   │
│  │ 1. 파이프에서 순차적 읽기                   │   │
│  │    read() → "data1"                         │   │
│  │    read() → "data2"                         │   │
│  │    read() → "data3"                         │   │
│  │                                             │   │
│  │ 2. 데이터 역직렬화                          │   │
│  │    JSON/XML/Binary → 객체                   │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

장점:
✅ 순서 보장 (FIFO)
✅ 블로킹/논블로킹 모드 지원  
✅ 크기 제한 없음 (파일 시스템 한계까지)
✅ 영구 저장 가능

### Shared Memory 방식

**또 다른 방식은 프로세스 간 Shared Memory 공유 메모리를 이용하는 방식입니다**. **(전역 변수를 이용한). RAM 메모리를 이용하는 방식이기 때문에 고정된 길이만큼 사용**합니다.

```
Shared Memory 동작 원리

가상 메모리 레벨:
┌─────────────────┐           ┌─────────────────┐
│   프로세스 A     │           │   프로세스 B     │
│                 │           │                 │
│ 가상주소:       │           │ 가상주소:       │
│ 0x10000000     │           │ 0x20000000     │ ← 서로 다름
│ ┌─────────────┐ │           │ ┌─────────────┐ │
│ │shared_data  │ │           │ │shared_data  │ │
│ │   = 100     │ │           │ │   = 100     │ │
│ └─────────────┘ │           │ └─────────────┘ │
└─────────────────┘           └─────────────────┘
         ↓                             ↓
    ┌─────────────────────────────────────────────┐
    │        물리 메모리 (같은 위치!)              │
    │     물리주소: 0x8F340000                    │
    │  ┌─────────────────────────────────────┐   │
    │  │        shared_data = 100            │   │ ← 실제로는 같은 메모리!
    │  └─────────────────────────────────────┘   │
    └─────────────────────────────────────────────┘
```

**두 개의 프로세스가 있다. 이때 각 프로세스마다 할당된 VMS가 있을 것이고 거기에 특정 전역변수를 사용한다. 이때 이 두 프로세스의 전역변수가 실제 물리적인 위치가 동일하다**. **만약 A 프로세스가 전역변수에 3을 할당하고 이를 B 프로세스가 읽는다면 물리적인 메모리 공간이 동일하기 때문에 B 프로세스에서 3이라는 값을 읽을 수 있다**.

### 동기화를 통한 Shared Memory 관리

**그래서 각 프로세스마다 해당 공유 메모리에 읽거나 쓰거나 하는데 이때 A 프로세스에서 해당 값을 write 한다면 다른 프로세스 B한테 해당 값에 대한 변경(signal 혹은 event)을 알려준다**. **이때 B 프로세스는 대기 상태에 있다가 신호가 오면 해당 값을 읽는다**.

```
Signal/Event 기반 동기화

시나리오: Process A가 데이터 업데이트
┌─────────────────────────────────────────────────────┐
│  🕐 시간 순서별 동작                                 │
│                                                     │
│  T1: Process B가 대기 상태 진입                     │
│      wait_for_signal(DATA_READY);                   │
│                                                     │
│  T2: Process A가 공유 메모리에 데이터 쓰기          │
│      shared_memory->data = 42;                      │
│      shared_memory->timestamp = current_time();     │
│                                                     │
│  T3: Process A가 신호 발송                          │
│      send_signal(PROCESS_B_PID, DATA_READY);        │
│                                                     │
│  T4: Process B가 신호 수신하고 깨어남               │
│      // 대기 상태에서 실행 상태로 전환              │
│                                                     │
│  T5: Process B가 공유 메모리에서 데이터 읽기        │
│      int value = shared_memory->data; // 42         │
│      long time = shared_memory->timestamp;          │
│                                                     │
│  T6: Process B가 다시 대기 상태로 전환              │
│      wait_for_signal(DATA_READY);                   │
└─────────────────────────────────────────────────────┘

동기화 메커니즘들:
┌─────────────────────────────────────────────────────┐
│  🔄 Semaphore (세마포어)                            │
│     sem_wait(&semaphore);  // 락 획득               │
│     // 공유 메모리 접근                             │
│     sem_post(&semaphore);  // 락 해제               │
│                                                     │
│  🔒 Mutex (뮤텍스)                                  │  
│     pthread_mutex_lock(&mutex);                     │
│     // 공유 메모리 접근                             │
│     pthread_mutex_unlock(&mutex);                   │
│                                                     │
│  📨 Event/Signal                                    │
│     WaitForSingleObject(event_handle, INFINITE);    │
│     SetEvent(event_handle);                         │
└─────────────────────────────────────────────────────┘
```

### IPC 기법 종합 비교

**IPC 기법별 특성 비교**

**메모리 기반:**

```
┌─────────────────────────────────────────────────────┐
│  🧠 Memory 기반                                     │
│  ────────────────────────────────────────────────  │
│  • Shared Memory                                   │
│    ✅ 매우 빠름 (메모리 직접 접근)                  │
│    ✅ 대용량 데이터 전송 가능                       │
│    ❌ 동기화 복잡함                                │
│    ❌ 같은 서버에서만 사용 가능                     │
│                                                     │
│  • Message Queue                                   │
│    ✅ 메시지 순서 보장                             │
│    ✅ 다양한 우선순위 지원                         │
│    ❌ 크기 제한 있음                               │
│    ❌ 중간 정도 속도                               │
└─────────────────────────────────────────────────────┘
```

**파일 기반:**

```
┌─────────────────────────────────────────────────────┐
│  📄 File 기반 (Pipe)                               │
│  ────────────────────────────────────────────────  │
│  • Anonymous Pipe                                  │
│    ✅ 부모-자식 프로세스 간 간단한 통신             │
│    ✅ 운영체제가 자동 관리                         │  
│    ❌ 관련 없는 프로세스 간 사용 불가               │
│                                                     │
│  • Named Pipe (FIFO)                              │
│    ✅ 임의의 프로세스 간 통신 가능                  │
│    ✅ 파일 시스템 권한 활용                        │
│    ❌ 파일 I/O 오버헤드                           │
│    ❌ 상대적으로 느림                              │
└─────────────────────────────────────────────────────┘
```

**소켓 기반:**

```
┌─────────────────────────────────────────────────────┐
│  🌐 Socket 기반                                     │
│  ────────────────────────────────────────────────  │
│  • Unix Domain Socket                              │
│    ✅ 로컬에서 네트워크 수준 성능                   │
│    ✅ 양방향 통신                                  │
│    ❌ Unix/Linux 계열에서만 지원                   │
│                                                     │
│  • TCP/UDP Socket                                  │
│    ✅ 네트워크를 통한 원격 통신                     │
│    ✅ 표준화된 프로토콜                            │
│    ❌ 네트워크 지연 시간                           │
│    ❌ 패킷 손실 가능성                             │
└─────────────────────────────────────────────────────┘
```

**RPC 기반:**

```
┌─────────────────────────────────────────────────────┐
│  📞 RPC 기반                                        │
│  ────────────────────────────────────────────────  │
│  • gRPC (HTTP/2)                                   │
│    ✅ 타입 안전성 보장                             │
│    ✅ 다중 언어 지원                               │
│    ✅ 스트리밍 지원                                │
│    ❌ 학습 곡선 가파름                             │
│                                                     │
│  • REST API (HTTP/HTTPS)                          │
│    ✅ 단순하고 직관적                              │
│    ✅ 웹 표준 활용                                 │
│    ❌ 오버헤드 큼                                  │
│    ❌ 실시간 통신에 부적합                         │
└─────────────────────────────────────────────────────┘
```

**IPC 기법들**은 각각 고유한 특성과 적합한 사용 사례를 가지고 있으며, **성능 요구사항, 통신 범위, 데이터 크기, 실시간성** 등을 고려하여 적절한 방식을 선택해야 합니다. 현대 시스템에서는 이러한 기법들을 **조합하여 사용**하는 경우가 많으며, 특히 **마이크로서비스 아키텍처**에서는 HTTP 기반 API와 메시지 큐를 함께 활용하는 하이브리드 접근법이 일반적입니다.