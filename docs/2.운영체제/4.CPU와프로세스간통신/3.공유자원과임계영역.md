## 공유 자원과 임계 구역

### Race Condition(경쟁 조건)의 발생 원인

**프로세스와 스레드 모두 여러 개가 존재했을 때 문제가 발생하는 이유는 항상 동시에 특정 한 대상에 접근했을 때 필연적으로 경쟁 조건이 발생**하기 때문입니다.

```
은행 계좌 예금 문제 시나리오

초기 상태: 예금 10만원

❌ 문제가 발생하는 실행 순서:
┌─────────────────────────────────────────────────────┐
│  시간  │  프로세스 A             │  프로세스 B        │
│  ──────┼────────────────────────┼───────────────────│
│  T1    │ 예금 10만원 확인        │                   │
│  T2    │                        │ 예금 10만원 확인   │
│  T3    │                        │ 5만원 입금 계산    │
│  T4    │                        │ 15만원 저장       │
│  T5    │ 10만원 입금 계산        │                   │
│  T6    │ 20만원 저장 (덮어씀!)   │                   │
└─────────────────────────────────────────────────────┘

💰 결과: 예상값 25만원 → 실제값 20만원 (5만원 손실!)

✅ 올바른 실행 순서 (순차 처리):
┌─────────────────────────────────────────────────────┐
│  시간  │  프로세스 A             │  프로세스 B        │
│  ──────┼────────────────────────┼───────────────────│
│  T1    │ 예금 10만원 확인        │   🔒 대기 중       │
│  T2    │ 10만원 입금 계산        │   🔒 대기 중       │
│  T3    │ 20만원 저장             │   🔒 대기 중       │
│  T4    │ 🔓 작업 완료            │ 예금 20만원 확인   │
│  T5    │                        │ 5만원 입금 계산    │
│  T6    │                        │ 25만원 저장       │
└─────────────────────────────────────────────────────┘

💰 결과: 예상값 25만원 → 실제값 25만원 (정확!)
```

### 비원자적 연산의 위험성

**우리가 한 줄의 코드가 한 번의 명령어으로 처리되는지 생각해봐야 합니다**.

**코드에서 단순히 예금을 확인하고 그 예금에 원하는 금액을 더해서 저장합니다. 이러한 한 줄의 코드가 실제로는 메모리에서 값을 읽고 그 값을 다른 값으로 덮어쓰고 다시 저장한다와 같이 한 줄의 코드도 최소 3번 이상의 명령으로 처리됩니다**.

```
고수준 코드 vs 저수준 명령어

Java 코드 (한 줄):
balance += depositAmount;

실제 CPU 명령어 (최소 3단계):
┌─────────────────────────────────────────────────────┐
│  1️⃣ LOAD R1, [balance_address]                     │
│     메모리에서 현재 잔액을 레지스터 R1에 로드        │
│     CPU 사이클: 100~300 (RAM 접근 시간)             │
│                                                     │
│  2️⃣ ADD R1, R1, depositAmount                      │
│     R1 = R1 + depositAmount (레지스터 내 연산)      │
│     CPU 사이클: 1 (매우 빠름)                       │
│                                                     │
│  3️⃣ STORE [balance_address], R1                    │
│     계산된 결과를 다시 메모리에 저장                │
│     CPU 사이클: 100~300 (RAM 접근 시간)             │
└─────────────────────────────────────────────────────┘

⚠️ 위험 지점: 각 단계 사이에 다른 스레드가 끼어들 수 있음!

시나리오: 두 스레드가 동시에 balance += 1000 실행
┌─────────────────────────────────────────────────────┐
│  시간  │ 스레드 A        │ 스레드 B        │ balance │
│  ──────┼────────────────┼────────────────┼────────│
│  T1    │LOAD R1,[bal]   │                │ 10000  │
│        │R1 = 10000      │                │        │
│  T2    │                │LOAD R2,[bal]   │ 10000  │
│        │                │R2 = 10000      │        │
│  T3    │ADD R1,1000     │                │ 10000  │
│        │R1 = 11000      │                │        │
│  T4    │                │ADD R2,1000     │ 10000  │
│        │                │R2 = 11000      │        │
│  T5    │STORE [bal],R1  │                │ 11000  │
│  T6    │                │STORE [bal],R2  │ 11000  │← 덮어씀!
└─────────────────────────────────────────────────────┘

결과: 20000이 되어야 하는데 11000이 됨!
```

### 원자성(Atomicity)과 컴파일러 최적화

**우리가 작성한 이 코드가 명령 한 번에 처리된다는 보장할 수 있느냐 즉, 우리가 작성한 코드가 원자성이 보장되지 않는다면 중간에 다른 처리가 발생할 수 있다는 말과 같습니다**. **또한 실제 작성된 코드도 컴파일 시 최적화를 통해 실제 실행 순서에 약간의 차이가 존재할 수도 있습니다**.

컴파일러 최적화의 예상치 못한 결과:

```java

// **원본 코드:**

int flag = 0;
int data = 0;

void producer() {
    data = 42;        // 1. 데이터 먼저 설정
    flag = 1;         // 2. 플래그로 완료 신호
}

void consumer() {
    while (flag == 0) {
        // 플래그가 설정될 때까지 대기
    }
    printf("Data: %d\n", data);  // 3. 데이터 읽기
}

컴파일러 최적화 후 (가능한 결과):
void producer() {
    flag = 1;         // ⚠️ 순서 바뀜!
    data = 42;        // 컴파일러가 성능상 이유로 재배열
}`
```

```
문제 상황:
┌─────────────────────────────────────────────────────┐
│  T1: Producer가 flag = 1 실행                       │
│  T2: Consumer가 flag == 1 확인하고 루프 탈출        │
│  T3: Consumer가 data 읽기 → 아직 42가 아닌 0!      │
│  T4: Producer가 data = 42 실행 (너무 늦음)          │
└─────────────────────────────────────────────────────┘

해결책: volatile 키워드나 메모리 배리어 사용
volatile int flag = 0;
volatile int data = 0;
```

### 공유 자원의 종류

**그래서 이 공유 자원은 보통 메모리와 파일 정도가 흔히 만날 수 있는 공유 자원에 속합니다**.

```
공유 자원의 분류

💾 메모리 기반 공유 자원:
┌─────────────────────────────────────────────────────┐
│  • 전역 변수 (Global Variables)                     │
│    static int counter = 0;                          │
│                                                     │
│  • 동적 할당 메모리 (Heap Memory)                   │
│    int* shared_data = malloc(sizeof(int));          │
│                                                     │
│  • 공유 메모리 (Shared Memory)                      │
│    shmget(), shmat() 등으로 생성                    │
│                                                     │
│  • 스태틱 변수 (Static Variables)                   │
│    함수 내부의 static 변수들                        │
└─────────────────────────────────────────────────────┘

📁 파일 기반 공유 자원:
┌─────────────────────────────────────────────────────┐
│  • 일반 파일 (Regular Files)                        │
│    여러 프로세스가 동시에 읽기/쓰기                  │
│                                                     │
│  • 로그 파일 (Log Files)                           │
│    여러 모듈이 동시에 로그 기록                      │
│                                                     │
│  • 설정 파일 (Configuration Files)                  │
│    런타임에 설정 변경 시 충돌 가능                   │
│                                                     │
│  • 데이터베이스 파일                                │
│    SQLite 등 파일 기반 DB의 동시 접근               │
└─────────────────────────────────────────────────────┘

🔧 시스템 자원:
┌─────────────────────────────────────────────────────┐
│  • 네트워크 포트 (Network Ports)                    │
│    같은 포트에 여러 프로세스가 바인딩 시도           │
│                                                     │
│  • 하드웨어 장치 (Hardware Devices)                 │
│    프린터, 사운드 카드 등의 독점적 사용              │
│                                                     │
│  • 시스템 리소스 (System Resources)                 │
│    파일 핸들, 메모리 풀, 스레드 풀                  │
└─────────────────────────────────────────────────────┘
```

### 임계 구역(Critical Section)과 동기화

**그래서 이렇게 동시적으로 접근하는 자원에 대해서 원자성을 보장하여 동시적 처리가 안 되게 방지하여 예상되는 문제를 사전에 차단해야 합니다**.

**그렇다면 우리가 작성한 코드가 있다면 특정한 코드가 다른 실행 흐름 즉 스레드의 개입으로 인하여 값이 변질될 가능성이 존재한다면 그 코드가 시작되는 처음과 끝에 Lock, UnLock을 통하여 원자성을 보장해야 합니다**.

```java
*// ❌ 동기화되지 않은 위험한 코드*
public class UnsafeBankAccount {
    private int balance = 100000;  *// 공유 자원*
    
    public void deposit(int amount) {
        *// 임계 구역 시작 (동기화 없음 - 위험!)*
        int currentBalance = balance;      *// 1. 읽기*
        int newBalance = currentBalance + amount;  *// 2. 계산*
        balance = newBalance;              *// 3. 쓰기// 임계 구역 끝*
        
        System.out.println("입금 완료: " + amount + ", 잔액: " + balance);
    }
}

*// ✅ 동기화된 안전한 코드*
public class SafeBankAccount {
    private int balance = 100000;
    private final Object lock = new Object();  *// 락 객체*
    
    public void deposit(int amount) {
        synchronized (lock) {  *// 🔒 Lock 획득// ===== 임계 구역 시작 =====*
            int currentBalance = balance;
            
            *// 시뮬레이션: 다른 작업으로 인한 지연*
            try {
                Thread.sleep(1);  *// 1ms 지연*
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            int newBalance = currentBalance + amount;
            balance = newBalance;
            *// ===== 임계 구역 끝 =====*
        }  *// 🔓 Lock 자동 해제*
        
        System.out.println("입금 완료: " + amount + ", 잔액: " + balance);
    }
    
    public synchronized int getBalance() {  *// 메서드 전체 동기화*
        return balance;
    }
}

*// 테스트 코드*
public class BankTest {
    public static void main(String[] args) throws InterruptedException {
        SafeBankAccount account = new SafeBankAccount();
        
        *// 5개 스레드가 동시에 10만원씩 입금*
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                account.deposit(100000);
                System.out.println("스레드 " + threadId + " 완료");
            });
        }
        
        *// 모든 스레드 시작*
        for (Thread thread : threads) {
            thread.start();
        }
        
        *// 모든 스레드 완료 대기*
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("최종 잔액: " + account.getBalance());
        System.out.println("예상 잔액: " + (100000 + 5 * 100000));
    }
}
```

### 임계 구역 최소화의 중요성

**이렇게 공유 자원에 대한 경쟁 조건이 발생하는 임계 구간에 대해 어느 구간을 언제 어떤 조건일 때 임계 구간으로 설정할지에 대해서는 완벽하게 경험에 의존하지만 확실한 것은 이 임계 구간은 반드시 최소화해야 합니다**.

```java
*// ❌ 나쁜 예: 임계 구역이 너무 큼*
public class BadExample {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void processData() {
        synchronized (lock) {  *// 🔒 락 획득// === 불필요하게 긴 임계 구역 ===*
            
            *// 1. 네트워크 호출 (수백 밀리초 소요)*
            String data = fetchDataFromServer();  *// ❌ 락 안에서 느린 작업*
            
            *// 2. 복잡한 계산 (수십 밀리초 소요)*  
            String processed = processComplexAlgorithm(data);  *// ❌ 락 안에서 무거운 연산*
            
            *// 3. 파일 I/O (수십 밀리초 소요)*
            writeToFile(processed);  *// ❌ 락 안에서 I/O 작업*
            
            *// 4. 실제로 보호해야 할 공유 자원 접근*
            counter++;  *// ✅ 정말 필요한 부분 (1 마이크로초)*
            
            *// === 임계 구역 끝 ===*
        }  *// 🔓 락 해제 (전체 시간: 수백 밀리초)*
    }
}

*// ✅ 좋은 예: 임계 구역 최소화*
public class GoodExample {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void processData() {
        *// 락 외부에서 느린 작업들 수행*
        String data = fetchDataFromServer();      *// 락 없이 실행*
        String processed = processComplexAlgorithm(data);  *// 락 없이 실행*
        writeToFile(processed);                   *// 락 없이 실행*
        
        *// 최소한의 임계 구역*
        synchronized (lock) {  *// 🔒 락 획득*
            counter++;  *// 정말 필요한 부분만 보호 (1 마이크로초)*
        }  *// 🔓 락 해제 (전체 락 시간: 1 마이크로초)*
    }
}
```

### 임계 구역 설계 원칙

```
임계 구역 최소화 전략

1️⃣ 사전 준비 (Pre-computation)
┌─────────────────────────────────────────────────────┐
│  락 획득 전에 가능한 모든 계산을 미리 수행           │
│                                                     │
│  // 락 외부에서 준비                                │
│  int newValue = expensiveCalculation();             │
│  String formattedData = formatData(rawData);        │
│                                                     │
│  synchronized (lock) {                              │
│      // 락 내부에서는 최소한의 작업만               │
│      sharedResource = newValue;                     │
│  }                                                  │
└─────────────────────────────────────────────────────┘

2️⃣ 지역 변수 활용 (Local Variable Usage)
┌─────────────────────────────────────────────────────┐
│  공유 자원을 지역 변수로 복사해서 작업               │
│                                                     │
│  int localCopy;                                     │
│  synchronized (lock) {                              │
│      localCopy = sharedData;  // 빠른 복사          │
│  }                                                  │
│                                                     │
│  // 락 외부에서 복잡한 작업                         │
│  int result = heavyProcessing(localCopy);           │
│                                                     │
│  synchronized (lock) {                              │
│      sharedData = result;  // 빠른 업데이트         │
│  }                                                  │
└─────────────────────────────────────────────────────┘

3️⃣ 읽기-수정-쓰기 최적화
┌─────────────────────────────────────────────────────┐
│  // ❌ 비효율적                                    │
│  synchronized (lock) {                              │
│      for (int i = 0; i < 1000; i++) {              │
│          counter++;  // 1000번의 락 경합            │
│      }                                              │
│  }                                                  │
│                                                     │
│  // ✅ 효율적                                      │
│  int increment = 1000;  // 미리 계산               │
│  synchronized (lock) {                              │
│      counter += increment;  // 한 번의 락 경합      │
│  }                                                  │
└─────────────────────────────────────────────────────┘

4️⃣ 세밀한 락 사용 (Fine-grained Locking)
┌─────────────────────────────────────────────────────┐
│  // ❌ 하나의 큰 락                                │
│  private final Object bigLock = new Object();      │
│                                                     │
│  synchronized (bigLock) {                           │
│      accountA.withdraw(100);                        │
│      accountB.deposit(100);                         │
│  }                                                  │
│                                                     │
│  // ✅ 여러 개의 작은 락                           │
│  synchronized (accountA.getLock()) {                │
│      accountA.withdraw(100);                        │
│  }                                                  │
│  synchronized (accountB.getLock()) {                │
│      accountB.deposit(100);                         │
│  }                                                  │
└─────────────────────────────────────────────────────┘
```

### 성능 영향 분석

```
임계 구역 크기별 성능 비교

임계 구역 시간: 1ms (긴 임계 구역)
┌─────────────────────────────────────────────────────┐
│  10개 스레드 실행 시:                               │
│  스레드 1: 대기 0ms + 실행 1ms = 1ms                │
│  스레드 2: 대기 1ms + 실행 1ms = 2ms                │
│  스레드 3: 대기 2ms + 실행 1ms = 3ms                │
│  ...                                                │
│  스레드 10: 대기 9ms + 실행 1ms = 10ms              │
│                                                     │
│  총 처리 시간: 10ms                                 │
│  평균 대기 시간: 4.5ms                              │
│  처리량: 1000 ops/sec                               │
└─────────────────────────────────────────────────────┘

임계 구역 시간: 0.01ms (짧은 임계 구역)
┌─────────────────────────────────────────────────────┐
│  10개 스레드 실행 시:                               │
│  스레드 1: 대기 0ms + 실행 0.01ms = 0.01ms          │
│  스레드 2: 대기 0.01ms + 실행 0.01ms = 0.02ms       │
│  스레드 3: 대기 0.02ms + 실행 0.01ms = 0.03ms       │
│  ...                                                │
│  스레드 10: 대기 0.09ms + 실행 0.01ms = 0.1ms       │
│                                                     │
│  총 처리 시간: 0.1ms                                │
│  평균 대기 시간: 0.045ms                            │
│  처리량: 100,000 ops/sec                            │
└─────────────────────────────────────────────────────┘

결론: 임계 구역을 1/100로 줄이면 처리량이 100배 향상!
```

이처럼 **임계 구역의 최소화는 단순한 최적화가 아니라 시스템 전체 성능을 좌우하는 핵심 요소**입니다. 경험 많은 개발자가 되기 위해서는 **어떤 코드가 정말로 동기화가 필요한지, 그리고 그 범위를 어떻게 최소화할지를 정확히 판단하는 능력**을 기르는 것이 중요하다.