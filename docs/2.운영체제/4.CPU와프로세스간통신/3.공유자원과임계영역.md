## 공유 자원과 임계 구역

### Race Condition(경쟁 조건)의 발생 원인

**프로세스와 스레드 모두 여러 개가 존재했을 때 문제가 발생하는 이유는 항상 동시에 특정 한 대상에 접근했을 때 필연적으로 경쟁 조건이 발생**하기 때문입니다.

```
은행 계좌 예금 문제 시나리오

초기 상태: 예금 10만원

❌ 문제가 발생하는 실행 순서:
┌─────────────────────────────────────────────────────┐
│  시간  │  프로세스 A             │  프로세스 B        │
│  ──────┼────────────────────────┼───────────────────│
│  T1    │ 예금 10만원 확인        │                   │
│  T2    │                        │ 예금 10만원 확인   │
│  T3    │                        │ 5만원 입금 계산    │
│  T4    │                        │ 15만원 저장       │
│  T5    │ 10만원 입금 계산        │                   │
│  T6    │ 20만원 저장 (덮어씀!)   │                   │
└─────────────────────────────────────────────────────┘

💰 결과: 예상값 25만원 → 실제값 20만원 (5만원 손실!)

✅ 올바른 실행 순서 (순차 처리):
┌─────────────────────────────────────────────────────┐
│  시간  │  프로세스 A             │  프로세스 B        │
│  ──────┼────────────────────────┼───────────────────│
│  T1    │ 예금 10만원 확인        │   🔒 대기 중       │
│  T2    │ 10만원 입금 계산        │   🔒 대기 중       │
│  T3    │ 20만원 저장             │   🔒 대기 중       │
│  T4    │ 🔓 작업 완료            │ 예금 20만원 확인   │
│  T5    │                        │ 5만원 입금 계산    │
│  T6    │                        │ 25만원 저장       │
└─────────────────────────────────────────────────────┘

💰 결과: 예상값 25만원 → 실제값 25만원 (정확!)
```

### 비원자적 연산의 위험성

**우리가 한 줄의 코드가 한 번의 명령어으로 처리되는지 생각해봐야 합니다**.

**코드에서 단순히 예금을 확인하고 그 예금에 원하는 금액을 더해서 저장합니다. 이러한 한 줄의 코드가 실제로는 메모리에서 값을 읽고 그 값을 다른 값으로 덮어쓰고 다시 저장한다와 같이 한 줄의 코드도 최소 3번 이상의 명령으로 처리됩니다**.

```
고수준 코드 vs 저수준 명령어

Java 코드 (한 줄):
balance += depositAmount;

실제 CPU 명령어 (최소 3단계):
┌─────────────────────────────────────────────────────┐
│  1️⃣ LOAD R1, [balance_address]                     │
│     메모리에서 현재 잔액을 레지스터 R1에 로드        │
│     CPU 사이클: 100~300 (RAM 접근 시간)             │
│                                                     │
│  2️⃣ ADD R1, R1, depositAmount                      │
│     R1 = R1 + depositAmount (레지스터 내 연산)      │
│     CPU 사이클: 1 (매우 빠름)                       │
│                                                     │
│  3️⃣ STORE [balance_address], R1                    │
│     계산된 결과를 다시 메모리에 저장                │
│     CPU 사이클: 100~300 (RAM 접근 시간)             │
└─────────────────────────────────────────────────────┘

⚠️ 위험 지점: 각 단계 사이에 다른 스레드가 끼어들 수 있음!

시나리오: 두 스레드가 동시에 balance += 1000 실행
┌─────────────────────────────────────────────────────┐
│  시간  │ 스레드 A        │ 스레드 B        │ balance │
│  ──────┼────────────────┼────────────────┼────────│
│  T1    │LOAD R1,[bal]   │                │ 10000  │
│        │R1 = 10000      │                │        │
│  T2    │                │LOAD R2,[bal]   │ 10000  │
│        │                │R2 = 10000      │        │
│  T3    │ADD R1,1000     │                │ 10000  │
│        │R1 = 11000      │                │        │
│  T4    │                │ADD R2,1000     │ 10000  │
│        │                │R2 = 11000      │        │
│  T5    │STORE [bal],R1  │                │ 11000  │
│  T6    │                │STORE [bal],R2  │ 11000  │← 덮어씀!
└─────────────────────────────────────────────────────┘

결과: 20000이 되어야 하는데 11000이 됨!
```

### 원자성(Atomicity)과 컴파일러 최적화

**우리가 작성한 이 코드가 명령 한 번에 처리된다는 보장할 수 있느냐 즉, 우리가 작성한 코드가 원자성이 보장되지 않는다면 중간에 다른 처리가 발생할 수 있다는 말과 같습니다**. **또한 실제 작성된 코드도 컴파일 시 최적화를 통해 실제 실행 순서에 약간의 차이가 존재할 수도 있습니다**.

컴파일러 최적화의 예상치 못한 결과:

```java

// **원본 코드:**

int flag = 0;
int data = 0;

void producer() {
    data = 42;        // 1. 데이터 먼저 설정
    flag = 1;         // 2. 플래그로 완료 신호
}

void consumer() {
    while (flag == 0) {
        // 플래그가 설정될 때까지 대기
    }
    printf("Data: %d\n", data);  // 3. 데이터 읽기
}

//컴파일러 최적화 후 (가능한 결과):
void producer() {
    flag = 1;         // ⚠️ 순서 바뀜!
    data = 42;        // 컴파일러가 성능상 이유로 재배열
}
```

```
문제 상황:
┌─────────────────────────────────────────────────────┐
│  T1: Producer가 flag = 1 실행                       │
│  T2: Consumer가 flag == 1 확인하고 루프 탈출        │
│  T3: Consumer가 data 읽기 → 아직 42가 아닌 0!      │
│  T4: Producer가 data = 42 실행 (너무 늦음)          │
└─────────────────────────────────────────────────────┘

해결책: volatile 키워드나 메모리 배리어 사용
volatile int flag = 0;
volatile int data = 0;
```

### 공유 자원의 종류

**그래서 이 공유 자원은 보통 메모리와 파일 정도가 흔히 만날 수 있는 공유 자원에 속합니다**.

```
공유 자원의 분류

💾 메모리 기반 공유 자원:
┌─────────────────────────────────────────────────────┐
│  • 전역 변수 (Global Variables)                     │
│    static int counter = 0;                          │
│                                                     │
│  • 동적 할당 메모리 (Heap Memory)                   │
│    int* shared_data = malloc(sizeof(int));          │
│                                                     │
│  • 공유 메모리 (Shared Memory)                      │
│    shmget(), shmat() 등으로 생성                    │
│                                                     │
│  • 스태틱 변수 (Static Variables)                   │
│    함수 내부의 static 변수들                        │
└─────────────────────────────────────────────────────┘

📁 파일 기반 공유 자원:
┌─────────────────────────────────────────────────────┐
│  • 일반 파일 (Regular Files)                        │
│    여러 프로세스가 동시에 읽기/쓰기                  │
│                                                     │
│  • 로그 파일 (Log Files)                           │
│    여러 모듈이 동시에 로그 기록                      │
│                                                     │
│  • 설정 파일 (Configuration Files)                  │
│    런타임에 설정 변경 시 충돌 가능                   │
│                                                     │
│  • 데이터베이스 파일                                │
│    SQLite 등 파일 기반 DB의 동시 접근               │
└─────────────────────────────────────────────────────┘

🔧 시스템 자원:
┌─────────────────────────────────────────────────────┐
│  • 네트워크 포트 (Network Ports)                    │
│    같은 포트에 여러 프로세스가 바인딩 시도           │
│                                                     │
│  • 하드웨어 장치 (Hardware Devices)                 │
│    프린터, 사운드 카드 등의 독점적 사용              │
│                                                     │
│  • 시스템 리소스 (System Resources)                 │
│    파일 핸들, 메모리 풀, 스레드 풀                  │
└─────────────────────────────────────────────────────┘
```

### 임계 구역(Critical Section)과 동기화

**그래서 이렇게 동시적으로 접근하는 자원에 대해서 원자성을 보장하여 동시적 처리가 안 되게 방지하여 예상되는 문제를 사전에 차단해야 합니다**.

**그렇다면 우리가 작성한 코드가 있다면 특정한 코드가 다른 실행 흐름 즉 스레드의 개입으로 인하여 값이 변질될 가능성이 존재한다면 그 코드가 시작되는 처음과 끝에 Lock, UnLock을 통하여 원자성을 보장해야 합니다**.

```java
// ❌ 동기화되지 않은 위험한 코드
public class UnsafeBankAccount {
    private int balance = 100000;  // 공유 자원
    
    public void deposit(int amount) {
        // 임계 구역 시작 (동기화 없음 - 위험!)*
        int currentBalance = balance;      // 1. 읽기
        int newBalance = currentBalance + amount;  // 2. 계산
        balance = newBalance;              // 3. 쓰기// 임계 구역 끝
        
        System.out.println("입금 완료: " + amount + ", 잔액: " + balance);
    }
}

// ✅ 동기화된 안전한 코드
public class SafeBankAccount {
    private int balance = 100000;
    private final Object lock = new Object();  // 락 객체
    
    public void deposit(int amount) {
        synchronized (lock) {  // 🔒 Lock 획득// ===== 임계 구역 시작 =====
            int currentBalance = balance;
            
            // 시뮬레이션: 다른 작업으로 인한 지연
            try {
                Thread.sleep(1);  // 1ms 지연
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            int newBalance = currentBalance + amount;
            balance = newBalance;
            // ===== 임계 구역 끝 =====
        }  // 🔓 Lock 자동 해제
        
        System.out.println("입금 완료: " + amount + ", 잔액: " + balance);
    }
    
    public synchronized int getBalance() {  // 메서드 전체 동기화
        return balance;
    }
}

// 테스트 코드
public class BankTest {
    public static void main(String[] args) throws InterruptedException {
        SafeBankAccount account = new SafeBankAccount();
        
        // 5개 스레드가 동시에 10만원씩 입금
        Thread[] threads = new Thread[5];
        for (int i = 0; i < 5; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                account.deposit(100000);
                System.out.println("스레드 " + threadId + " 완료");
            });
        }
        
        // 모든 스레드 시작
        for (Thread thread : threads) {
            thread.start();
        }
        
        // 모든 스레드 완료 대기
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("최종 잔액: " + account.getBalance());
        System.out.println("예상 잔액: " + (100000 + 5 * 100000));
    }
}
```

### 임계 구역 최소화의 중요성

**이렇게 공유 자원에 대한 경쟁 조건이 발생하는 임계 구간에 대해 어느 구간을 언제 어떤 조건일 때 임계 구간으로 설정할지에 대해서는 완벽하게 경험에 의존하지만 확실한 것은 이 임계 구간은 반드시 최소화해야 합니다**.

```java
// ❌ 나쁜 예: 임계 구역이 너무 큼
public class BadExample {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void processData() {
        synchronized (lock) {  // 🔒 락 획득// === 불필요하게 긴 임계 구역 ===
            
            // 1. 네트워크 호출 (수백 밀리초 소요)
            String data = fetchDataFromServer();  // ❌ 락 안에서 느린 작업
            
            // 2. 복잡한 계산 (수십 밀리초 소요)
            String processed = processComplexAlgorithm(data);  // ❌ 락 안에서 무거운 연산
            
            // 3. 파일 I/O (수십 밀리초 소요)*
            writeToFile(processed);  // ❌ 락 안에서 I/O 작업
            
            // 4. 실제로 보호해야 할 공유 자원 접근
            counter++;  // ✅ 정말 필요한 부분 (1 마이크로초)
            
            // === 임계 구역 끝 ===*
        }  // 🔓 락 해제 (전체 시간: 수백 밀리초)
    }
}

// ✅ 좋은 예: 임계 구역 최소화
public class GoodExample {
    private int counter = 0;
    private final Object lock = new Object();
    
    public void processData() {
        // 락 외부에서 느린 작업들 수행
        String data = fetchDataFromServer();      // 락 없이 실행
        String processed = processComplexAlgorithm(data);  // 락 없이 실행
        writeToFile(processed);                   // 락 없이 실행
        
        // 최소한의 임계 구역
        synchronized (lock) {  // 🔒 락 획득
            counter++;  // 정말 필요한 부분만 보호 (1 마이크로초)
        }  // 🔓 락 해제 (전체 락 시간: 1 마이크로초)
    }
}
```

### 임계 구역 설계 원칙

```
임계 구역 최소화 전략

1️⃣ 사전 준비 (Pre-computation)
┌─────────────────────────────────────────────────────┐
│  락 획득 전에 가능한 모든 계산을 미리 수행           │
│                                                     │
│  // 락 외부에서 준비                                │
│  int newValue = expensiveCalculation();             │
│  String formattedData = formatData(rawData);        │
│                                                     │
│  synchronized (lock) {                              │
│      // 락 내부에서는 최소한의 작업만               │
│      sharedResource = newValue;                     │
│  }                                                  │
└─────────────────────────────────────────────────────┘

2️⃣ 지역 변수 활용 (Local Variable Usage)
┌─────────────────────────────────────────────────────┐
│  공유 자원을 지역 변수로 복사해서 작업               │
│                                                     │
│  int localCopy;                                     │
│  synchronized (lock) {                              │
│      localCopy = sharedData;  // 빠른 복사          │
│  }                                                  │
│                                                     │
│  // 락 외부에서 복잡한 작업                         │
│  int result = heavyProcessing(localCopy);           │
│                                                     │
│  synchronized (lock) {                              │
│      sharedData = result;  // 빠른 업데이트         │
│  }                                                  │
└─────────────────────────────────────────────────────┘

3️⃣ 읽기-수정-쓰기 최적화
┌─────────────────────────────────────────────────────┐
│  // ❌ 비효율적                                    │
│  synchronized (lock) {                              │
│      for (int i = 0; i < 1000; i++) {              │
│          counter++;  // 1000번의 락 경합            │
│      }                                              │
│  }                                                  │
│                                                     │
│  // ✅ 효율적                                      │
│  int increment = 1000;  // 미리 계산               │
│  synchronized (lock) {                              │
│      counter += increment;  // 한 번의 락 경합      │
│  }                                                  │
└─────────────────────────────────────────────────────┘

4️⃣ 세밀한 락 사용 (Fine-grained Locking)
┌─────────────────────────────────────────────────────┐
│  // ❌ 하나의 큰 락                                │
│  private final Object bigLock = new Object();      │
│                                                     │
│  synchronized (bigLock) {                           │
│      accountA.withdraw(100);                        │
│      accountB.deposit(100);                         │
│  }                                                  │
│                                                     │
│  // ✅ 여러 개의 작은 락                           │
│  synchronized (accountA.getLock()) {                │
│      accountA.withdraw(100);                        │
│  }                                                  │
│  synchronized (accountB.getLock()) {                │
│      accountB.deposit(100);                         │
│  }                                                  │
└─────────────────────────────────────────────────────┘
```

### 성능 영향 분석

```
임계 구역 크기별 성능 비교

임계 구역 시간: 1ms (긴 임계 구역)
┌─────────────────────────────────────────────────────┐
│  10개 스레드 실행 시:                               │
│  스레드 1: 대기 0ms + 실행 1ms = 1ms                │
│  스레드 2: 대기 1ms + 실행 1ms = 2ms                │
│  스레드 3: 대기 2ms + 실행 1ms = 3ms                │
│  ...                                                │
│  스레드 10: 대기 9ms + 실행 1ms = 10ms              │
│                                                     │
│  총 처리 시간: 10ms                                 │
│  평균 대기 시간: 4.5ms                              │
│  처리량: 1000 ops/sec                               │
└─────────────────────────────────────────────────────┘

임계 구역 시간: 0.01ms (짧은 임계 구역)
┌─────────────────────────────────────────────────────┐
│  10개 스레드 실행 시:                               │
│  스레드 1: 대기 0ms + 실행 0.01ms = 0.01ms          │
│  스레드 2: 대기 0.01ms + 실행 0.01ms = 0.02ms       │
│  스레드 3: 대기 0.02ms + 실행 0.01ms = 0.03ms       │
│  ...                                                │
│  스레드 10: 대기 0.09ms + 실행 0.01ms = 0.1ms       │
│                                                     │
│  총 처리 시간: 0.1ms                                │
│  평균 대기 시간: 0.045ms                            │
│  처리량: 100,000 ops/sec                            │
└─────────────────────────────────────────────────────┘

결론: 임계 구역을 1/100로 줄이면 처리량이 100배 향상!
```

이처럼 **임계 구역의 최소화는 단순한 최적화가 아니라 시스템 전체 성능을 좌우하는 핵심 요소**입니다. 경험 많은 개발자가 되기 위해서는 **어떤 코드가 정말로 동기화가 필요한지, 그리고 그 범위를 어떻게 최소화할지를 정확히 판단하는 능력**을 기르는 것이 중요하다.


## 임계구역 해결 방법

### 임계구역의 정의와 현실적 복잡성

**임계구역에 대한 정의부터 다시 언급하고 가자면 여러 프로세스(또는 스레드)가 동시에 접근해서는 안 되는 공유 자원(예: 데이터 구조, 메모리, 파일 등)에 접근하는 코드의 일부**를 말합니다.

**이 임계 구역을 어떻게 정하고 그 근거는 전적으로 경험에 의해서 정해집니다**. **또한 일반적인 해결방법은 대단히 일반적이고 실제로는 매우 특수한 상황인 경우가 많기에 일반적인 책에서 나오는 해결방법이 적용되지 않는 경우가 다반사**입니다.

**이론 vs 현실**

```
교과서적 임계구역:
┌─────────────────────────────────────────────────────┐
│  synchronized (lock) {                              │
│      counter++;  // 간단한 공유 변수 접근           │
│  }                                                  │
│                                                     │
│  특징:                                              │
│  • 명확한 시작과 끝                                 │
│  • 단순한 데이터 구조                               │
│  • 예측 가능한 실행 시간                            │
└─────────────────────────────────────────────────────┘

실제 업무의 임계구역:
┌─────────────────────────────────────────────────────┐
│  🌐 분산 시스템 환경                                │
│  • 네트워크 지연 (10ms ~ 1000ms)                   │
│  • 서버 간 데이터 동기화                            │
│  • 데이터베이스 트랜잭션                            │
│  • 캐시 무효화                                      │
│  • 로드 밸런서를 통한 요청 분산                     │
│                                                     │
│  🔧 복잡한 비즈니스 로직                            │
│  • 다단계 검증 과정                                 │
│  • 외부 API 호출                                   │
│  • 파일 시스템 접근                                 │
│  • 이메일/알림 발송                                │
│                                                     │
│  ❓ 어디서부터 어디까지가 임계구역인가?             │
└─────────────────────────────────────────────────────┘`
```

**실제 업무 시나리오: UI-서비스-DB 아키텍처**

만약에 UI에서 조회 추가 삭제가 있고 이를 특정 백엔드 서버에서 특정 서비스로 실행한다고 가정했을 때 이 서비스는 다시 DB 서버에서 데이터를 가져옵니다.

```
🏗️ 3계층 아키텍처에서의 동시성 문제

          UI (React/Vue)
             ↕ HTTP
       백엔드 서비스 (Spring)
             ↕ SQL
         DB 서버 (MySQL)

실제 시나리오:
┌─────────────────────────────────────────────────────┐
│  👤 사용자 A: "주소록에서 김철수 삭제" 버튼 클릭     │
│  👤 사용자 B: "김철수 정보 수정" 화면에서 저장 버튼   │
│                                                     │
│  타이밍:                                            │
│  T1: 사용자 A → DELETE 요청 전송                    │
│  T2: 사용자 B → UPDATE 요청 전송 (거의 동시)        │
│  T3: 서버에서 DELETE 처리 시작                      │
│  T4: 서버에서 UPDATE 처리 시작                      │
│                                                     │
│  ❓ 결과: 김철수 데이터는 삭제? 수정? 아니면 오류?   │
└─────────────────────────────────────────────────────┘`
```

**이때 DB 서버에 데이터를 요청하고 응답을 받는 Network I/O가 발생합니다**. **기본적으로 이 Network I/O는 비동기로 처리됩니다**. **이 GUI 화면이 어떤 스레드 A가 실행하고 이 서비스에서 데이터를 가져오는 작업 역시 다른 스레드 B가 처리하게 됩니다**. **그러면 이 GUI와 서비스는 동시성을 가지게 됩니다**.

**이때 이 네트워크라는 것은 어쩔 때는 되다가 특정 상황에는 안 될 수도 있습니다**. **그래서 이 네트워크라는 녀석은 비동기에 불안정성까지도 가지고 있습니다**.

```
네트워크 I/O의 복잡성

정상적인 흐름:
┌─────────────────────────────────────────────────────┐
│  UI 스레드                 서비스 스레드              │
│  ┌─────────────┐         ┌─────────────┐           │
│  │1. 삭제 요청  │────────→│3. DB에 DELETE│           │
│  │2. 화면 업데이트│        │4. 응답 200 OK│           │
│  │   (로딩...)  │←────────│5. 완료 알림   │           │
│  └─────────────┘         └─────────────┘           │
│  총 소요시간: 200ms (예측 가능)                      │
└─────────────────────────────────────────────────────┘

문제가 발생하는 흐름:
┌─────────────────────────────────────────────────────┐
│  UI 스레드                 서비스 스레드              │
│  ┌─────────────┐         ┌─────────────┐           │
│  │1. 삭제 요청  │────────→│3. DB에 DELETE│           │
│  │2. 화면 업데이트│        │4. ⏰ 네트워크 │           │
│  │   (로딩...)  │         │   타임아웃!   │           │
│  │6. ❓ 삭제됨? │         │5. 재시도 시도 │           │
│  │   안됨?      │←────────│   또는 실패   │           │
│  └─────────────┘         └─────────────┘           │
│  소요시간: 30초+ (예측 불가능)                       │
│                                                     │
│  💥 이 사이에 다른 사용자가 같은 데이터 조회/수정    │
└─────────────────────────────────────────────────────┘
```

### 전역 자료구조에서의 임계구역

**그래서 임계 구역이라고 하면 전역 자료구조 예를 들어 주소록이 있다고 한다면 새로운 데이터를 추가할 수도 있고 삭제할 수도 있고 단순 데이터를 읽을 수도 있습니다**(전체 검색). **만약 전체 검색이 발생하는 와중에 해당 주소록에 데이터가 추가되거나 삭제된다면 데이터가 엉킬 수가 있습니다**.

java

```java
// 전역 자료구조 예시
public class ContactManager {
    // 공유 자원 - 모든 스레드가 접근 가능
    private List<Contact> contactList = new ArrayList<>();
    private Map<String, Contact> contactIndex = new HashMap<>();
    
    // ❌ 동기화되지 않은 위험한 메서드들
    public void addContact(Contact contact) {
        // 임계구역 1: 리스트와 인덱스 동시 수정
        contactList.add(contact);           // A 지점// 만약 여기서 다른 스레드가 전체 검색하면?
        contactIndex.put(contact.getName(), contact);  // B 지점
    }
    
    public void removeContact(String name) {
        // 임계구역 2: 삭제 과정
        Contact contact = contactIndex.get(name);      // C 지점
        if (contact != null) {
            contactList.remove(contact);               // D 지점
            contactIndex.remove(name);                 // E 지점
        }
    }
    
    public List<Contact> searchAll() {
        // 임계구역 3: 전체 검색
        List<Contact> result = new ArrayList<>();
        for (Contact contact : contactList) {         // F 지점// 만약 여기서 다른 스레드가 삭제하면?
            result.add(contact.clone());              // G 지점
        }
        return result;
    }
}
```

```
*문제 시나리오*
┌─────────────────────────────────────────────────────┐
│  시간  │ 스레드 A (검색)      │ 스레드 B (삭제)     │
│  ──────┼─────────────────────┼────────────────────│
│  T1    │ searchAll() 시작     │                    │
│  T2    │ F: 리스트 순회 중... │ removeContact()    │
│  T3    │ G: contact1 복사     │ D: contact2 삭제   │
│  T4    │ G: contact2 복사 시도│ E: 인덱스에서 제거 │
│  T5    │ 💥 NullPointer!     │ 삭제 완료          │
└─────────────────────────────────────────────────────┘
```

### 기본적인 동기화 기법들

이런 문제들을 해결하기 위해 다양한 동기화 기법들이 개발되었습니다. 각각의 특성과 한계를 살펴보겠습니다.

### 1️⃣ Mutex (뮤텍스) - 상호 배제

**Mutex는 한 번에 하나의 스레드만 임계구역에 접근할 수 있게 하는 가장 기본적인 동기화 기법**입니다.

```java
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
    private int bankBalance = 100000;  // 공유 자원: 은행 잔액
    private final ReentrantLock mutex = new ReentrantLock();  // 뮤텍스
    
    public void withdraw(int amount) {
        mutex.lock();  // 🔒 뮤텍스 획득 (한 번에 하나의 스레드만)
        try {
            System.out.println(Thread.currentThread().getName() + 
                             " - 출금 시도: " + amount);
            
            // === 임계 구역 시작 ===*
            if (bankBalance >= amount) {
                Thread.sleep(100);  // 네트워크 지연 시뮬레이션
                bankBalance -= amount;
                System.out.println("출금 성공! 잔액: " + bankBalance);
            } else {
                System.out.println("잔액 부족!");
            }
            // === 임계 구역 끝 ===
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            mutex.unlock();  // 🔓 뮤텍스 해제
        }
    }
}
```

**장점**: 단순하고 명확한 상호 배제
**단점**: 한 번에 하나의 스레드만 접근 가능해서 병렬성 제한

### 2️⃣ Semaphore (세마포어) - 자원 개수 제한

**Semaphore는 동시에 접근할 수 있는 스레드의 개수를 제한**합니다.

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    // 최대 3개의 스레드만 동시에 DB 연결 가능
    private final Semaphore dbConnectionPool = new Semaphore(3);
    
    public void accessDatabase() {
        try {
            System.out.println(Thread.currentThread().getName() + 
                             " - DB 연결 대기 중...");
            
            dbConnectionPool.acquire();  // 🎫 허가증 획득 (카운트 -1)
            System.out.println(Thread.currentThread().getName() + 
                             " - DB 연결 성공! (남은 연결: " + 
                             dbConnectionPool.availablePermits() + ")");
            
            // === 제한된 자원 사용 ===
            Thread.sleep(2000);  // DB 작업 시뮬레이션
            System.out.println(Thread.currentThread().getName() + 
                             " - DB 작업 완료");
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            dbConnectionPool.release();  // 🎫 허가증 반납 (카운트 +1)
            System.out.println(Thread.currentThread().getName() + 
                             " - DB 연결 해제");
        }
    }
}
```

**장점**: 제한된 자원을 여러 스레드가 공유 가능
**단점**: 자원 개수 관리가 복잡하고, 여전히 경쟁 조건 발생 가능

### 3️⃣ 조건 변수 (Condition Variable) - 특정 조건 대기

**특정 조건이 만족될 때까지 스레드를 대기시키는 기법**입니다.

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ConditionExample {
    private int itemCount = 0;
    private final int MAX_ITEMS = 5;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();   // 버퍼가 가득 차지 않음
    private final Condition notEmpty = lock.newCondition();  // 버퍼가 비어있지 않음
    
    // Producer: 아이템 생산
    public void produce() throws InterruptedException {
        lock.lock();
        try {
            while (itemCount >= MAX_ITEMS) {
                System.out.println("버퍼 가득참 - Producer 대기");
                notFull.await();  // 버퍼에 공간이 생길 때까지 대기
            }
            
            itemCount++;
            System.out.println("아이템 생산! 현재 개수: " + itemCount);
            notEmpty.signal();  // Consumer에게 아이템이 있다고 신호
            
        } finally {
            lock.unlock();
        }
    }
    
    // Consumer: 아이템 소비
    public void consume() throws InterruptedException {
        lock.lock();
        try {
            while (itemCount <= 0) {
                System.out.println("버퍼 비어있음 - Consumer 대기");
                notEmpty.await();  // 아이템이 생길 때까지 대기
            }
            
            itemCount--;
            System.out.println("아이템 소비! 현재 개수: " + itemCount);
            notFull.signal();  // Producer에게 공간이 있다고 신호
            
        } finally {
            lock.unlock();
        }
    }
}
```

**장점**: 조건 기반의 정교한 동기화 가능
**단점**: 구현이 복잡하고 데드락 위험성 존재

### 4️⃣ 읽기-쓰기 락 (ReadWrite Lock) - 읽기 우선 최적화

**읽기 작업은 동시에 허용하고, 쓰기 작업만 독점적으로 실행하는 기법**입니다.

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockExample {
    private String sharedData = "초기 데이터";
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    
    // 읽기 작업 - 여러 스레드가 동시에 읽기 가능
    public String readData() {
        rwLock.readLock().lock();  // 🔍 읽기 락 획득
        try {
            System.out.println(Thread.currentThread().getName() + 
                             " - 데이터 읽기: " + sharedData);
            Thread.sleep(1000);  // 읽기 작업 시뮬레이션
            return sharedData;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        } finally {
            rwLock.readLock().unlock();  // 🔍 읽기 락 해제
        }
    }
    
    // 쓰기 작업 - 한 번에 하나의 스레드만 실행 가능
    public void writeData(String newData) {
        rwLock.writeLock().lock();  // ✏️ 쓰기 락 획득 (독점)
        try {
            System.out.println(Thread.currentThread().getName() + 
                             " - 데이터 쓰기 시작");
            Thread.sleep(500);  // 쓰기 작업 시뮬레이션
            sharedData = newData;
            System.out.println("데이터 업데이트 완료: " + sharedData);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            rwLock.writeLock().unlock();  // ✏️ 쓰기 락 해제
        }
    }
}
```

**장점**: 읽기 작업의 병렬성 극대화
**단점**: 쓰기 작업이 기아 상태에 빠질 위험

### 모니터(Monitor) 패턴과 큐 기반 동기화

**우리가 스레드 또는 프로세스가 동기화라고 하는 목표를 달성하기 위해서 항상 나오는 자료구조가 Queue**입니다.

### 모니터 패턴의 핵심 개념

```
모니터 구조

스레드 + 큐 + 모니터
┌─────────────────────────────────────────────────────┐
│                   Monitor                           │
│  ┌─────────────────────────────────────────────┐   │
│  │               Work Queue                    │   │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐          │   │
│  │  │Task1│ │Task2│ │Task3│ │Task4│ ← 외부 추가│   │
│  │  └─────┘ └─────┘ └─────┘ └─────┘          │   │
│  └─────────────────────────────────────────────┘   │
│                    ↑ poll()                        │
│  ┌─────────────────────────────────────────────┐   │
│  │          Worker Thread                      │   │
│  │  1. 큐에서 작업 꺼내기                      │   │
│  │  2. 작업 실행                               │   │
│  │  3. 다음 작업 대기                          │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

핵심 특징:
✅ 한 번에 하나의 스레드만 모니터 내부 접근
✅ 큐를 통한 순서 보장 (FIFO)
✅ wait/notify를 통한 효율적인 대기
✅ 임계구역 최소화 (큐 조작만 동기화)

**이러한 개념을 모니터라고 합니다**. **어떤 동기화 기법을 사용하든 결국 위의 구조가 핵심입니다**. **내부적으로 큐에 해야 될 일을 줄 세웁니다. 그리고 그걸 하나씩 꺼내서 처리합니다**.

이 패턴은 **Java의 synchronized, BlockingQueue, ExecutorService 등의 기반이 되는 핵심 동기화 메커니즘**이며, **실제 업무에서 마주치는 복잡한 동시성 문제를 해결하는 현실적이고 효과적인 방법**입니다.

```java
// 모니터 패턴 구현 예시
public class TaskProcessor {
    private final Queue<Task> taskQueue = new LinkedList<>();
    private final Object monitor = new Object();  // 모니터 객체
    private volatile boolean running = true;
    
    // 작업 추가 (Producer)
    public void addTask(Task task) {
        synchronized (monitor) {  // 🔒 모니터 진입
            taskQueue.offer(task);
            System.out.println("작업 추가: " + task.getId());
            monitor.notify();  // 대기 중인 스레드 깨우기
        }  // 🔓 모니터 해제
    }
    
    // 작업 처리 (Consumer)
    public void processTask() {
        while (running) {
            Task task = null;
            
            synchronized (monitor) {  // 🔒 모니터 진입
                while (taskQueue.isEmpty() && running) {
                    try {
                        System.out.println("작업 대기 중...");
                        monitor.wait();  // 큐가 비어있으면 대기
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (!taskQueue.isEmpty()) {
                    task = taskQueue.poll();  // 큐에서 작업 꺼내기
                }
            }  // 🔓 모니터 해제
            
            // 모니터 외부에서 실제 작업 수행 (임계구역 최소화)
            if (task != null) {
                executeTask(task);
            }
        }
    }
    
    private void executeTask(Task task) {
        System.out.println("작업 실행 시작: " + task.getId());
        // 실제 작업 수행 (시간이 오래 걸릴 수 있음)
        try {
            Thread.sleep(task.getDuration());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("작업 실행 완료: " + task.getId());
    }
    
    public void shutdown() {
        synchronized (monitor) {
            running = false;
            monitor.notifyAll();  // 모든 대기 스레드 깨우기
        }
    }
}

// 사용 예시
public class MonitorExample {
    public static void main(String[] args) throws InterruptedException {
        TaskProcessor processor = new TaskProcessor();
        
        // 작업 처리 스레드 시작
        Thread workerThread = new Thread(processor::processTask);
        workerThread.start();
        
        // 작업 추가 스레드들 시작
        Thread[] producers = new Thread[3];
        for (int i = 0; i < 3; i++) {
            final int producerId = i;
            producers[i] = new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    Task task = new Task("P" + producerId + "-T" + j, 1000);
                    processor.addTask(task);
                    
                    try {
                        Thread.sleep(500);  // 0.5초마다 작업 추가
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            });
            producers[i].start();
        }
        
        // 10초 후 종료
        Thread.sleep(10000);
        processor.shutdown();
        
        workerThread.join();
        for (Thread producer : producers) {
            producer.join();
        }
        
        System.out.println("모든 작업 완료");
    }
}
```


### 대충 넘어가는 교착 상태

### 데드락의 4가지 필요 조건

데드락이 발생하려면 다음 4가지 조건이 **모두** 충족되어야 합니다:

**1. 비선점(Non-preemption)**: **어떤 자원에 대해 프로세스나 스레드가 점유한 후 그 점유한 자원을 계속 가지고 있는 상태**

```
화장실 데드락 시나리오

스레드 A: 화장실 문 잠그고 들어감 → 휴지 없음을 발견 → 휴지 대기
스레드 B: 휴지 가지고 있음 → 화장실 들어가려 함 → 문 잠겨서 대기

┌─────────────────────────────────────────────────────┐
│  🚽 화장실 (임계구역)                               │
│  ┌─────────────────────────────────────────────┐   │
│  │ 👨 스레드 A                                 │   │
│  │ "휴지가 없어... 누가 가져다줄 때까지 기다려"  │   │
│  │ 🔒 문은 계속 잠긴 상태 (비선점)             │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                    ↑ 들어가려 함
┌─────────────────────────────────────────────────────┐
│  👩 스레드 B                                        │
│  🧻 휴지 들고 있음                                  │
│  "화장실 문이 잠겨있어... 언제 열릴지 모르겠네"      │
└─────────────────────────────────────────────────────┘

결과: 무한 대기!
```

**2. 점유와 대기(Hold and Wait)**: **특정 공유 자원에 대해서 한 스레드가 점유하면 다른 스레드는 사용하기까지 대기한다**

**3. 원형 대기(Circular Wait)**: 스레드들이 서로의 자원을 원형으로 기다리는 상태

**4. 상호 배제(Mutual Exclusion)**: 한 번에 하나의 스레드만 자원 사용 가능

### 데드락의 정의와 현상

**데드락(Deadlock, 교착상태)이란 컴퓨터 시스템에서 둘 이상의 프로세스(또는 스레드)가 서로가 가지고 있는 자원을 요청하며 무한 대기 상태에 빠지는 현상**입니다.

```java
// 전형적인 데드락 예시
public class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {          // 스레드 A가 lock1 획득
            System.out.println("Thread A: lock1 획득");
            
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            
            synchronized (lock2) {      // 스레드 A가 lock2 요청 (대기)
                System.out.println("Thread A: lock2도 획득!");
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {          // 스레드 B가 lock2 획득
            System.out.println("Thread B: lock2 획득");
            
            try { Thread.sleep(100); } catch (InterruptedException e) {}
            
            synchronized (lock1) {      // 스레드 B가 lock1 요청 (대기)
                System.out.println("Thread B: lock1도 획득!");
            }
        }
    }
}

// 실행 결과:// Thread A: lock1 획득// Thread B: lock2 획득// ... (무한 대기)
```

**프로세스의 스레드 1,2가 하나의 공유 자원에 대해 접근할 때 경쟁 조건이 발생하면서 이때 이 자원에 대해 락을 걸고 임계영역을 수행한다. 이때 점유한 스레드가 락을 해제하지 않는다면 대기하는 스레드들은 무한적 대기 상태에 빠지게 됩니다**.

### 데드락 감지와 해결 방법

**이러한 데드락을 방지하기 위해서는 공유 자원에 다른 하나의 스레드가 접근하는 스레드 1,2에 대한 상태를 감시해서 스레드들이 지속적으로 wait 상태에 빠지는 것이 있는지, 얼마나 오래 대기 상태에 있는지를 감시합니다**.

```java
// 데드락 감지 및 해결 예시
public class DeadlockDetector {
    private final Map<Thread, List<Object>> heldLocks = new ConcurrentHashMap<>();
    private final Map<Thread, Object> waitingFor = new ConcurrentHashMap<>();
    private final ScheduledExecutorService detector = 
        Executors.newScheduledThreadPool(1);
    
    public DeadlockDetector() {
        // 5초마다 데드락 검사
        detector.scheduleAtFixedRate(this::detectDeadlock, 5, 5, TimeUnit.SECONDS);
    }
    
    private void detectDeadlock() {
        System.out.println("=== 데드락 검사 시작 ===");
        
        for (Thread thread : heldLocks.keySet()) {
            if (thread.getState() == Thread.State.BLOCKED) {
                long waitTime = getWaitTime(thread);
                
                System.out.println(thread.getName() + " - 대기 시간: " + 
                                 waitTime + "ms, 상태: " + thread.getState());
                
                // 10초 이상 대기 중인 스레드 발견
                if (waitTime > 10000) {
                    System.out.println("⚠️ 데드락 의심: " + thread.getName());
                    handleDeadlock(thread);
                }
            }
        }
    }
    
    private void handleDeadlock(Thread suspectedThread) {
        System.out.println("🚨 데드락 해결 시도: " + suspectedThread.getName() + " 종료");
        
        // 메모리 덤프 생성 (실제로는 더 복잡한 구현 필요)
        generateMemoryDump(suspectedThread);
        
        // 스레드 강제 종료
        suspectedThread.interrupt();
        
        // 새로운 스레드로 재시작
        restartThread(suspectedThread);
    }
    
    private void generateMemoryDump(Thread thread) {
        System.out.println("📊 메모리 덤프 생성: " + thread.getName());
        
        // 스택 트레이스 출력
        StackTraceElement[] stackTrace = thread.getStackTrace();
        System.out.println("Call Stack 분석:");
        for (StackTraceElement element : stackTrace) {
            System.out.println("  " + element.toString());
        }
        
        // 어떤 락을 기다리고 있는지 분석
        Object waitingLock = waitingFor.get(thread);
        if (waitingLock != null) {
            System.out.println("대기 중인 락: " + waitingLock.getClass().getSimpleName());
        }
    }
}
```

**이런 상황이 발생할 때 가장 간단한 방법은 대기 상태에 빠져있는 스레드들을 제거하면 됩니다**. **종료시킨 스레드를 감시하는 스레드가 재실행시킴으로써 해결할 수 있습니다**. **그래서 종료된 스레드의 메모리 Dump를 통해서 스레드가 가지고 있는 Call Stack을 확인하여 스레드가 어떤 작업을 하다가 대기 상태에 빠지게 됐는지 분석하면 됩니다**.

### 메모리 덤프(Memory Dump)란?

**메모리 덤프는 특정 시점에서 프로세스나 스레드의 메모리 상태를 파일로 저장한 것**입니다. 여기에는 다음 정보들이 포함됩니다:

📊 ``메모리 덤프 구성 요소
1. 스택 프레임 (Stack Frames)
   • 함수 호출 순서
   • 지역 변수 값들
   • 매개변수 정보

2. 레지스터 상태
   • CPU 레지스터 값들
   • 프로그램 카운터(PC)
   • 스택 포인터(SP)

3. 힙 메모리 상태
   • 동적 할당된 객체들
   • 객체 간 참조 관계

4. 스레드 상태 정보
   • 현재 실행 상태
   • 대기 중인 락 정보
   • 스레드 ID와 우선순위

### 프로세스 레벨의 데드락

**이러한 교착 상태를 스레드 레벨에서 프로세스 레벨까지 생각해보면** 더 복잡한 상황이 발생합니다.

```
🖨️ 프로세스 레벨 데드락 시나리오

     P1, P2, P3 (프로세스들)
        ↓
User   File (파일 자원)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Kernel Mode (시스템 호출)
        ↓
S/W    Device Driver
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
H/W    Printer (물리적 프린터)
```

**만약에 위 그림처럼 프로세스 1번이 파일을 통해 커널 모드로 진입하여 프린터라는 자원을 사용하려고 할 때 프로세스 1이 파일을 open하는 순간 해당 파일에 락을 걸게 됩니다**. **이 말은 즉 다른 프로세스 2,3번은 접근이 불가능하다는 의미입니다**.

```java
// 프로세스 레벨 데드락 시뮬레이션
public class ProcessLevelDeadlock {
    // 커널 오브젝트 시뮬레이션
    private final Object fileResource = new Object();    // 파일 자원
    private final Object printerResource = new Object(); // 프린터 자원
    
    // 프로세스 1 시뮬레이션
    public void process1() {
        try {
            synchronized (fileResource) {  // 파일 락 획득
                System.out.println("프로세스 1: 파일 오픈 완료");
                
                // 100장 프린트 작업 시작
                synchronized (printerResource) {
                    System.out.println("프로세스 1: 프린터 획득, 100장 인쇄 시작");
                    
                    for (int i = 1; i <= 100; i++) {
                        System.out.println("프린트 중... " + i + "/100");
                        Thread.sleep(100);  // 인쇄 시간
                        
                        // 50장 인쇄 후 강제 중단 시뮬레이션
                        if (i == 50) {
                            System.out.println("💥 프로세스 1: 50장 인쇄 후 비정상 종료!");
                            // 프로세스가 비정상 종료되면서 락을 해제하지 못함
                            throw new RuntimeException("Process crashed!");
                        }
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("프로세스 1 오류: " + e.getMessage());
            // 비정상 종료로 인해 락이 해제되지 않음!
        }
    }
    
    // 프로세스 2,3 시뮬레이션 (대기 상태)
    public void process2() {
        System.out.println("프로세스 2: 프린터 사용 대기 중...");
        synchronized (printerResource) {  // 무한 대기!
            System.out.println("프로세스 2: 프린터 획득 (실행되지 않음)");
        }
    }
}
```

**이때 프로세스 1이 100장을 프린트하고 있다가 50장을 프린트하는 시점에서 프로세스 1이 중단되었다면 이 프린터를 사용하려는 다른 프로세스들이 대기 상태에 빠지게 됩니다**. **즉, 사용하지 못하는 자원이 됩니다**.

### 커널 오브젝트 동기화와 타임아웃

**그래서 이러한 커널 오브젝트에 대한 동기화를 할 때 보통 뮤텍스를 사용하고 점유하려는 프로세스들은 진입 시에 타임을 명시합니다**.

```java
// 타임아웃을 이용한 데드락 방지
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class TimeoutBasedDeadlockPrevention {
    private final ReentrantLock fileResource = new ReentrantLock();
    private final ReentrantLock printerResource = new ReentrantLock();
    
    public void safeProcess1() {
        boolean fileAcquired = false;
        boolean printerAcquired = false;
        
        try {
            // 파일 자원 획득 시도 (최대 5초 대기)
            fileAcquired = fileResource.tryLock(5, TimeUnit.SECONDS);
            if (!fileAcquired) {
                System.out.println("프로세스 1: 파일 락 획득 실패 (타임아웃)");
                return;
            }
            
            System.out.println("프로세스 1: 파일 락 획득 성공");
            
            // 프린터 자원 획득 시도 (최대 3초 대기)
            printerAcquired = printerResource.tryLock(3, TimeUnit.SECONDS);
            if (!printerAcquired) {
                System.out.println("프로세스 1: 프린터 락 획득 실패 (타임아웃)");
                return;
            }
            
            System.out.println("프로세스 1: 프린터 락 획득 성공");
            
            // 실제 인쇄 작업
            performPrintJob();
            
        } catch (InterruptedException e) {
            System.out.println("프로세스 1: 인터럽트로 인한 종료");
            Thread.currentThread().interrupt();
        } finally {
            // 반드시 획득한 락들을 해제 (역순으로)
            if (printerAcquired) {
                printerResource.unlock();
                System.out.println("프로세스 1: 프린터 락 해제");
            }
            if (fileAcquired) {
                fileResource.unlock();
                System.out.println("프로세스 1: 파일 락 해제");
            }
        }
    }
    
    private void performPrintJob() throws InterruptedException {
        for (int i = 1; i <= 100; i++) {
            System.out.println("안전한 인쇄: " + i + "/100");
            Thread.sleep(50);
            
            // 주기적으로 인터럽트 체크
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("인쇄 작업 중단 요청 받음");
                throw new InterruptedException("Print job interrupted");
            }
        }
    }
}
```

### 데드락 방지 전략 종합

🛡️ 데드락 방지 전략

1️⃣ 예방 (Prevention)
• 4가지 조건 중 하나라도 차단
• 자원 순서 지정 (Lock Ordering)
• 타임아웃 설정

2️⃣ 회피 (Avoidance)  
• 은행가 알고리즘
• 안전한 상태 유지

3️⃣ 탐지 (Detection)
• 주기적 데드락 검사
• 자원 할당 그래프 분석

4️⃣ 복구 (Recovery)
• 프로세스/스레드 강제 종료
• 자원 선점 및 재할당
• 체크포인트 복구

**실제 운영 환경에서는 타임아웃 기반의 예방 전략이 가장 실용적**이며, **메모리 덤프를 통한 사후 분석**으로 데드락의 근본 원인을 파악하여 시스템을 개선하는 것이 일반적인 접근법입니다.