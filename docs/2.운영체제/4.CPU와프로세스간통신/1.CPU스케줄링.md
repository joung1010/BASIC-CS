# CPU와 프로세스간 통신

## CPU 스케줄링

### 운영체제의 역할과 스케줄링의 본질

**OS도 하나의 프로세스로써 백그라운드에서 다른 프로세스들이 잘 동작하게 서포트해주는 역할**입니다. 하지만 OS는 특별한 권한을 가진 프로세스로, **커널 모드에서 실행되어 시스템 자원을 직접 제어**할 수 있습니다.

```
컴퓨터 시스템 = 레스토랑
┌─────────────────────────────────────────────────────┐
│                OS (레스토랑 매니저)                  │
│  ┌─────────────────────────────────────────────┐   │
│  │           스케줄러 (웨이터)                  │   │
│  │  - 테이블 배정 (CPU 할당)                   │   │
│  │  - 주문 관리 (프로세스 요청 처리)            │   │
│  │  - 대기열 관리 (Ready Queue)               │   │
│  └─────────────────────────────────────────────┘   │
│                                                     │
│  🍽️ CPU (주방/테이블)     👥 프로세스들 (손님들)    │
│  ┌─────┬─────┬─────┬─────┐  ┌─────────────────┐   │
│  │코어1│코어2│코어3│코어4│  │  대기 중인      │   │
│  └─────┴─────┴─────┴─────┘  │  프로세스들     │   │
│    ↑     ↑     ↑     ↑     └─────────────────┘   │
│  스레드 스레드 스레드 스레드                       │
└─────────────────────────────────────────────────────┘
```

**CPU의 스케줄링이라고 했을 때 프로세스를 손님이라고 가정했을 때 이 프로세스들이 CPU 자원을 소모**합니다. (정확하게는 프로세스 안에 있는 스레드들이) **즉, OS가 식당 매니저가 되어 프로세스 손님을 지정된 자리에 예약하고 주문을 도와주는** 역할을 합니다.

**운영체제 OS가 CPU 같은 전산 자원을 프로세스의 스레드들이 선점하여 사용할 수 있게 도와줍니다**.

### 3계층 스케줄링 시스템

**그래서 이 스케줄링을 할 때는 크게 3가지로 구분**합니다:

```
3계층 스케줄링 구조

🔝 Level 1: 고수준 스케줄링 (High-Level Scheduling)
┌─────────────────────────────────────────────────────┐
│  🏢 시스템 전체 관리 (식당 입장 관리)                │
│                                                     │
│  • 전체 시스템의 부하 상태 확인                      │
│  • 프로세스를 잡(Job) 단위로 묶어서 관리             │
│  • 메모리 부족 시 일부 프로세스를 디스크로 스왑       │
│  • 시스템 리소스 한계 내에서 프로세스 수 조절         │
│                                                     │
│  예시: "현재 메모리 사용률 90% → 신규 프로세스 대기"  │
└─────────────────────────────────────────────────────┘
                           ↓
🔄 Level 2: 중간 수준 스케줄링 (Medium-Level Scheduling)  
┌─────────────────────────────────────────────────────┐
│  🚪 대기실 관리 (식당 밖 대기 고객 관리)             │
│                                                     │
│  • Suspended 상태 프로세스 관리                      │
│  • 메모리 ↔ 디스크 간 스왑(Swap) 결정               │
│  • 시스템 부하에 따른 프로세스 활성화/비활성화        │
│  • Degree of Multiprogramming 조절                 │
│                                                     │
│  예시: "메모리 여유 생김 → 스왑된 프로세스 복귀"      │
└─────────────────────────────────────────────────────┘
                           ↓
⚡ Level 3: 저수준 스케줄링 (Low-Level Scheduling)
┌─────────────────────────────────────────────────────┐
│  🍽️ 테이블 서빙 관리 (실제 주문/서빙 순서 결정)      │
│                                                     │
│  • Ready → Running 상태 전환 결정                   │
│  • CPU 코어에 실제 스레드 할당                       │
│  • Time Slice 관리 (보통 10-100ms)                 │
│  • 우선순위 기반 스케줄링 수행                       │
│                                                     │
│  예시: "스레드A 10ms 실행 → 스레드B로 교체"          │
└─────────────────────────────────────────────────────┘
```

**고수준 스케줄링은 OS가 식당이면 손님 수를 조절**합니다. **저수준 스케줄링은 각 손님에 대한 주문과 요리 제공 순서를 미세하게 조정하는 단계**라고 볼 수 있습니다. **그러면 이때 중간 수준 스케줄링은 식당에 들어오지 못해서 밖에서 대기하고 있는 손님을 관리하는 것**이라고 보면 됩니다.

**이렇게 스케줄링을 하는 이유는 전체적인 시스템의 과부하를 막기 위해서**입니다.

### CPU 버스트와 I/O 버스트

프로세스의 동작을 이해하기 위해서는 **CPU 버스트(CPU Burst)와 I/O 버스트(I/O Burst)** 개념을 알아야 합니다.

```
`프로세스 실행 패턴 분석

CPU 집중적 프로세스 (CPU-bound):
CPU ████████████████████ I/O ██ CPU ████████████████████
 |     연산 작업 많음     | 짧은|    다시 연산 작업    |
 |   (수학 계산, 압축)    | I/O |                     |

I/O 집중적 프로세스 (I/O-bound):  
CPU ███ I/O ████████████ CPU ██ I/O ████████████ CPU ███
 |짧은|    파일 읽기     |짧은|    네트워크 통신   |짧은|
 |처리|   디스크 접근    |처리|      데이터베이스  |처리|

혼합형 프로세스 (일반적인 애플리케이션):
CPU ██████ I/O ██████ CPU ████ I/O ████ CPU ██████`

**각 프로세스 유형별 특성**:

`🔥 CPU 집중적 프로세스
┌─────────────────────────────────────┐
│  특징:                              │
│  • 긴 CPU 버스트 시간               │
│  • 짧고 드문 I/O 버스트             │
│  • 높은 CPU 사용률 요구             │
│                                     │
│  예시:                              │
│  • 과학 계산 프로그램               │
│  • 이미지/비디오 인코딩             │
│  • 압축/암호화 작업                 │
│  • 게임 엔진의 물리 연산            │
│                                     │
│  스케줄링 고려사항:                  │
│  • 낮은 우선순위 설정 고려          │
│  • 백그라운드에서 실행              │
│  • 긴 Time Slice 할당               │
└─────────────────────────────────────┘

💾 I/O 집중적 프로세스  
┌─────────────────────────────────────┐
│  특징:                              │
│  • 짧은 CPU 버스트 시간             │
│  • 빈번하고 긴 I/O 버스트           │
│  • 대부분 시간을 I/O 대기에 소모    │
│                                     │
│  예시:                              │
│  • 텍스트 에디터                    │
│  • 웹 브라우저                      │
│  • 데이터베이스 서버                │
│  • 파일 관리자                      │
│                                     │
│  스케줄링 고려사항:                  │
│  • 높은 우선순위 설정               │
│  • 빠른 응답성 중요                 │
│  • 짧은 Time Slice로도 충분         │
└─────────────────────────────────────┘`
```

### 선점형 vs 비선점형 스케줄링

**스케줄링 시 고려사항**으로 **선점형(Preemptive)과 비선점형(Non-Preemptive)** 방식이 있습니다.

```
선점형 스케줄링 (Preemptive)
┌─────────────────────────────────────────────────────┐
│  "OS가 강제로 CPU를 뺏을 수 있음"                    │
│                                                     │
│  시간 흐름: 0ms ──→ 10ms ──→ 20ms ──→ 30ms         │
│           ┌─────┐   ┌─────┐   ┌─────┐              │
│  프로세스A│█████│   │     │   │█████│              │
│           └─────┘   └─────┘   └─────┘              │
│           ┌─────┐   ┌─────┐   ┌─────┐              │
│  프로세스B│     │   │█████│   │     │              │
│           └─────┘   └─────┘   └─────┘              │
│                     ↑                               │
│                OS가 강제로                          │
│                CPU 뺏고 교체                        │
│                                                     │
│  장점: 응답성 좋음, 대화형 시스템에 적합              │
│  단점: 오버헤드 증가, 컨텍스트 스위칭 비용           │
│                                                     │
│  예시: Windows, Linux, macOS                       │
└─────────────────────────────────────────────────────┘

🔒 비선점형 스케줄링 (Non-Preemptive)
┌─────────────────────────────────────────────────────┐
│  "프로세스가 자발적으로 CPU를 반납할 때까지 대기"     │
│                                                     │
│  시간 흐름: 0ms ──────────→ 50ms ──────────→ 100ms  │
│           ┌─────────────────────┐   ┌──────────────┐│
│  프로세스A│████████████████████│   │              ││
│           └─────────────────────┘   └──────────────┘│
│           ┌─────────────────────┐   ┌──────────────┐│
│  프로세스B│      대기 중...     │   │██████████████││
│           └─────────────────────┘   └──────────────┘│
│                                 ↑                   │
│                        A가 자발적으로               │
│                        CPU 반납                     │
│                                                     │
│  장점: 오버헤드 적음, 처리량 많음                    │
│  단점: 응답시간 예측 어려움, 기아 현상 가능          │
│                                                     │
│  예시: 초기 MS-DOS, 배치 처리 시스템                │
└─────────────────────────────────────────────────────┘
```

**어떤 프로세스가 CPU 자원을 선점해서 사용하려고 하는데 이를 OS가 통제할 수 있는 경우**가 선점형이고, **어떤 프로세스가 CPU 자원을 선점해서 사용하고 있다면 해당 프로세스가 종료할 때까지 다른 프로세스들은 대기해야 하는 경우**가 비선점형입니다.

### 프로세스 우선순위 시스템

**그렇다면 우선순위는 어떻게 될까? 프로세스별 스레드별로 이 우선순위를 정할 수 있습니다**. **이 우선순위는 보통의 경우 5단계로 이루어져 있습니다**.

```
Windows 우선순위 체계 (5단계)

┌─────────────────────────────────────────────────────┐
│  ⚡ 실시간 (Realtime) - 우선순위 24-31              │
│     • 시스템 크리티컬 프로세스                       │
│     • 하드웨어 인터럽트 처리                         │
│     ⚠️  잘못 사용하면 시스템 멈춤                   │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  🔴 높음 (High) - 우선순위 13-15                   │
│     • 시스템 서비스                                 │
│     • 백신 프로그램                                 │
│     • 시스템 모니터링 도구                          │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  🟡 보통보다 높음 (Above Normal) - 우선순위 10-12   │
│     • 멀티미디어 애플리케이션                        │
│     • 게임 프로그램                                 │
│     • 실시간성이 중요한 앱                          │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  🟢 보통 (Normal) - 우선순위 6-10                  │
│     • 일반적인 사용자 애플리케이션                   │
│     • 웹 브라우저, 오피스 프로그램                   │
│     • 대부분의 GUI 프로그램                         │
│     ✅ 기본값 - 99%의 프로그램이 사용               │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  🔵 보통보다 낮음 (Below Normal) - 우선순위 4-6     │
│     • 백그라운드 동기화 프로그램                     │
│     • 인덱싱 서비스                                 │
│     • 자동 업데이트 프로그램                        │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  🟣 낮음 (Idle) - 우선순위 1-4                     │
│     • 화면 보호기                                   │
│     • 디스크 조각 모음                              │
│     • 압축/백업 프로그램                            │
│     • CPU 여유 시간에만 실행                        │
└─────────────────────────────────────────────────────┘
```

**일반적으로는 보통으로써 사용하고 예를 들어 아주 고해상도 동영상을 재생해야 하는 경우 그 미디어 플레이어를 아주 높음으로 설정하고 사용하면 동영상 자체는 잘 동작하지만 이 미디어 플레이어를 닫기조차 힘들 정도로 재생하는데 모든 자원을 사용하는 것을 확인할 수 있습니다**.

**우리가 압축 파일을 해제할 때 이 시간이 오래 걸린다면 우선순위를 가장 낮게 설정해서 스케줄링하면 다른 작업에 영향을 덜 주면서 압축을 해제할 수 있습니다**.

### 동적 우선순위 조정과 피드백

현대 운영체제는 **동적 우선순위(Dynamic Priority)** 시스템을 사용합니다:

```
동적 우선순위 조정 메커니즘

시간 경과에 따른 우선순위 변화:

프로세스 A (I/O 집중적):
초기: 우선순위 8 ──→ I/O 대기 발생 ──→ 우선순위 10 (상승)
                     "반응성 좋은 프로세스로 인식"

프로세스 B (CPU 집중적):  
초기: 우선순위 8 ──→ CPU 장시간 사용 ──→ 우선순위 6 (하락)
                     "CPU 독점 방지"

프로세스 C (기아 상태):
초기: 우선순위 4 ──→ 장시간 대기 ──→ 우선순위 7 (상승)
                     "기아 현상 방지 (Aging 기법)"
```

### 전면 프로세스 vs 백그라운드 프로세스

**그래서 이러한 작업을 백그라운드에서 동작하게 하고 보통 GUI, 사용자가 직접적으로 보면서 제어하는 부분을 조금 높은 수준의 우선순위 스케줄링으로 처리**합니다. (GUI 화면이 끊기거나 하면 짜증남)

```
Windows 우선순위 부스트 시스템

전면 프로세스 (Foreground Process):
┌─────────────────────────────────────────────────────┐
│  🎯 사용자가 현재 상호작용하는 프로그램              │
│                                                     │
│  • 기본 우선순위 + 2 레벨 부스트                    │
│  • 더 긴 Time Slice 할당 (6 quantum vs 2 quantum)  │
│  • 마우스/키보드 입력 시 즉시 높은 우선순위         │
│                                                     │
│  예시:                                              │
│  • 현재 포커스된 창의 프로그램                      │
│  • 사용자가 타이핑하고 있는 문서 편집기             │
│  • 재생 중인 동영상 플레이어                        │
└─────────────────────────────────────────────────────┘

백그라운드 프로세스 (Background Process):
┌─────────────────────────────────────────────────────┐
│  ⚙️ 사용자 인터랙션 없이 뒤에서 동작                │
│                                                     │
│  • 기본 우선순위 유지                               │
│  • 짧은 Time Slice                                 │
│  • 전면 프로세스에 양보                             │
│                                                     │
│  예시:                                              │
│  • 자동 백업 프로그램                               │
│  • 시스템 업데이트                                  │
│  • 바이러스 검사                                    │
│  • 윈도우 탐색기 섬네일 생성                        │
└─────────────────────────────────────────────────────┘
```

### I/O 집중 vs CPU 집중 프로세스 스케줄링

**추가적으로 입출력은 CPU 작업보다 매우 느리고 이러한 입출력 작업 중에서도 시간이 걸리는 작업을 처리할 때 끝날 때까지 대기하는 것은 상당히 비효율적**입니다.

```
처리 속도 비교 (상대적 시간)

CPU 연산:        1 사이클
RAM 접근:        100 사이클  
SSD 접근:        10,000 사이클
HDD 접근:        1,000,000 사이클  
네트워크 통신:    10,000,000 사이클

┌─────────────────────────────────────────────────────┐
│  🚀 CPU 작업 (1초)                                  │
│  ████████████████████████████████████████████████  │
└─────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────┐
│  💾 디스크 I/O 작업 (16분 40초에 해당)              │
│  ████████████████████████████████████████████████  │
│  ████████████████████████████████████████████████  │
│  ████████████████████████████████████████████████  │
│  ████████████████████████████████████████████████  │
│  (실제로는 1000배 더 긴 막대가 필요)                │
└─────────────────────────────────────────────────────┘
```

**그래서 이러한 입출력 작업을 보다 빠르게 처리하기 위해서 비동기 논블로킹 이러한 개념들이 생겨난 것**입니다.

### 시스템별 우선순위 정책

**그래서 일반적으로 Windows는 프로세스의 우선순위가 프로그램 즉 사용자 GUI에 우선순위가 높습니다**. **그러면 시스템으로 설정된 경우는 어떤 경우가 있냐 하면 일반적인 서버가 그렇습니다**.

```
데스크톱 시스템 (Windows/macOS)
┌─────────────────────────────────────────────────────┐
│  우선순위 정책: "사용자 경험 최우선"                 │
│                                                     │
│  높은 우선순위:                                      │
│  • GUI 응답성 (마우스, 키보드)                      │
│  • 멀티미디어 재생                                  │
│  • 사용자 상호작용 프로그램                         │
│                                                     │
│  낮은 우선순위:                                      │
│  • 시스템 유지보수 작업                             │
│  • 백그라운드 동기화                                │
│  • 자동 업데이트                                    │
│                                                     │
│  설계 철학: "사용자가 기다리게 하지 말라"            │
└─────────────────────────────────────────────────────┘

🖧 서버 시스템 (Linux Server)
┌─────────────────────────────────────────────────────┐
│  우선순위 정책: "처리량과 안정성 최우선"             │
│                                                     │
│  높은 우선순위:                                      │
│  • 네트워크 I/O 처리                               │
│  • 데이터베이스 트랜잭션                            │
│  • 시스템 데몬 프로세스                             │
│                                                     │
│  낮은 우선순위:                                      │
│  • 로그 분석                                        │
│  • 백업 작업                                        │
│  • 시스템 모니터링                                  │
│                                                     │
│  설계 철학: "최대한 많은 요청을 안정적으로 처리"     │
└─────────────────────────────────────────────────────┘
```

**서버는 여러 클라이언트들과의 I/O의 연쇄 작업 및 대기가 반복되기 때문에 시스템(백그라운드)에 우선순위가 높게 설정되어 있습니다**.

### IOCP (I/O Completion Port) 개념

**IOCP가 빠른 이유는 커널에서 바로 I/O 작업을 직접 처리하기 때문에 항상 높은 우선순위를 가집니다**.

```
 IOCP 동작 원리

기존 방식 (동기 I/O):
┌─────────────────────────────────────────────────────┐
│  👤 사용자 프로세스                                  │
│  ┌─────────────────────────────────────────────┐   │
│  │ 1. I/O 요청                                 │   │
│  │ 2. ⏳ 블로킹 대기 (CPU 낭비)                │   │
│  │ 3. 결과 수신                                │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
        ↕ 시스템 콜 오버헤드
┌─────────────────────────────────────────────────────┐
│  ⚙️ 커널                                            │
│  ┌─────────────────────────────────────────────┐   │
│  │ I/O 작업 수행                               │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘

IOCP 방식 (비동기 I/O):
┌─────────────────────────────────────────────────────┐
│  👤 사용자 프로세스 (여러 스레드)                    │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │
│  │스레드1      │ │스레드2      │ │워커 스레드  │   │
│  │1.I/O 요청   │ │3.다른 작업  │ │5.결과 처리  │   │
│  │2.즉시 반환  │ │4.계속 실행  │ │6.콜백 실행  │   │
│  └─────────────┘ └─────────────┘ └─────────────┘   │
└─────────────────────────────────────────────────────┘
        ↕ 최소한의 시스템 콜
┌─────────────────────────────────────────────────────┐
│  ⚡ 커널 (높은 우선순위로 실행)                      │
│  ┌─────────────────────────────────────────────┐   │
│  │ IOCP 큐                                     │   │
│  │ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐           │   │
│  │ │요청1│ │요청2│ │요청3│ │요청4│ ...       │   │
│  │ └─────┘ └─────┘ └─────┘ └─────┘           │   │
│  │                                             │   │
│  │ 완료 시 자동으로 완료 큐에 결과 추가        │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

**IOCP의 장점**:

- **커널 레벨에서 I/O 처리**: 최고 우선순위로 실행
- **CPU 사용률 최적화**: 대기 시간 동안 다른 작업 수행 가능
- **확장성**: 수천 개의 동시 연결 처리 가능
- **자동 로드 밸런싱**: 커널이 최적의 스레드에 작업 분배

### 우선순위 기반 스케줄링 알고리즘

현대 운영체제에서 사용하는 주요 스케줄링 알고리즘들을 살펴보겠습니다:

```
주요 스케줄링 알고리즘 비교

1️⃣ Round Robin (RR) - 시분할 방식
┌─────────────────────────────────────────────────────┐
│  Time Quantum: 10ms                                │
│                                                     │
│  프로세스A: ████████ → 대기                         │
│  프로세스B:          ████████ → 대기                │
│  프로세스C:                   ████████ → 대기       │
│  프로세스A:                            ████████     │
│                                                     │
│  장점: 공평함, 응답시간 예측 가능                    │
│  단점: 컨텍스트 스위칭 오버헤드                      │
└─────────────────────────────────────────────────────┘

2️⃣ Priority Scheduling - 우선순위 기반
┌─────────────────────────────────────────────────────┐
│  우선순위: A(9) > B(7) > C(5) > D(3)               │
│                                                     │
│  프로세스A: ████████████████ (높은 우선순위)        │
│  프로세스B:                  ████████ (중간)        │
│  프로세스C:                           ████ (낮음)   │
│  프로세스D:                               ██ (가장낮음)│
│                                                     │
│  장점: 중요한 작업 우선 처리                        │
│  단점: 기아 현상(낮은 우선순위 프로세스가 실행 안됨) │
└─────────────────────────────────────────────────────┘

3️⃣ Multilevel Feedback Queue - 다단계 피드백
┌─────────────────────────────────────────────────────┐
│  Queue 0 (높은 우선순위, RR quantum=8ms):           │
│  ┌─────┐ ┌─────┐                                   │
│  │ 새로│ │ I/O │ ← 새 프로세스, I/O 완료 프로세스   │
│  │운작업│ │완료 │                                   │
│  └─────┘ └─────┘                                   │
│          ↓ (시간 초과시)                            │
│  Queue 1 (중간 우선순위, RR quantum=16ms):         │
│  ┌─────┐ ┌─────┐                                   │
│  │CPU  │ │집중 │                                   │
│  │작업 │ │프로세스│                                 │
│  └─────┘ └─────┘                                   │
│          ↓ (시간 초과시)                            │
│  Queue 2 (낮은 우선순위, FCFS):                    │
│  ┌─────┐ ┌─────┐ ┌─────┐                         │
│  │장시간│ │실행 │ │CPU  │                         │
│  │실행 │ │프로세스│ │독점 │                         │
│  └─────┘ └─────┘ └─────┘                         │
│                                                     │
│  특징: 프로세스 행동에 따라 자동으로 우선순위 조정   │
└─────────────────────────────────────────────────────┘
```

### 실시간 시스템과 우선순위

특별한 경우로 **실시간 시스템(Real-time System)**에서는 더욱 엄격한 우선순위 관리가 필요합니다:

```
실시간 시스템 분류

Hard Real-time (경성 실시간):
┌─────────────────────────────────────────────────────┐
│  🚨 데드라인 놓치면 시스템 실패!                     │
│                                                     │
│  데드라인: 10ms ────────────────→ ⚠️ 반드시 지켜야함 │
│  ┌─────────────────────────┐                       │
│  │    작업 실행             │                       │
│  └─────────────────────────┘                       │
│   0ms                    8ms                       │
│                                                     │
│  예시: 항공기 제어, 의료기기, 원자력 발전소          │
│  특징: 가장 높은 우선순위, 선점 불가                │
└─────────────────────────────────────────────────────┘

Soft Real-time (연성 실시간):
┌─────────────────────────────────────────────────────┐
│  🎵 데드라인 놓쳐도 품질만 저하                      │
│                                                     │
│  데드라인: 16.67ms (60fps) → 늦어도 큰 문제 없음    │
│  ┌─────────────────────────────────┐               │
│  │    작업 실행 (조금 늦어짐)        │               │
│  └─────────────────────────────────┘               │
│   0ms                           20ms               │
│                                                     │
│  예시: 멀티미디어 재생, 온라인 게임                  │
│  특징: 높은 우선순위, 하지만 유연함                  │
└─────────────────────────────────────────────────────┘
```

### 프로세스 유형별 최적 스케줄링 전략

앞서 언급한 우선순위 분류를 더 구체적으로 살펴보겠습니다:

```
우선순위 높음 ──────────────→ 우선순위 낮음

커널 프로세스              일반 프로세스
┌─────────────────┐       ┌─────────────────┐
│• 메모리 관리자   │       │• 웹 브라우저     │
│• 프로세스 스케줄러│       │• 문서 편집기     │
│• 장치 드라이버   │       │• 게임 프로그램   │
│• 네트워크 스택   │   vs  │• 미디어 플레이어 │
│                 │       │                 │
│우선순위: 15-31   │       │우선순위: 6-12    │
│절대 중단되면 안됨│       │사용자 편의성     │
└─────────────────┘       └─────────────────┘

전면 프로세스(GUI)        후면 프로세스(백그라운드)
┌─────────────────┐       ┌─────────────────┐
│• 현재 활성 창    │       │• 시스템 업데이트 │
│• 마우스 포인터   │       │• 바이러스 검사   │
│• 키보드 입력     │   vs  │• 자동 백업       │
│• 동영상 재생     │       │• 인덱싱 서비스   │
│                 │       │                 │
│빠른 응답 필요    │       │느려도 괜찮음     │
│Time Slice: 6x    │       │Time Slice: 2x    │
└─────────────────┘       └─────────────────┘

대화형 프로세스           일괄 프로세스
┌─────────────────┐       ┌─────────────────┐
│• 사용자와 상호작용│       │• 배치 작업       │
│• 즉시 응답 필요   │   vs  │• 대용량 계산     │
│• 짧은 CPU 버스트 │       │• 로그 분석       │
│• 높은 우선순위   │       │• 데이터 마이닝   │
└─────────────────┘       └─────────────────┘

I/O 집중 프로세스         CPU 집중 프로세스  
┌─────────────────┐       ┌─────────────────┐
│• 텍스트 에디터   │       │• 수학 계산       │
│• 데이터베이스    │       │• 이미지 처리     │
│• 웹 서버        │   vs  │• 압축/암호화     │
│• 네트워크 앱     │       │• 3D 렌더링       │
│                 │       │                 │
│빠른 선점, 높은 우선│       │긴 Time Slice    │
│순위로 응답성 보장│       │백그라운드 실행   │
└─────────────────┘       └─────────────────┘
```

### 현대 운영체제의 지능형 스케줄링

현대 운영체제들은 **적응적 스케줄링(Adaptive Scheduling)**을 사용합니다:

```
Windows CFS (Completely Fair Scheduler) 유사 개념

가상 실행 시간(Virtual Runtime) 기반:
┌─────────────────────────────────────────────────────┐
│  프로세스별 가상 실행 시간 추적:                     │
│                                                     │
│  프로세스A: VT=100ms (우선순위 높음) → 실제시간 50ms │
│  프로세스B: VT=200ms (우선순위 보통) → 실제시간 200ms│  
│  프로세스C: VT=150ms (우선순위 낮음) → 실제시간 300ms│
│                                                     │
│  ➡️ VT가 가장 적은 프로세스A가 다음에 실행          │
│                                                     │
│  공식: VT = 실제실행시간 × (기본가중치 / 프로세스가중치)│
└─────────────────────────────────────────────────────┘

Linux O(1) 스케줄러 개념:
┌─────────────────────────────────────────────────────┐
│  ⚡ Active Array          💤 Expired Array          │
│  ┌─────────────────┐      ┌─────────────────┐      │
│  │우선순위 0: [P1] │      │우선순위 0: [ ]  │      │
│  │우선순위 1: [P2] │      │우선순위 1: [P4] │      │
│  │우선순위 2: [P3] │  →   │우선순위 2: [ ]  │      │
│  │       ...       │      │       ...       │      │
│  └─────────────────┘      └─────────────────┘      │
│                                                     │
│  • Active에서 실행, Time Slice 소모시 Expired로    │
│  • Active 비면 두 배열 교체                        │
│  • O(1) 시간복잡도로 다음 프로세스 선택             │
└─────────────────────────────────────────────────────┘
```

### 스케줄링 성능 측정 지표

스케줄링 효율성을 측정하는 주요 지표들입니다:

📊스케줄링 성능 지표

1️⃣ 처리량 (Throughput)
단위 시간당 완료된 프로세스 수
높을수록 좋음: 50개/초 vs 30개/초

2️⃣ 응답 시간 (Response Time)  
요청부터 첫 응답까지의 시간
낮을수록 좋음: 100ms vs 500ms

3️⃣ 대기 시간 (Waiting Time)
Ready Queue에서 대기한 총 시간  
낮을수록 좋음: 평균 50ms vs 200ms

4️⃣ 반환 시간 (Turnaround Time)
작업 제출부터 완료까지 총 시간
낮을수록 좋음: 2초 vs 10초

5️⃣ CPU 사용률 (CPU Utilization)
CPU가 유휴 상태가 아닌 시간 비율
높을수록 좋음: 95% vs 60%

```
실제 측정 예시:
┌─────────────────────────────────────────────────────┐
│  시스템 A (최적화 전):                               │
│  • 처리량: 20 프로세스/초                            │
│  • 평균 응답시간: 800ms                             │
│  • CPU 사용률: 60%                                  │
│                                                     │
│  시스템 B (최적화 후):                               │
│  • 처리량: 45 프로세스/초                            │
│  • 평균 응답시간: 200ms                             │
│  • CPU 사용률: 90%                                  │
│                                                     │
│  ➡️ 시스템 B가 모든 면에서 우수한 성능               │
└─────────────────────────────────────────────────────┘
```

이러한 **복합적인 스케줄링 메커니즘**을 통해 현대 운영체제는 **다양한 유형의 프로세스들이 효율적으로 CPU 자원을 공유**하면서도 **사용자 경험과 시스템 성능을 동시에 최적화**할 수 있습니다. 특히 **I/O 집중적 프로세스에는 높은 응답성을, CPU 집중적 프로세스에는 충분한 처리 시간을 보장**하는 균형잡힌 접근법이 핵심입니다.