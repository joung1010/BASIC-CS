## 프로세스와 스레드

### 기본 개념과 관계

**프로세스는 관리의 단위**이고 이 주체는 **OS**이다. 결국 프로세스도 처리해야 할 연산들이고, 이 연산들은 **연속적인 흐름**을 가진다. 프로세스 레벨에서는 이 흐름이 **1개가 존재**하고 이 프로세스는 **반드시 한 개의 스레드**를 가진다.

이때 이 흐름이 **n개일 때** 이 각 흐름들은 **동시에 각자 독립적으로** 동작한다. 그리고 이 흐름들에서 **각 실행들을 스레드**라고 하고 이 실행들이 여러 개가 있으면 **멀티스레딩**이라고 한다.

### 프로세스와 스레드의 구조적 관계

```
프로세스 (Process) - OS의 관리 단위
├─ 흐름1 ────────────────────────────────────────────>
│  ├─ 스레드 실행 ──┐
│  ├─ 스레드 실행 ──┤  
│  ├─ 스레드 실행 ──┤  독립적 실행 흐름
│  └─ 스레드 실행 ──┘
│
├─ 흐름2 ────────────────────────────────────────────>
│  ├─ 스레드 실행 ──┐
│  ├─ 스레드 실행 ──┤  병렬 처리
│  └─ 스레드 실행 ──┘
│
└─ 흐름n ────────────────────────────────────────────>
   ├─ 스레드 실행 ──┐
   └─ 스레드 실행 ──┘
```

### 시스템 자원 할당과 가상 메모리

```
┌─────────────────────────────────────────────────────────┐
│                     User Mode                          │
│  ┌─────────────────┐    ┌─────────────────────────────┐ │
│  │    프로세스     │    │      가상 메모리            │ │
│  │    연산코드     │◄──►│   (Virtual Memory)          │ │
│  │                 │    │                             │ │
│  └─────────────────┘    └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
═══════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────┐
│                   Kernel Mode                          │
│                      OS                                │
│              (자원 관리 및 할당)                        │
└─────────────────────────────────────────────────────────┘
═══════════════════════════════════════════════════════════
┌─────────────────────────────────────────────────────────┐
│                    Hardware                            │
│  ┌─────────────────┐    ┌─────────────────────────────┐ │
│  │      CPU        │    │          RAM               │ │
│  │ 코어0, 코어1,   │    │     (물리 메모리)           │ │
│  │ 코어2, 코어3    │    │                             │ │
│  └─────────────────┘    └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 자원 할당 과정과 가상 메모리의 역할

**프로세스 실행을 위한 자원 할당 과정**:

1. **CPU 할당**: 운영체제가 "CPU 0번을 주고 이걸 사용해서 연산 처리해!"라고 지시
2. **메모리 할당**: CPU는 연산에 필요한 **연습장(RAM)**이 필요하다고 요청
3. **가상 메모리 제공**: OS가 연산에 필요한 메모리를 **Virtual Memory 형태로 관리**하여 제공

**가상 메모리의 추상화 개념**:

```
가상 메모리 (연속된 주소 공간)
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │ ← 논리적 주소
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   ↓     ↓     ↓     ↓     ↓     ↓     ↓     ↓
┌─────┬─────┐     ┌─────┬─────┐     ┌─────┬─────┐
│RAM  │RAM  │     │HDD  │HDD  │     │RAM  │SSD  │ ← 실제 물리적 위치
└─────┴─────┘     └─────┴─────┘     └─────┴─────┘
```

이 **Virtual Memory는 1차 메모리인 RAM과 2차 메모리인 HDD/SSD를 합쳐서 추상화**시킨 것으로, 이 연속된 가상 메모리를 실제 따라가 보면 **RAM인 경우도 있고 HDD인 경우도** 있을 수 있다.

### 가구와 세대원 비유 - TLS와 Heap의 이해

**프로세스를 가구, 스레드를 세대원으로 비유**하면 더 쉽게 이해할 수 있다:

```
🏠 프로세스 (가구) - OS에게 할당받은 집
┌─────────────────────────────────────────────────────────┐
│  👨 스레드1     👩 스레드2     👦 스레드3     👧 스레드4   │
│   (세대원1)     (세대원2)     (세대원3)     (세대원4)    │
│                                                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │
│  │ 개인방1 │  │ 개인방2 │  │ 개인방3 │  │ 개인방4 │    │
│  │   TLS   │  │   TLS   │  │   TLS   │  │   TLS   │    │
│  │ (Thread │  │ (Thread │  │ (Thread │  │ (Thread │    │
│  │ Local   │  │ Local   │  │ Local   │  │ Local   │    │
│  │Storage) │  │Storage) │  │Storage) │  │Storage) │    │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘    │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │              거실 (공용 공간)                    │   │
│  │                 Heap Memory                     │   │
│  │   - 모든 세대원이 공유하는 공간                  │   │
│  │   - 공용 가구, 물건들 보관                      │   │
│  │   - 함께 사용하는 자원들                        │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 프로세스와 스레드의 메모리 공유

**핵심 원칙들**:

- **Process(작업)는 최소 1개의 Thread가 존재**한다. 그래서 우리가 **프로세스 내에서의 연산은 스레드 단위로 진행**되게 된다.
- **OS는 이 Virtual Memory(제한된 공간)를 Process에게 할당**한다.
- **Process에 속한 모든 스레드는 프로세스의 가상 메모리로 공간이 제약**된다.
- **각 스레드는 고유한 TLS(Thread Local Storage)를 가지고 있다**. 따라서 **스레드들은 프로세스에게 운영체제로부터 할당받은 공간에서 모여 살고 있다**.

### 메모리 영역별 상세 분석

**프로세스 가상 메모리 구조**:

```
높은 주소 (0xFFFFFFFF)
┌─────────────────────────────────────┐
│            Kernel Space              │ ← OS 전용 영역
├─────────────────────────────────────┤
│     Stack (각 스레드별 독립)         │ ← 개인방 (TLS 포함)
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐   │
│  │TLS1 │ │TLS2 │ │TLS3 │ │TLS4 │   │ ← Thread Local Storage
│  │Stack│ │Stack│ │Stack│ │Stack│   │
│  │  1  │ │  2  │ │  3  │ │  4  │   │
│  └─────┘ └─────┘ └─────┘ └─────┘   │
├─────────────────────────────────────┤
│               ↓↑                    │ ← 동적 확장 영역
│         (Stack ↔ Heap 경계)         │
├─────────────────────────────────────┤
│              Heap                   │ ← 거실 (모든 스레드 공유)
│        (동적 메모리 할당)            │   공용 가구, 데이터
│      모든 스레드가 공유 영역         │
├─────────────────────────────────────┤
│              BSS                    │ ← 모든 스레드가 공유
│      (초기화되지 않은 전역변수)       │
├─────────────────────────────────────┤
│             Data                    │ ← 모든 스레드가 공유
│       (초기화된 전역변수)            │
├─────────────────────────────────────┤
│             Text                    │ ← 모든 스레드가 공유
│          (실행 코드)                 │
└─────────────────────────────────────┘
낮은 주소 (0x00000000)
```

### Thread Local Storage (TLS) 상세 설명

**TLS의 개념과 특징**:

```c
*// 각 스레드마다 독립적인 TLS 변수*
__thread int thread_id;           *// 각 스레드별로 다른 값*
__thread char buffer[1024];       *// 각 스레드별로 독립적인 버퍼*
__thread FILE* log_file;          *// 각 스레드별로 다른 파일 핸들*

void thread_function(void* arg) {
    thread_id = getCurrentThreadId();  *// 각 스레드마다 다른 ID 저장*
    sprintf(buffer, "Thread %d log", thread_id);  *// 독립적인 버퍼 사용*
    
    *// TLS는 각 스레드의 "개인방"에 저장됨// 다른 스레드가 접근할 수 없음*
}
```

**TLS 활용 예시**:

```java
// Java에서의 ThreadLocal 사용*
public class ThreadLocalExample {
    // 각 스레드별로 독립적인 값을 가지는 변수*
    private static ThreadLocal<Integer> threadLocalValue = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            return 0;  // 각 스레드별 초기값*
        }
    };
    
    public static void main(String[] args) {
        // 3개의 스레드가 각각 독립적인 TLS 공간을 가짐*
        for (int i = 0; i < 3; i++) {
            final int threadNum = i;
            new Thread(() -> {
                // 각 스레드가 자신만의 값을 설정 (개인방에 물건 보관)*
                threadLocalValue.set(threadNum * 100);
                
                System.out.println("Thread " + threadNum + 
                    " TLS value: " + threadLocalValue.get());
                // Thread 0 TLS value: 0// Thread 1 TLS value: 100  // Thread 2 TLS value: 200*
            }).start();
        }
    }
}
```

### 스레드별 자원 공유와 독립성

**개인방 (TLS) - 각 스레드가 독립적으로 소유**:

- **TLS 변수**: 스레드별로 고유한 값 저장
- **레지스터**: CPU 레지스터 상태값
- **프로그램 카운터**: 현재 실행 중인 명령어 위치
- **스택**: 함수 호출 스택과 지역 변수
- **스레드 ID**: 각 스레드의 고유 식별자

**거실 (Heap) - 모든 스레드가 공유하는 공간**:

- **힙 메모리**: `malloc()`, `new` 등으로 할당된 동적 메모리
- **전역 변수**: 모든 스레드가 접근 가능한 변수들
- **파일 디스크립터**: 열린 파일들
- **시그널 핸들러**: 신호 처리 함수
- **코드 영역**: 실행할 프로그램 코드

### 실제 TLS와 Heap 사용 예시

**C++에서의 TLS와 공유 메모리 사용**:

```cpp
#include <thread>
#include <iostream>

*// 거실 (Heap) - 모든 스레드가 공유*
int shared_counter = 0;           *// 공용 카운터*
std::mutex counter_mutex;         *// 공용 자원 보호용 뮤텍스// 개인방 (TLS) - 각 스레드별로 독립*
thread_local int private_counter = 0;  *// 각 스레드만의 카운터*

void worker_thread(int thread_id) {
    *// 개인방에서 작업 (TLS 사용)*
    private_counter = thread_id * 10;
    
    for (int i = 0; i < 5; i++) {
        *// 개인방에서 혼자 작업*
        private_counter++;
        
        *// 거실에서 공용 작업 (동기화 필요)*
        {
            std::lock_guard<std::mutex> lock(counter_mutex);
            shared_counter++;  *// 공용 자원 접근*
        }
        
        std::cout << "Thread " << thread_id 
                  << " - Private: " << private_counter 
                  << ", Shared: " << shared_counter << std::endl;
    }
}

int main() {
    std::thread t1(worker_thread, 1);  *// 세대원 1*
    std::thread t2(worker_thread, 2);  *// 세대원 2*
    
    t1.join();
    t2.join();
    
    return 0;
}
```

### 스케줄링과 CPU 할당

**OS의 스레드 스케줄링**:

CPU 코어 할당:
시간 t1: 코어0 → 스레드1(TLS1), 코어1 → 스레드2(TLS2)
시간 t2: 코어0 → 스레드2(TLS2), 코어1 → 스레드3(TLS3)  
시간 t3: 코어0 → 스레드3(TLS3), 코어1 → 스레드1(TLS1)

각 스레드는:
- 개인방(TLS): 독립적으로 관리
- 거실(Heap): 공유하면서 동기화 필요

### 동기화의 필요성

**거실(Heap) 사용 시 주의사항**:

c

```c
*// 문제 상황: 거실에서 동시에 물건을 옮기려 할 때// 스레드1과 스레드2가 동시에 shared_data를 수정*
int shared_data = 100;  *// 거실의 공용 물건// 스레드1: shared_data = shared_data + 10;// 스레드2: shared_data = shared_data * 2;// 예상 결과: 220 또는 210// 실제 결과: 예측 불가 (Race Condition)// 해결책: 뮤텍스로 거실 사용 순서 정하기*
pthread_mutex_t room_lock;
pthread_mutex_lock(&room_lock);    *// 거실 문 잠그기*
shared_data = shared_data + 10;    *// 혼자서 안전하게 작업*
pthread_mutex_unlock(&room_lock);  *// 거실 문 열기*
```

이러한 **프로세스와 스레드의 관계**는 **가구와 세대원의 개념**으로 이해하면, **각 스레드가 독립적인 TLS(개인방)을 가지면서도 공통의 Heap(거실)을 공유**하여 효율적인 **병렬 처리와 자원 공유**를 가능하게 한다는 것을 알 수 있다.


### 컴퓨터 자원의 구성

컴퓨터에서 자원이라고 할 때는 보통 크게 **3개의 자원**을 말한다:

- **CPU**: 연산 처리 장치
- **RAM**: 주기억장치
- **HDD/SSD**: 보조기억장치 (추가적인 자원)

그리고 **주기억장치 RAM과 보조기억장치 HDD/SSD를 합쳐서 Virtual Memory 형태로 관리**된다.

### 자원 할당 방식의 차이

그래서 이 자원을 **운영체제마다 차이가 있지만** 보통 **프로세스에게 할당**한다. **Windows 같은 경우는 스레드에게 할당**한다.

**Linux/Unix 계열**:

```
OS → Process → Thread
자원 할당 단위: Process
스케줄링 단위: Thread
```

**Windows 계열**:

```
OS → Thread (직접 할당)
자원 할당 단위: Thread
스케줄링 단위: Thread
```

### PCB와 TCB - 프로세스와 스레드 관리

**OS 입장에서 프로세스들을 관리**해야 되는데 이때 **관리에 필요한 정보를 모아둔 것을 PCB(Process Control Block)**라고 한다.

그래서 **프로세스에 속한 스레드들은 프로세스에게 할당받은 공간에 접근**할 수 있다. 반대로 **스레드들을 관리하기 위한 정보들은 TCB(Thread Control Block)에 저장하고 관리**한다.

### 시분할 시스템의 필요성

근데 생각해보면 이 **CPU의 코어가 8개 있다고 가정했을 때** 우리가 PC에서 현재 실행 중인 프로세스를 확인해보면 **그 많은 프로세스들의 각 연산들을 고작 CPU 코어 8개에 부탁해서 처리**하고 있으면 **병목 현상이 발생하지 않을까** 하는 생각을 할 수 있다.

**현실적 상황**:

```
실행 중인 프로세스: 200~500개
사용 가능한 CPU 코어: 4~16개
→ 물리적으로 동시 처리 불가능!
```

그러한 문제를 해결해주는 것이 바로 **OS**인데 OS에서 이러한 **병목 현상이 생기지 않게끔 프로세스들을 관리**하고 **CPU 역시 본인이 가지고 있는 자원을 시분할 사용을 통해 이를 해결**한다. (**특정 프로세스가 잠깐 사용하고 다른 프로세스가 해당 자원을 사용한다. 이러한 방식을 시분할**)

**시분할 처리 예시**:

```
Time Slice: 10ms

시간 0-10ms:   코어0→프로세스A, 코어1→프로세스B
시간 10-20ms:  코어0→프로세스C, 코어1→프로세스D  
시간 20-30ms:  코어0→프로세스A, 코어1→프로세스E
...

→ 사용자 입장에서는 모든 프로세스가 동시에 실행되는 것처럼 보임
```

### PCB(Process Control Block)의 구성 요소

그러면 과연 이 **PCB는 어떤 정보가 있어서 프로세스를 관리할 수 있는 것일까?**

**핵심 PCB 정보들**:

- **PID(프로세스 ID)**: 양의 정수 값으로 프로세스 고유 식별자
- **메모리 관련 정보**: 연산에 필요한 메모리 주소값 등을 가지고 있음
- **레지스터 정보**: CPU 레지스터 상태 백업
- **프로그램 카운터**: 현재 실행 중인 명령어 주소
- **프로세스 상태**: 생성, 준비, 실행, 대기, 완료
- **우선순위**: 스케줄링 우선순위
- **부모/자식 프로세스 정보**: 프로세스 계층 구조
- **열린 파일 목록**: 사용 중인 파일 디스크립터들

### Virtual Memory의 영역 구분

그러면 이 **Virtual Memory는 여러 영역으로 나뉘어져** 있다:

```
높은 주소 (0xFFFFFFFF)
┌─────────────────────────────────────┐
│              Stack                  │ ← 지역변수, 함수 매개변수
│         (지역 변수)                  │   함수 호출 스택
├─────────────────────────────────────┤
│               ↓↑                    │ ← 동적 확장 영역
├─────────────────────────────────────┤
│              Heap                   │ ← 동적 메모리 할당
│        (malloc, new 등)             │   런타임 시 크기 결정
├─────────────────────────────────────┤
│           Static/BSS                │ ← 정적 변수 영역
│  ┌─────────────────────────────┐   │
│  │    Read/Write 영역          │   │ ← 초기화된 전역변수
│  │    (전역변수)               │   │   프로그램 종료까지 유지
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │    Read Only 영역           │   │ ← 문자열 리터럴
│  │    (문자열 상수)            │   │   수정 불가능한 데이터
│  └─────────────────────────────┘   │
├─────────────────────────────────────┤
│          Code/Text                  │ ← 실행 가능한 명령어
│        (기계어 명령)                 │   CPU가 실행할 코드
└─────────────────────────────────────┘
낮은 주소 (0x00000000)
```

### 프로그램에서 프로세스로의 전환

**설치된 프로그램을 RAM에 올려서 인스턴스화한다 → 설치 파일을 실행한다.**

**프로세스 생성 과정**:

```
1. 프로그램 실행 요청 (더블클릭, 명령어 입력)
   ↓
2. OS가 실행 파일(.exe, .out)을 분석
   ↓  
3. Virtual Memory 공간 할당
   ↓
4. 프로그램 코드를 메모리에 로드
   ↓
5. PCB 생성 및 초기화
   ↓
6. 프로세스 상태를 "생성"으로 설정
```

그래서 **실행시키면 OS는 이 프로그램을 메모리에 올리고 PCB를 생성하고 연산을 진행**한다. 이러한 상태의 프로그램을 **프로세스**라고 한다. 즉 **프로그램을 실행(인스턴스화)시켜서 CPU가 연산하는 상태를 프로세스**라고 한다.

### 프로세스 상태 전이도

그리고 이 **프로세스는 상태가 존재**하는데:

**5가지 프로세스 상태**:

1. **생성(New)**: PCB 생성, 메모리 할당 준비
2. **준비(Ready)**: 실행 준비 완료, CPU 할당 대기
3. **실행(Running)**: CPU에서 실제 명령어 실행
4. **대기(Blocked/Waiting)**: I/O 작업 등으로 일시 정지
5. **완료(Terminated)**: 실행 종료, 자원 해제

**상태 전이도**:

```
                      디스패치(Dispatch)
생성 상태 → 준비 상태  ────────────→  실행 상태 ────→ 완료 상태
         +PCB 생성   ←────────────          
                     타임아웃(인터럽트)
                     
                      ↓ 입출력 요청
                      ↓ (I/O Request)
                   대기 상태
                      ↑
                입출력 완료
               (I/O Complete)
```

### 비동기와 블로킹/논블로킹의 관계

그래서 이제는 **비동기에 대해서 조금 더 설명**을 진행하자면 **비동기는 요청자의 상태에 따라 블로킹/논블로킹이 정해진다**:

- **요청자가 비동기를 요청하고도 실행 상태이면 논블로킹**
- **요청자가 비동기를 요청하고 대기 상태로 전환한다면 블로킹**

**비동기 처리 방식 비교**:

```java
// 논블로킹 비동기*
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return slowNetworkCall();  // 백그라운드에서 실행*
});
// 메인 스레드는 계속 다른 작업 수행 (실행 상태 유지)*
doOtherWork();  
String result = future.get();  // 필요할 때 결과 획득// 블로킹 비동기*  
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return slowNetworkCall();
});
String result = future.get();  // 즉시 대기 (대기 상태로 전환)*
```

### Dispatch의 의미와 동작 원리

**Dispatch의 사전적 의미와 IT의 의미가 다르다**:

- **사전적 의미**:
    - **dispatcher**: 운행원, 관리원
    - **dispatch**: 보내다
- **IT적 관점**:
    - **dispatcher**: OS가 담당
    - **dispatch**: 보내기 전에 **보낼 대상을 선점**한다는 의미
    - **먼저 대상을 선점해야 그 대상을 보낼 수 있기 때문**
    - 즉 **dispatch라는 의미에는 보낼 데이터의 선점까지 포함**되어 있다

### 큐 기반 프로세스 스케줄링

**운영체제가 프로세스를 관리할 때 사용하는 자료구조는 Queue를 사용**한다. 그래서 **만약 프로세스가 200개이면 이 200개의 프로세스를 줄을 세워서 dispatch** 한다.

**스케줄링 큐의 동작**:

```
Ready Queue (준비 상태 프로세스들):
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│ P1  │ P2  │ P3  │ P4  │ P5  │ P6  │ P7  │ P8  │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
  ↑                                           ↑
 Front                                      Rear
 (다음 실행)                             (새로 추가)

CPU 코어 8개라면 → 한 번에 8개씩 꺼내서 처리
```

**만약 해당 큐가 준비 상태의 프로세스만 보관하고 있는 큐라면** 큐를 **순차적으로 디스패치해서 실행 상태로 전환**한다. 그래서 **CPU 코어 8개라면 한 번에 8개씩 꺼내서 처리**하게 되는 것이다.

**실제 스케줄링 과정**:

```
Time t1:
Ready Queue: [P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, ...]
             ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓
CPU Cores:  [P1][P2][P3][P4][P5][P6][P7][P8]

Time t2 (10ms 후, 타임 슬라이스 만료):
Ready Queue: [P9, P10, P11, P12, P1, P2, P3, P4, ...]
             ↓   ↓   ↓   ↓   ↓  ↓  ↓  ↓
CPU Cores:  [P9][P10][P11][P12][P1][P2][P3][P4]
```

이러한 **프로세스 관리 시스템**을 통해 **수백 개의 프로세스가 제한된 CPU 자원을 효율적으로 공유**하여 **멀티태스킹 환경**을 구현할 수 있다.