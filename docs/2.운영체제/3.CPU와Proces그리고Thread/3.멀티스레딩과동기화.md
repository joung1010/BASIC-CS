## 멀티스레드 동기화 기본

### 멀티태스킹과 자원 공유

**멀티태스킹은 프로세스가 여러 개 있는 것을 의미**합니다. **하나의 프로세스에는 OS가 권한과 VMS(가상 메모리 공간)을 할당하고 거기에 속한 스레드들은 이 공간을 공유**하게 됩니다. **항상 멀티 여러 개가 되면 문제가 되는 것이 동기화 문제**입니다.

```
🏠 프로세스 (집)
┌─────────────────────────────────────────────────────┐
│                  가상 메모리 공간                    │
│                                                     │
│  👨 스레드1   👩 스레드2   👦 스레드3   👧 스레드4   │
│   (세대원1)   (세대원2)   (세대원3)   (세대원4)      │
│      ↓          ↓          ↓          ↓           │
│  ┌─────────────────────────────────────────────┐   │
│  │            🚽 화장실 (공유 자원)             │   │
│  │         - 전역 변수                         │   │
│  │         - 파일 핸들러                       │   │
│  │         - 네트워크 연결                     │   │
│  └─────────────────────────────────────────────┘   │
│      ↑          ↑          ↑          ↑           │
│   동시 접근     동시 접근   동시 접근   동시 접근     │
│   🏃‍♂️💨        🏃‍♀️💨      🏃‍♂️💨        🏃‍♀️💨         │
└─────────────────────────────────────────────────────┘
```

**프로세스가 집이고 거기에 살고 있는 세대주들이 스레드**라고 할 때 **그 거주 공간에 화장실이 하나라면 여러 사람들이 이 하나의 화장실을 점유하려 하고**, 특히 **아침이나 저녁 시간대에는 병목 현상이 발생**합니다.

**이 하나의 자원을 두고 병목 현상 및 Race Condition(경쟁 조건)이 발생**합니다.

### 멀티프로세싱 vs 멀티스레딩 선택

**그래서 여기서 우리는 작은 공간을 여러 개 사용할 것인가 혹은 큰 집에 여러 방을 선택할 것인가 하는 고민**을 할 수 있습니다.

```
🏢 멀티프로세싱 (여러 개의 작은 집)
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│  프로세스1   │  │  프로세스2   │  │  프로세스3   │
│             │  │             │  │             │
│ 👨 스레드1   │  │ 👩 스레드1   │  │ 👦 스레드1   │
│             │  │             │  │             │
│ 🚽 화장실    │  │ 🚽 화장실    │  │ 🚽 화장실    │
│ 🛋️ 거실     │  │ 🛋️ 거실     │  │ 🛋️ 거실     │
│ 🍽️ 주방     │  │ 🍽️ 주방     │  │ 🍽️ 주방     │
└─────────────┘  └─────────────┘  └─────────────┘
   독립된 자원      독립된 자원      독립된 자원
   (중복 생성)      (중복 생성)      (중복 생성)

🏠 멀티스레딩 (하나의 큰 집)
┌─────────────────────────────────────────────────────┐
│                    프로세스                          │
│                                                     │
│  👨 스레드1   👩 스레드2   👦 스레드3   👧 스레드4    │
│                                                     │
│  ┌─────────────────────────────────────────────┐   │
│  │        🚽 화장실 (공유 자원)                │   │
│  │        🛋️ 거실 (공유 자원)                 │   │
│  │        🍽️ 주방 (공유 자원)                 │   │
│  └─────────────────────────────────────────────┘   │
│                   효율적인 자원 활용                 │
└─────────────────────────────────────────────────────┘
```

**이때 여러 집, 오피스텔 형태의 공간을 선택한다면 공간이 작더라도 여기에는 공유 자원인 화장실과 거실 등을 각 공간마다 만들어 줘야 합니다**. 따라서 **효율적인 측면에서 보면 멀티스레딩이 보다 효율적**입니다.

### CPU 자원 할당과 스레드 권한

**스레드가 연산의 단위이기 때문에 실제 CPU의 자원을 할당받아 연산하는 주체는 스레드**이지만, **이때 어느 정도의 스레드를 할당받아 사용할 것인가**(예를 들어 8코어 CPU일 때 모든 코어를 할당받아 처리할 것인가, 하나의 코어만을 받아 처리할 것인가)에 **대한 권한은 프로세스에게 주어집니다**.

```
💻 8코어 CPU 자원 할당
┌─────────────────────────────────────────────────────┐
│                  OS 스케줄러                        │
│                                                     │
│  프로세스 A (4코어 할당)  │  프로세스 B (4코어 할당) │
│  ┌─────┬─────┬─────┬─────┐│  ┌─────┬─────┬─────┬─────┐│
│  │코어0│코어1│코어2│코어3││  │코어4│코어5│코어6│코어7││
│  └─────┴─────┴─────┴─────┘│  └─────┴─────┴─────┴─────┘│
│    ↓     ↓     ↓     ↓   │    ↓     ↓     ↓     ↓   │
│  스레드1 스레드2 스레드3 스레드4  스레드5 스레드6 스레드7 스레드8  │
└─────────────────────────────────────────────────────┘
        프로세스가 CPU 할당을 결정
```

### 스레드별 독립 영역과 공유 영역

**그래서 스레드는 VMS에서 정적 영역이라 분류되는 공간(코드, 전역 데이터, 파일)들을 같이 사용하고, 스레드 개별적으로 가지고 있는 스택(지역 변수, 자동 변수), 레지스터(TCB)는 독립적**입니다.

```
🏠 프로세스 메모리 구조
┌─────────────────────────────────────────────────────┐
│  👨 스레드1   👩 스레드2   👦 스레드3   👧 스레드4    │
│                                                     │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │
│  │ Stack1  │ │ Stack2  │ │ Stack3  │ │ Stack4  │   │ ← 독립 영역
│  │(1MB)    │ │(1MB)    │ │(1MB)    │ │(1MB)    │   │   (각 스레드별)
│  │지역변수  │ │지역변수  │ │지역변수  │ │지역변수  │   │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │
│                                                     │
│  ┌─────────────────────────────────────────────┐   │
│  │              Heap (공유 영역)                │   │ ← 공유 영역
│  │          - 동적 할당 메모리                 │   │   (모든 스레드)
│  │          - malloc(), new로 생성            │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │            Data (공유 영역)                 │   │
│  │          - 전역 변수                       │   │
│  │          - 정적 변수                       │   │
│  └─────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────┐   │
│  │            Code (공유 영역)                 │   │
│  │          - 실행 코드                       │   │
│  │          - 함수들                          │   │
│  └─────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
```

**Windows 기준으로 스택 영역의 크기는 별다른 설정이 없다면 1MB**입니다.

### TCB와 컨텍스트 스위칭

**스레드는 프로세스와 마찬가지로 별도의 TCB(Thread Control Block)를 가지고 있습니다**. **스레드 단위로 어떤 실행(연산)이 이루어지고 이 연산은 CPU의 코어가 하게 됩니다**. **이 코어 속에 레지스터 정보를 가지고 있습니다**.

```
🧠 CPU 코어와 레지스터
┌─────────────────────────────────────┐
│            CPU Core 0               │
│                                     │
│  ┌─────────────────────────────┐   │
│  │        레지스터들            │   │
│  │  ┌─────┬─────┬─────┬─────┐  │   │
│  │  │ EAX │ EBX │ ECX │ EDX │  │   │ ← 범용 레지스터
│  │  └─────┴─────┴─────┴─────┘  │   │
│  │  ┌─────┬─────┬─────┬─────┐  │   │
│  │  │ ESP │ EBP │ ESI │ EDI │  │   │ ← 포인터 레지스터
│  │  └─────┴─────┴─────┴─────┘  │   │
│  │  ┌─────────────────────────┐  │   │
│  │  │      PC (Program       │  │   │ ← 프로그램 카운터
│  │  │       Counter)         │  │   │
│  │  └─────────────────────────┘  │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
         ↕ 컨텍스트 스위칭
┌─────────────────────────────────────┐
│       TCB (Thread Control Block)   │
│  ┌─────────────────────────────┐   │
│  │     저장된 레지스터 상태     │   │
│  │  EAX: 0x12345678           │   │
│  │  EBX: 0x87654321           │   │
│  │  PC:  0x004010A0           │   │
│  │  ...                       │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

**즉, 어떤 연산을 하게 되면 이 CPU 코어의 레지스터에 변화가 생기게 됩니다**. **그래서 이 레지스터의 상태를 가지고 작업을 전환하고 이어가는 것을 컨텍스트 스위칭**이라고 합니다. **이 말은 프로세스와 마찬가지로 스레드 또한 특정한 상태를 가지고 있다**는 뜻입니다.

### 왜 스레드를 사용하게 되었을까?

**그러면 근본적으로 스레드를 왜 사용하게 되었을까?**

```
📈 단일 스레드 vs 멀티 스레드 성능 비교

단일 스레드 (순차 처리):
작업1 ──→ 작업2 ──→ 작업3 ──→ 작업4
 3초      3초      3초      3초
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
         총 소요 시간: 12초

멀티 스레드 (병렬 처리):
작업1 ──→
작업2 ──→  } 동시 실행 (4개 코어)
작업3 ──→
작업4 ──→
 3초
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
         총 소요 시간: 3초
```

**스레드 도입의 주요 이유들**:

1. **성능 향상**: CPU의 멀티코어를 활용하여 병렬 처리 가능
2. **응답성 개선**: UI 스레드와 작업 스레드 분리로 사용자 인터페이스가 멈추지 않음
3. **자원 효율성**: 프로세스보다 가벼운 컨텍스트 스위칭 비용
4. **I/O 중첩**: 한 스레드가 I/O 대기 중일 때 다른 스레드가 계속 작업

**실생활 예시**: 웹 브라우저에서 유튜브 동영상을 보면서 동시에 다른 탭에서 파일을 다운로드하고, 채팅도 할 수 있는 것이 모두 멀티스레드 덕분입니다.

### Java 스레드 실행 예제

**간단한 스레드 3개 시작/종료 예제**:

```java
public class ThreadOrderExample {
    public static void main(String[] args) {
        *// 3개의 스레드 생성*
        Thread thread1 = new Thread(() -> {
            System.out.println("스레드 1 시작");
            try {
                Thread.sleep(100); *// 0.1초 대기*
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("스레드 1 종료");
        });

        Thread thread2 = new Thread(() -> {
            System.out.println("스레드 2 시작");
            try {
                Thread.sleep(50); *// 0.05초 대기*
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("스레드 2 종료");
        });

        Thread thread3 = new Thread(() -> {
            System.out.println("스레드 3 시작");
            try {
                Thread.sleep(150); *// 0.15초 대기*  
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("스레드 3 종료");
        });

        *// 스레드 시작 (순서 예측 불가!)*
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

**실행 결과 (예측 불가능한 순서)**:

```
스레드 2 시작
스레드 1 시작  
스레드 3 시작
스레드 2 종료
스레드 1 종료
스레드 3 종료
```

### Race Condition (경쟁 조건) 예제

**전역 변수 경쟁 조건 문제**:

```java
public class RaceConditionExample {
    *// 공유 자원 (전역 변수)*
    private static int sharedCounter = 0;
    
    public static void main(String[] args) throws InterruptedException {
        *// 1000번씩 증가시키는 5개 스레드 생성*
        Thread[] threads = new Thread[5];
        
        for (int i = 0; i < 5; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    *// 🚨 위험! Race Condition 발생 지점*
                    sharedCounter++; *// 비원자적 연산/**
                     * sharedCounter++ 는 실제로는 3단계:
                     * 1. 메모리에서 값 읽기
                     * 2. 값에 1 더하기  
                     * 3. 메모리에 값 쓰기
                     **/*
                }
                System.out.println(Thread.currentThread().getName() + " 완료");
            });
        }
        
        *// 모든 스레드 시작*
        for (Thread thread : threads) {
            thread.start();
        }
        
        *// 모든 스레드 종료 대기*
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("예상 결과: " + (5 * 1000)); *// 5000*
        System.out.println("실제 결과: " + sharedCounter); *// 보통 5000보다 작음!*
    }
}
```

**실행 결과**:

```
Thread-0 완료
Thread-1 완료  
Thread-2 완료
Thread-3 완료
Thread-4 완료
예상 결과: 5000
실제 결과: 4847  ← 예상보다 작음!
```

### Race Condition이 발생하는 이유

```
Race Condition 발생 과정

시간 T1: 스레드A가 sharedCounter 읽기 (값: 100)
시간 T2: 스레드B가 sharedCounter 읽기 (값: 100) ← 같은 값!
시간 T3: 스레드A가 100 + 1 = 101 계산
시간 T4: 스레드B가 100 + 1 = 101 계산  
시간 T5: 스레드A가 101을 메모리에 저장
시간 T6: 스레드B가 101을 메모리에 저장 ← 덮어씀!

결과: 2번 증가했어야 하는데 1번만 증가함 (100 → 102가 아닌 100 → 101)
```

### 동기화의 필요성

**이런 Race Condition을 해결하기 위해 동기화(Synchronization)가 필요**합니다.

```
동기화 해결책

1. 뮤텍스(Mutex) - 상호 배제
┌─────────────────────────────────────┐
│  🚪 화장실 (공유 자원)               │
│  ┌─────────────────────────────┐   │
│  │ 🔒 자물쇠 (Mutex Lock)       │   │  
│  │                             │   │
│  │ 👨 현재 사용 중: 스레드1      │   │
│  │                             │   │
│  │ 🚪 문 잠김                   │   │
│  └─────────────────────────────┘   │
│                                     │
│  대기열:                            │
│  👩 스레드2 ──→ 👦 스레드3 ──→ 👧 스레드4  │
│   (대기 중)     (대기 중)     (대기 중)  │
└─────────────────────────────────────┘

2. 동기화된 코드 예제:
synchronized (lockObject) {
    sharedCounter++; // 한 번에 하나의 스레드만 실행
}
```

**동기화를 적용한 수정된 코드**:

```java
public class SynchronizedExample {
    private static int sharedCounter = 0;
    private static final Object lock = new Object(); *// 락 객체*
    
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[5];
        
        for (int i = 0; i < 5; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    *// 🔒 동기화 블록 - 한 번에 하나의 스레드만 실행*
                    synchronized (lock) {
                        sharedCounter++; *// 안전한 증가*
                    }
                }
                System.out.println(Thread.currentThread().getName() + " 완료");
            });
        }
        
        for (Thread thread : threads) {
            thread.start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("예상 결과: " + (5 * 1000));
        System.out.println("실제 결과: " + sharedCounter); *// 이제 정확히 5000!*
    }
}
```

이렇게 **멀티스레드 환경에서는 공유 자원에 대한 동기화가 필수적**이며, 이를 통해 **Race Condition을 방지하고 프로그램의 정확성을 보장**할 수 있습니다.