## 기억장치의종류와 역할
![img_2.png](../../static/img_2.png)


##  기억장치의 기본 개념

### **기억장치의 정의**

**컴퓨터에서 데이터를 저장하고 처리하는 장치.**

**기억장치가 필요한 이유:**

```

컴퓨터의 기본 동작:
1. 입력 (Input) - 키보드, 마우스
2. 처리 (Process) - CPU 연산
3. 출력 (Output) - 모니터, 프린터
4. 저장 (Storage) - 데이터 보관 ← 기억장치의 역할

처리 과정에서 필요:
- 실행할 프로그램 저장
- 연산할 데이터 저장
- 중간 결과 임시 보관
- 최종 결과 영구 보관

```

**디지털 정보의 저장 단위:**

```

모든 정보는 0과 1의 비트로 저장:
- 문자: ASCII/UTF-8 코드
- 숫자: 2진수 표현
- 이미지: 픽셀의 RGB 값
- 음악: 디지털 샘플링 데이터
- 프로그램: 기계어 명령어

저장 계층:
비트 → 바이트 → KB → MB → GB → TB

```

## 📊 기억장치의 계층적 구조

### **메모리 피라미드 분석**

```

           ↗ Register (가장 빠름, 가장 작음)
    CPU ━━━┫ Cache Memory
           ↘
              ↓ (데이터 복사)
           ┌─────────────────┐
           │       RAM       │ (주기억장치)
           └─────────────────┘
              ↓ (데이터 로딩)
     ┌─────────────────────────────┐
     │ HDD, SSD, USB, File System │ (보조기억장치)
     └─────────────────────────────┘
              ↓ (백업/아카이브)
        ┌─────────────────────┐
        │   Backup Device     │ (백업 장치)
        └─────────────────────┘

```

**계층별 특성 상세 비교:**

| 계층 | 속도 | 용량 | 가격/GB | 휘발성 | 용도 |
| --- | --- | --- | --- | --- | --- |
| **Register** | 1 클록 | 수십 개 | 매우 비쌈 | 휘발성 | CPU 임시 저장 |
| **Cache** | 1-10 클록 | KB-MB | 비쌈 | 휘발성 | 자주 쓰는 데이터 |
| **RAM** | 100+ 클록 | GB | 보통 | 휘발성 | 실행 중 프로그램 |
| **SSD** | 10,000+ 클록 | TB | 저렴 | 비휘발성 | 영구 저장 |
| **HDD** | 100,000+ 클록 | TB | 매우 저렴 | 비휘발성 | 대용량 저장 |

## 기억장치의 종류와 특성

### **주기억장치 (RAM)**

**휘발성 메모리로, 전원이 꺼지면 데이터 소실.프로그램 실행 시 데이터와 명령어를 임시로 저장.**

**RAM의 동작 원리:**

```

DRAM (Dynamic RAM) 구조:
- 각 비트를 커패시터에 전하로 저장
- 시간이 지나면 전하 누설 발생
- 주기적 리프레시 필요 (동적)

SRAM (Static RAM) 구조:
- 플립플롭 회로로 비트 저장
- 전원 공급되는 동안 데이터 유지 (정적)
- 빠르지만 비쌈 (캐시에 사용)

DDR (Double Data Rate):
DDR3: 800-1600 MHz
DDR4: 1600-3200 MHz
DDR5: 3200-6400 MHz
→ 숫자가 클수록 더 빠른 데이터 전송

```

**RAM 용량과 성능 관계:**

```

RAM 부족 시 문제:
- 가상 메모리 (스왑) 사용 증가
- HDD/SSD 접근 빈도 증가
- 전체 시스템 속도 저하

적정 RAM 용량 (2024년 기준):
- 기본 사무용: 8GB
- 멀티태스킹: 16GB
- 게임/개발: 32GB
- 전문 작업: 64GB+

```

### **보조기억장치 (HDD, SSD)**

**비휘발성 메모리로, 전원이 꺼져도 데이터 유지.**

### **HDD: 기계적 방식으로 데이터를 저장.**

**HDD 구조와 동작:**

```

물리적 구성:
- 플래터 (Platter): 자성 물질로 코팅된 원반
- 헤드 (Head): 데이터를 읽고 쓰는 자기 센서
- 스핀들: 플래터를 회전시키는 모터 (5400-15000 RPM)
- 액추에이터: 헤드를 이동시키는 장치

데이터 저장 방식:
0: 자성 방향 ↑ (North)
1: 자성 방향 ↓ (South)

접근 시간 구성:
- 회전 지연 (Rotational Delay): 섹터가 헤드 아래 올 때까지
- 탐색 시간 (Seek Time): 헤드가 트랙으로 이동하는 시간
- 전송 시간: 실제 데이터 읽기/쓰기 시간

```

### **SSD: 플래시 메모리 기반으로 빠른 데이터 접근.**

**SSD 구조와 장점:**

```

플래시 메모리 원리:
- NAND 게이트 구조
- 전자를 플로팅 게이트에 가두어 저장
- 전기적 신호로 읽기/쓰기

SSD vs HDD 비교:
           SSD        HDD
속도:      0.1ms      10ms
내구성:    충격 무관   물리적 충격 약함
소음:      무음       회전 소음
전력:      낮음       높음
용량:      제한적     대용량
가격:      비쌈       저렴

SSD 종류:
- SATA SSD: 기존 HDD 인터페이스 (6Gbps)
- NVMe SSD: PCIe 직접 연결 (32Gbps+)
- M.2 SSD: 작은 폼팩터 NVMe

```

### **캐시 메모리**

**CPU와 RAM 사이의 고속 메모리.자주 사용하는 데이터와 명령어를 저장하여 처리 속도 향상.**

**캐시 계층 구조:**

```

L1 캐시 (Level 1):
- 위치: CPU 코어 내부
- 크기: 32-64KB
- 속도: 1-2 클록
- 분리: 명령어 캐시 + 데이터 캐시

L2 캐시 (Level 2):
- 위치: CPU 내부, 코어별 또는 공유
- 크기: 256KB-1MB
- 속도: 3-10 클록

L3 캐시 (Level 3):
- 위치: CPU 내부, 모든 코어 공유
- 크기: 8-64MB
- 속도: 10-20 클록

캐시 작동 원리:
1. CPU가 데이터 요청
2. L1 → L2 → L3 순서로 검색
3. 캐시 미스 시 RAM에서 로드
4. 지역성 원리로 주변 데이터도 함께 로드

```

## 기억장치 관리 체계

**컴퓨터는 기본적으로 모든 것이 다 숫자다.정보가 저장된 위치도 숫자 (일련번호)로 표시된다.**

**디지털 세계의 숫자 체계:**

```

모든 정보의 숫자화:
- 데이터: 0과 1의 이진수
- 주소: 16진수 (0x00000000~0xFFFFFFFF)
- 파일 크기: 바이트 단위
- 시간: 유닉스 타임스탬프 (초 단위)
- 색상: RGB 값 (0-255)

예시:
문자 'A' = 65₁₀ = 0x41₁₆ = 01000001₂
메모리 주소 = 0x12345678
파일 크기 = 1,048,576 바이트 = 1MB

```

**이 같은 관리 체계는 아파트 단지에서 각 가구를 동, 호 숫자로 관리하는 것과 유사하다.**

**아파트 vs 컴퓨터 메모리 비교:**

```

아파트 단지:                    컴퓨터 메모리:
101동 1502호                   주소 0x12345678
├─ 동: 건물 구분               ├─ 상위 비트: 메모리 영역
└─ 호수: 각 가정               └─ 하위 비트: 정확한 위치

우편 배달:                     데이터 접근:
주소 확인 → 동 찾기 → 호수 방문  주소 디코딩 → 메모리 뱅크 → 데이터 읽기

관리 시스템:                   메모리 관리:
관리사무소에서 입주자 명단 관리    운영체제에서 메모리 맵 관리

```

### **레지스터는 개별 기억공간마다 고유 이름을 붙인다.**

**레지스터 명명 체계:**

```

Intel x86-64 레지스터:
범용 레지스터:
- RAX (Accumulator): 누산기, 연산 결과
- RBX (Base): 베이스 주소 계산
- RCX (Counter): 루프 카운터
- RDX (Data): 데이터 저장, 곱셈/나눗셈 확장
- RSI (Source Index): 소스 인덱스
- RDI (Destination Index): 목적지 인덱스
- RBP (Base Pointer): 스택 프레임 베이스
- RSP (Stack Pointer): 스택 포인터

특수 레지스터:
- RIP (Instruction Pointer): 다음 실행할 명령어 주소
- RFLAGS: 상태 플래그 (Zero, Carry, Overflow 등)

사용 예시:
MOV RAX, 100   ; RAX 레지스터에 100 저장
ADD RAX, RBX   ; RAX = RAX + RBX

```

**레지스터 크기별 이름:**

```

64비트: RAX (전체 64비트)
32비트: EAX (하위 32비트)
16비트: AX  (하위 16비트)
8비트:  AL  (하위 8비트), AH (상위 8비트)

활용:
MOV RAX, 0x123456789ABCDEF0  ; 64비트 전체
MOV EAX, 0x12345678          ; 하위 32비트만
MOV AX, 0x1234               ; 하위 16비트만
MOV AL, 0x12                 ; 하위 8비트만

```

### **주 기억장치는 일련번호를 붙인다.**

**RAM 주소 체계:**

```

선형 주소 공간:
0x00000000: [데이터1]
0x00000001: [데이터2]
0x00000002: [데이터3]
...
0xFFFFFFFF: [데이터마지막]

주소 계산 예시:
int array[1000];
array[0] 주소: 0x12340000
array[1] 주소: 0x12340004 (int = 4바이트)
array[2] 주소: 0x12340008
array[i] 주소: 0x12340000 + (i × 4)

메모리 레이아웃:
0x00000000-0x00400000: 커널 영역
0x00400000-0x08000000: 프로그램 코드
0x08000000-0x40000000: 힙 (동적 할당)
0x7FFF0000-0x80000000: 스택

```

**가상 메모리 주소 변환:**

```

가상 주소 → 물리 주소 변환:

프로그램이 보는 주소 (가상): 0x08048000
실제 RAM 위치 (물리): 0x12345000

페이지 테이블을 통한 변환:
가상 페이지 번호: 0x08048 (상위 20비트)
페이지 오프셋: 0x000 (하위 12비트)
→ 물리 주소: 0x12345000 + 0x000

장점:
- 프로그램마다 독립적인 주소 공간
- 물리 메모리보다 큰 가상 공간 사용 가능
- 메모리 보호 (다른 프로그램 접근 차단)

```

### **보조 기억장치는 트랙(Track) 번호와 섹터(Sector) 번호를 붙여 관리한다. (파일의 등장)**

**HDD 물리적 주소 체계:**

```

CHS (Cylinder, Head, Sector) 방식:
- Cylinder (실린더): 여러 플래터의 같은 위치 트랙들
- Head (헤드): 읽기/쓰기 헤드 번호
- Sector (섹터): 트랙을 나눈 최소 단위 (512바이트)

예시:
파일 위치: C=100, H=2, S=15
의미: 100번째 실린더, 2번째 헤드, 15번째 섹터

LBA (Logical Block Address) 방식:
- 물리적 구조 숨김
- 순차적 블록 번호 사용
- LBA 0, 1, 2, 3... 순서로 관리

변환 공식:
LBA = (C × 헤드수 × 섹터수) + (H × 섹터수) + (S - 1)

```

**파일 시스템의 등장:**

```

파일 시스템이 해결하는 문제:
1. 물리적 주소의 복잡성 숨김
2. 의미있는 이름으로 데이터 관리
3. 디렉토리 구조로 체계적 분류
4. 권한 관리 및 메타데이터 저장

FAT32 파일 시스템:
- FAT (File Allocation Table): 파일 위치 정보
- 클러스터 단위로 공간 할당
- 파일명: 8.3 형식 제한

NTFS 파일 시스템:
- MFT (Master File Table): 파일 정보 중앙 관리
- 긴 파일명 지원
- 압축, 암호화, 권한 기능
- 저널링으로 안정성 향상

ext4 파일 시스템 (Linux):
- 익스텐트 기반 할당
- 최대 16TB 파일, 1EB 볼륨
- 저널링 및 체크섬 기능

```

**파일의 물리적 저장:**

```

파일 "document.txt" (크기: 1500바이트)

물리적 저장:
클러스터 100: [첫 512바이트]
클러스터 101: [다음 512바이트]
클러스터 102: [마지막 476바이트]

FAT 테이블:
100 → 101 (다음 클러스터)
101 → 102 (다음 클러스터)
102 → EOF (파일 끝)

디렉토리 엔트리:
파일명: document.txt
크기: 1500 bytes
시작 클러스터: 100
날짜: 2024-01-15
속성: 읽기/쓰기

```

## 기억장치의 역할과 상호작용

### **데이터 저장: 프로그램과 파일을 저장하고 필요 시 불러옴.**

**프로그램 실행 과정:**

```

1단계: 프로그램 로딩
HDD/SSD → RAM으로 프로그램 복사
- 실행 파일 (.exe) 읽기
- 필요한 라이브러리 (.dll) 로딩
- 메모리 공간 할당

2단계: 데이터 파일 로딩
HDD/SSD → RAM으로 데이터 복사
- 문서 파일 읽기
- 이미지, 동영상 등 미디어 파일
- 설정 파일 및 임시 파일

3단계: 실행 중 저장
RAM → HDD/SSD로 결과 저장
- 수정된 문서 저장
- 임시 파일 생성
- 로그 및 히스토리 기록

```

### **데이터 처리: CPU가 데이터를 처리할 수 있도록 지원.**

**계층 간 데이터 흐름:**

```

처리 요청 시:
1. CPU가 데이터 요청
2. L1 캐시에서 확인
3. L2, L3 캐시 순차 확인
4. 캐시 미스 시 RAM 접근
5. RAM 미스 시 가상 메모리 (스왑)
6. 스왑 미스 시 HDD/SSD 접근

데이터 복사 과정:
원본 데이터는 유지하면서 상위 계층으로 복사
HDD → RAM → Cache → Register

```

### **성능 향상: 캐시 메모리와 같은 고속 메모리를 통해 전체 시스템 성능 개선.**

**성능 최적화 기법:**

```

지역성 원리 활용:
- 시간적 지역성: 최근 사용한 데이터를 다시 사용
- 공간적 지역성: 인접한 데이터를 함께 사용

프리페칭 (Prefetching):
- 필요할 것 같은 데이터를 미리 로드
- 하드웨어/소프트웨어 예측 알고리즘

파이프라이닝:
- 여러 메모리 접근을 동시에 처리
- 대기 시간 숨김 기법

압축 및 중복 제거:
- 메모리 사용량 최적화
- 전송 시간 단축

```

## 핵심 요약

1. **계층 구조**: Register → Cache → RAM → Storage 순으로 속도와 용량의 트레이드오프
2. **관리 체계**: 레지스터(이름) → RAM(주소) → HDD(트랙/섹터) → 파일시스템(파일명)
3. **데이터 흐름**: 하위 계층에서 상위 계층으로 복사하며 처리
4. **성능 최적화**: 지역성 원리와 캐싱으로 전체 시스템 효율성 향상
5. **선택 기준**: 용도에 따른 속도, 용량, 비용, 안정성의 균형점 찾기