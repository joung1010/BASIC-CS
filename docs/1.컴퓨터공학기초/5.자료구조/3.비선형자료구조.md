# 비선형 자료구조: 2차원의 효율성

## 🌳 2진 트리 (Binary Tree)

### **2진 트리의 기본 구조**

2진 트리 = 비선형 자료구조의 대표
핵심 특징: 각 노드마다 최대 2개의 자식 노드

구조적 특징:

- 자료당 두 개의 위치에 정보(링크) 저장
- 셋을 하나로 묶는 구조 (부모 1개 + 자식 2개)
- 계층적 구조 형성

기본 구조:
[부모 노드]
/          \
[왼쪽 자식]    [오른쪽 자식]

실제 예시 (이진 검색 트리):
[8]          ← 루트 (Root)
/     \
[3]     [10]     ← 레벨 1
/  \       \
[1]  [6]    [14]    ← 레벨 2
/  \    /
[4]  [7] [13]     ← 레벨 3

규칙: 왼쪽은 작은 값, 오른쪽은 큰 값

### 트리의 검색 과정

문제: 위 트리에서 5번을 찾아보자

검색 과정:
1단계: 루트(8)에서 시작
8과 5 비교 → 5 < 8 → 왼쪽으로 이동

2단계: 노드(3) 확인

3과 5 비교 → 5 > 3 → 오른쪽으로 이동

3단계: 노드(6) 확인
6과 5 비교 → 5 < 6 → 왼쪽으로 이동

4단계: 노드(4) 확인
4와 5 비교 → 5 > 4 → 오른쪽으로 이동
→ 오른쪽 자식이 없음 → 5는 트리에 없음

결과: 4번의 비교로 결론 도출!

선형 구조와 비교:
배열 [1, 3, 4, 6, 7, 8, 10, 13, 14]에서 5 찾기
→ 순차 검색: 최대 9번 비교 필요
→ 트리 검색: 4번 비교로 완료 (2배 이상 빠름)

### 왜 트리가 빠른가?

선형 구조의 한계:
[1] → [3] → [4] → [6] → [7] → [8] → [10] → [13] → [14]
한 번에 하나씩만 확인 가능
5를 찾기 위해: 1→3→4→6 순서대로 4번 확인

트리 구조의 장점:
매 단계마다 검색 범위를 절반으로 줄임

1단계: 전체 9개 → 8과 비교 → 왼쪽 4개로 범위 축소
[1, 3, 4, 6] vs [8, 10, 13, 14]

2단계: 4개 → 3과 비교 → 오른쪽 2개로 범위 축소

[1] vs [4, 6]

3단계: 2개 → 6과 비교 → 왼쪽 1개로 범위 축소
[4] vs []

4단계: 1개 → 4와 비교 → 결론 도출

핵심: 매번 절반씩 제거 → 기하급수적 성능 향상

### 성능 비교: 선형 vs 트리

데이터 개수별 최대 비교 횟수:

10개 데이터:

- 선형 구조: 10번
- 트리 구조: 4번 (log₂(10) ≈ 3.3)

100개 데이터:

- 선형 구조: 100번
- 트리 구조: 7번 (log₂(100) ≈ 6.6)

1,000개 데이터:

- 선형 구조: 1,000번
- 트리 구조: 10번 (log₂(1000) ≈ 9.9)

10,000개 데이터:

- 선형 구조: 10,000번
- 트리 구조: 14번 (log₂(10000) ≈ 13.3)

결론: 데이터가 많을수록 트리의 효과는 압도적!
선형은 O(n), 트리는 O(log n) 시간 복잡도

## 2진 트리의 단점과 개선

### **2진 트리의 문제점**

균형 잡힌 트리 (이상적):
[5]
/   \
[3]   [7]
/  \   /  \
[1] [4] [6] [8]

높이: 3, 최대 비교: 3번

불균형한 트리 (최악의 경우):
[1]
\
[2]
\
[3]

\
[4]
\
[5]
\
[6]
\
[7]
\
[8]

높이: 8, 최대 비교: 8번 (선형 구조와 동일!)

문제점:

- 데이터 삽입 순서에 따라 성능이 크게 달라짐
- 정렬된 데이터를 순서대로 삽입하면 선형 구조가 됨
- 트리의 장점을 전혀 활용할 수 없음

### 개선된 트리: AVL 트리

AVL 트리 = 자동으로 균형을 맞추는 트리

핵심 아이디어:
모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이를 1 이하로 유지

불균형 발생 시 자동 회전:

불균형한 상태:
[1]
\
[2]
\
[3]

자동 회전 후:
[2]
/   \
[1]   [3]

장점:

- 항상 O(log n) 성능 보장
- 최악의 경우에도 안정적
- 삽입/삭제 시 자동으로 균형 조정

단점:

- 구현이 복잡함
- 회전 연산으로 인한 약간의 오버헤드
- 메모리 사용량 증가 (균형 정보 저장)

### 다른 개선된 트리들

Red-Black 트리:

- 각 노드에 색깔(빨강/검정) 정보 추가
- 색깔 규칙으로 균형 유지
- AVL보다 삽입/삭제가 빠름
- Java의 TreeMap, C++의 map에서 사용

B-Tree:

- 한 노드에 여러 개의 데이터 저장
- 디스크 I/O 최적화
- 데이터베이스 인덱스에서 주로 사용
- 대용량 데이터 처리에 효율적

Trie (트라이):

- 문자열 검색에 특화
- 단어 자동완성, 사전 검색에 사용
- 메모리는 많이 사용하지만 문자열 검색이 매우 빠름

각각의 특화된 용도:

- AVL/Red-Black: 일반적인 검색/정렬
- B-Tree: 데이터베이스, 파일 시스템
- Trie: 문자열 처리, 검색 엔진

## 🕸️ 그래프 (Graph)

### **그래프의 기본 개념**

그래프 = 가장 일반적인 비선형 자료구조
트리의 확장된 형태

트리 vs 그래프:
트리: 계층적, 부모-자식 관계, 순환 없음
그래프: 네트워크적, 임의의 연결, 순환 가능

그래프 구조:
[A] ――― [B]
|   \   / |
|    \ /  |
[C] ――― [D]
|       |
[E] ――― [F]

특징:

- 노드(Vertex)들이 임의로 연결
- 방향성이 있을 수도, 없을 수도 있음
- 가중치(Weight)를 가질 수 있음
- 순환(Cycle) 허용

### 그래프의 실생활 응용

1. 지도/네비게이션:
   도시들 = 노드
   도로들 = 간선(Edge)
   거리/시간 = 가중치

   [서울] ―50km― [수원]
   |             |
   40km           30km

   |             |
   [인천] ―60km― [평택]

2. 소셜 네트워크:
   사람들 = 노드
   친구 관계 = 간선

   [철수] ――― [영희]
   |    \   /   |
   |     \ /    |
   [민수] ――― [지은]

3. 웹페이지 링크:
   웹페이지 = 노드

   하이퍼링크 = 간선

   구글의 PageRank 알고리즘이 이를 활용

4. 컴퓨터 네트워크:
   컴퓨터/라우터 = 노드
   네트워크 연결 = 간선
   대역폭 = 가중치
5. 게임 AI:
   게임 상태 = 노드
   가능한 행동 = 간선
   체스, 바둑 AI가 이를 활용

### 그래프 알고리즘들

1. 최단 경로 찾기:
   다익스트라(Dijkstra) 알고리즘
   → 네비게이션에서 최단 경로 계산
2. 최소 신장 트리:
   크루스칼(Kruskal) 알고리즘
   → 최소 비용으로 모든 노드 연결
3. 너비 우선 탐색 (BFS):
   → 최단 거리 탐색, 레벨별 탐색
4. 깊이 우선 탐색 (DFS):

   → 경로 존재 확인, 사이클 검출

5. 위상 정렬:
   → 작업 순서 결정 (프로젝트 스케줄링)
6. 네트워크 플로우:
   → 최대 유량 문제 (교통량, 데이터 전송량)

## 핵심 정리

### **비선형 자료구조의 핵심 가치**

1. **성능**: 선형 O(n) → 트리 O(log n) → 해시 O(1)
2. **표현력**: 복잡한 관계와 계층 구조 표현 가능
3. **확장성**: 대용량 데이터 처리에 필수

### **2진 트리**

- **장점**: 빠른 검색(O(log n)), 정렬 순서 유지
- **단점**: 불균형 시 성능 저하
- **해결책**: AVL, Red-Black 등 자가균형 트리

### **그래프**

- **표현력**: 가장 일반적인 관계 모델링
- **응용**: 네비게이션, 소셜네트워크, AI, 웹검색
- **복잡성**: 구현과 알고리즘이 가장 어려움