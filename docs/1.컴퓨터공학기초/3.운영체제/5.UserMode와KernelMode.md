# User Mode와 Kernel Mode

## 🏛️ 두 개의 세상: User Mode vs Kernel Mode

### **완전히 다른 권력 계층**

```
컴퓨터 국가의 권력 구조:

┌─────────────────────────────────────┐
│            User Mode                │  ← 일반 시민 영역
│     (일반 프로그램들의 세상)         │    (제한된 권한)
├─────────────────────────────────────┤
│    System Call Interface           │  ← 청원/요청 창구
├═════════════════════════════════════┤  ← 권력의 경계선
│            Kernel Mode              │  ← 통치 권력 영역
│        (OS의 핵심 영역)             │    (절대 권한)
└─────────────────────────────────────┘

핵심 차이점:
User Mode: 제한된 권한, 간접 접근만 가능
Kernel Mode: 무제한 권한, 직접 제어 가능
```

### **권한 수준의 차이**

```
CPU 권한 링 구조 (x86 기준):

Ring 0 (Kernel Mode):
- 모든 하드웨어 직접 접근 가능
- 모든 메모리 영역 접근 가능  
- 시스템 크리티컬 명령어 실행 가능
- 인터럽트 처리 가능

Ring 1, 2 (시스템 서비스):
- 제한적 권한
- 일부 시스템 기능만 접근

Ring 3 (User Mode):
- 제한된 명령어만 실행 가능
- 할당된 메모리만 접근 가능
- 하드웨어 직접 접근 불가
- 시스템 호출을 통해서만 커널 기능 이용
```

## ⚖️ 커널: 디지털 국가의 법과 정부

### **커널의 핵심 기능**

```
커널 = 컴퓨터 국가의 법 + 정부

1. I/O 제어 (입출력 관리):
   역할: 모든 하드웨어 접근 통제
   예시:
   - 파일 읽기/쓰기 요청 처리
   - 네트워크 통신 관리
   - 키보드/마우스 입력 처리
   - 화면 출력 제어

2. 자원 관리 (CPU + Memory):
   역할: 한정된 자원의 공정한 분배
   예시:
   - CPU 시간 스케줄링
   - 메모리 할당/회수
   - 프로세스 우선순위 관리
   - 데드락 방지

3. 접근 통제 (보안 관리):
   역할: 시스템 보안과 안정성 확보
   예시:
   - 프로세스 간 메모리 침범 방지
   - 파일 접근 권한 검사
   - 사용자 인증 및 권한 관리
   - 시스템 자원 보호
```

### **커널 모드에서 동작하는 소프트웨어**

```
일반적인 분류:

1. 운영체제 핵심 (Primary):
   - 프로세스 스케줄러
   - 메모리 관리자
   - 파일 시스템
   - 네트워크 스택

2. 디바이스 드라이버:
   - 그래픽 카드 드라이버
   - 네트워크 카드 드라이버
   - USB 드라이버
   - 오디오 드라이버

3. 보안 소프트웨어 (Special):
   - 은행/증권 보안 프로그램
   - 안티바이러스 커널 모듈
   - 방화벽 필터 드라이버
   - DRM 보호 모듈

특별한 경우 - 금융 보안 프로그램:
이유: 사용자 모드에서는 쉽게 우회/조작 가능
목적: 키로거 방지, 메모리 덤프 방지, 스크린샷 차단
방법: 커널 레벨에서 시스템 호출 후킹
```

## 🏗️ 시스템 아키텍처: 계층별 구조

### **전체 시스템 구조도**

```
전체 계층 구조:

┌─────────────────────────────────────┐
│            User Mode                │
│  ┌─────────┐ ┌─────────┐ ┌────────┐ │
│  │Chrome   │ │Word     │ │게임    │ │  ← 응용 프로그램
│  │Process  │ │Process  │ │Process │ │
│  └─────────┘ └─────────┘ └────────┘ │
├─────────────────────────────────────┤
│        System Call Interface       │  ← API 계층
├═════════════════════════════════════┤
│            Kernel Mode              │
│  ┌─────────────────────────────────┐ │
│  │         OS Kernel               │ │  ← 운영체제 핵심
│  │    (Process, Memory, File...)   │ │
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│            Software                 │
│  ┌─────────┐ ┌─────────┐ ┌────────┐ │  ← 드라이버 계층
│  │Graphics │ │Network  │ │Storage │ │
│  │Driver   │ │Driver   │ │Driver  │ │
│  └─────────┘ └─────────┘ └────────┘ │
├─────────────────────────────────────┤
│            Hardware                 │
│  ┌─────────┐ ┌─────────┐ ┌────────┐ │  ← 물리적 장치
│  │GPU      │ │Network  │ │HDD/SSD │ │
│  │Device   │ │Card     │ │Device  │ │
│  └─────────┘ └─────────┘ └────────┘ │
└─────────────────────────────────────┘
```

### **Physical vs Logical의 구분**

```
Physical (물리적) 계층:
- CPU: 실제 실리콘 칩, 트랜지스터들
- Memory: 물리적 DRAM 모듈
- Storage: 자기 디스크, SSD 낸드 플래시
- 특징: 만질 수 있는 실체, 전기적 신호

Logical (논리적) 계층:  
- 프로그램 코드: 명령어들의 집합
- 파일 시스템: 논리적 구조와 규칙
- 프로세스: 실행 중인 프로그램의 개념
- 특징: 개념적 존재, 소프트웨어로 구현
- Virtual 이라는 말과 호환되서 용

IT에서 Logical = Virtual:
- 가상 메모리: 물리 메모리를 논리적으로 확장
- 가상 파일 시스템: 다양한 저장소를 통합 관리
- 가상 네트워크: 물리 네트워크 위의 논리적 연결
```

## 🔗 플랫폼의 개념과 의존성

### **플랫폼이란?**

```
플랫폼의 정의:
"다른 것들이 작동할 수 있게 기반이 되어주는 인프라"

예시들:
건축: 건물의 기초 → 상위 구조물들이 서는 기반
철도: 승강장 플랫폼 → 기차와 승객이 만나는 기반
컴퓨터: HW + OS 플랫폼 → 응용프로그램이 실행되는 기반

64bit 플랫폼의 의미:
- CPU 아키텍처: 64비트 명령어 처리 가능
- 운영체제: 64비트 주소 공간 지원
- 메모리: 4GB 이상 사용 가능
- 응용프로그램: 64비트 코드로 컴파일 가능
```

### **하드웨어 의존성**

```
OS의 하드웨어 의존성:

Intel x86 플랫폼:
- Windows (x86/x64)
- Linux (i386/amd64)
- 명령어 세트: x86 어셈블리

ARM 플랫폼:
- Android
- iOS  
- 명령어 세트: ARM 어셈블리

RISC-V 플랫폼:
- 새로운 오픈소스 아키텍처
- 다양한 임베디드 OS

포팅(Porting)의 필요성:
같은 프로그램이라도 다른 플랫폼에서 실행하려면
소스코드 수정 + 재컴파일 필요
```

## 📱 디바이스 파일: User와 Kernel 사이의 다리

### **인터페이스로서의 디바이스 파일**

```
통신 구조:

User Process ↔ Device File ↔ Kernel ↔ Driver ↔ Hardware

구체적 예시:
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Chrome    │    │  /dev/video │    │  Graphics   │
│   Process   │ ←→ │   Device    │ ←→ │   Driver    │
│             │    │    File     │    │             │
└─────────────┘    └─────────────┘    └─────────────┘

디바이스 파일의 특성:
1. 파일 형태로 존재
2. 파일 시스템에 위치 (/dev/ 디렉토리)
3. 읽기/쓰기/실행 권한 적용
4. 실제 하드웨어와 1:1 대응
```

### **I/O 작업의 실제 과정**

```
"Hello World" 화면 출력 과정:

1. 프로세스 단계:
   printf("Hello World");
   ↓
   시스템 호출: write(stdout, "Hello World", 11)

2. 커널 단계:
   ↓
   디바이스 파일 접근: /dev/tty1
   ↓  
   권한 검사: 쓰기 권한 확인
   ↓
   그래픽 드라이버 호출

3. 드라이버 단계:
   ↓
   GPU 명령어 생성
   ↓
   비디오 메모리에 픽셀 데이터 쓰기

4. 하드웨어 단계:
   ↓
   GPU가 화면에 문자 렌더링
   ↓
   모니터에 "Hello World" 표시

키보드 입력 과정 (역방향):
키보드 → 드라이버 → 커널 → 디바이스 파일 → 프로세스
```

## 🛡️ 파일 기반 시스템 제어

### **"모든 것은 파일이다" 철학**

```
Unix/Linux의 핵심 철학:
"Everything is a file"

파일로 표현되는 것들:

일반 파일:
- 텍스트 파일: /home/user/document.txt
- 실행 파일: /bin/ls
- 라이브러리: /lib/libc.so

디바이스 파일:
- 터미널: /dev/tty1
- 하드디스크: /dev/sda1  
- 랜덤 생성기: /dev/random
- null 디바이스: /dev/null

시스템 정보 파일:
- 프로세스 정보: /proc/1234/status
- 시스템 정보: /proc/cpuinfo
- 메모리 정보: /proc/meminfo

네트워크 소켓:
- TCP 소켓: 파일 디스크립터로 관리
- Unix 도메인 소켓: 파일 시스템 경로 사용
```

### **접근 통제를 통한 시스템 제어**

```
파일 권한 시스템:

권한 비트 (rwx):
r (read): 읽기 권한
w (write): 쓰기 권한  
x (execute): 실행 권한

대상별 권한:
- owner (소유자): 파일을 만든 사용자
- group (그룹): 소유자와 같은 그룹
- others (기타): 나머지 모든 사용자

예시:
-rwxr-xr-- myfile.txt
소유자: 읽기+쓰기+실행
그룹: 읽기+실행
기타: 읽기만

시스템 제어 원리:
1. 모든 자원을 파일로 추상화
2. 파일 권한으로 접근 제어
3. 커널이 모든 접근 요청 검증
4. 권한 없는 접근은 차단 (Permission Denied)
```

## 🔍 실시간 보안 감시: 백신의 작동 원리

### **계층별 보안 구조**

```
보안 감시 시스템 구조:

┌─────────────────────────────────────┐
│            User Mode                │
│  ┌─────────┐          ┌───────────┐ │
│  │ 악성    │          │안티바이러스│ │
│  │프로세스 │          │UI 프로세스 │ │
│  └─────────┘          └───────────┘ │
├─────────────────────────────────────┤
│        System Call Interface       │
├═════════════════════════════════════┤
│            Kernel Mode              │
│  ┌─────────────────────────────────┐ │
│  │     File System Filter         │ │  ← 실시간 감시
│  │    (I/O 요청 가로채기)          │ │
│  └─────────────────────────────────┘ │
│  ┌─────────────────────────────────┐ │
│  │        File System              │ │
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│            Software                 │
│  ┌─────────────────────────────────┐ │
│  │         HDD Driver              │ │
│  └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│            Hardware                 │
│  ┌─────────────────────────────────┐ │
│  │           HDD                   │ │
│  └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### **실시간 감시 엔진의 동작 과정**

```
파일 접근 시 바이러스 검사 과정:

1. 사용자 프로세스:
   file = open("suspicious_file.exe")
   ↓

2. 시스템 호출:
   커널에게 파일 열기 요청
   ↓

3. 필터 드라이버 개입:
   ⚠️ 파일 접근 요청 가로채기
   ↓
   바이러스 검사 엔진에게 의뢰
   ↓
   
4. 바이러스 검사:
   - 파일 시그니처 분석
   - 휴리스틱 분석  
   - 행위 기반 분석
   - 클라우드 평판 조회
   ↓

5. 검사 결과에 따른 처리:
   
   안전한 파일인 경우:
   ✅ 정상적으로 파일 열기 허용
   
   위험한 파일인 경우:  
   ❌ 파일 접근 차단
   ❌ 격리 또는 삭제
   ❌ 사용자에게 경고 메시지

이 모든 과정이 실시간으로 발생!
```

## 🌐 가상화 기술: 하드웨어를 소프트웨어로 구현

### **가상화의 기본 개념**

가상 하드웨어 구성요소:

1. 가상 CPU (vCPU):
   물리적 구현: 실제 CPU 시간을 시분할하여 할당
   가상화 방식: 스케줄링으로 여러 VM에 번갈아 실행
   예시: 8코어 물리 CPU → 각 VM에 2vCPU씩 할당
2. 가상 메모리 (vRAM):
   물리적 구현: 실제 RAM을 논리적으로 분할
   가상화 방식: 메모리 맵핑과 페이징 기술 활용
   예시: 32GB 물리 RAM → VM1(8GB), VM2(8GB), VM3(16GB)
3. 가상 스토리지 (vDisk):
   물리적 구현: 실제 하드디스크 파일로 저장
   가상화 방식: 가상 디스크 이미지 (.vmdk, .vdi, .qcow2)
   예시: 500GB SSD → VM1.vmdk(100GB), VM2.vmdk(200GB)
4. 가상 네트워크 (vNIC):
   물리적 구현: 소프트웨어 네트워크 스위치
   가상화 방식: 네트워크 패킷 라우팅 및 브리징
   예시: 1개 물리 NIC → 여러 가상 네트워크 인터페이스

### **하드웨어 가상화의 원리**

```
1. 전가상화 (Full Virtualization):
   ┌─────────────────────────────────┐
   │  Guest OS (수정 불필요)         │
   ├─────────────────────────────────┤
   │  Hypervisor (Type 1: Bare Metal)│  ← 직접 하드웨어 위에
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: Guest OS가 가상화를 모름
   예시: VMware vSphere, Microsoft Hyper-V

2. 반가상화 (Para-Virtualization):
   ┌─────────────────────────────────┐
   │  Guest OS (수정됨)              │  ← 가상화 인식
   ├─────────────────────────────────┤
   │  Hypervisor                     │
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: Guest OS가 하이퍼바이저와 직접 통신
   예시: Xen (PV 모드)

3. 호스트형 가상화 (Type 2 Hypervisor):
   ┌─────────────────────────────────┐
   │  Guest OS                       │
   ├─────────────────────────────────┤
   │  Hypervisor (응용프로그램)       │
   ├─────────────────────────────────┤
   │  Host Operating System          │  ← 기존 OS 위에
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: 기존 OS 위에서 실행되는 프로그램
   예시: VMware Workstation, VirtualBox, Parallels
```

### **가상화 기술의 유형**

```
1. 전가상화 (Full Virtualization):
   ┌─────────────────────────────────┐
   │  Guest OS (수정 불필요)         │
   ├─────────────────────────────────┤
   │  Hypervisor (Type 1: Bare Metal)│  ← 직접 하드웨어 위에
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: Guest OS가 가상화를 모름
   예시: VMware vSphere, Microsoft Hyper-V

2. 반가상화 (Para-Virtualization):
   ┌─────────────────────────────────┐
   │  Guest OS (수정됨)              │  ← 가상화 인식
   ├─────────────────────────────────┤
   │  Hypervisor                     │
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: Guest OS가 하이퍼바이저와 직접 통신
   예시: Xen (PV 모드)

3. 호스트형 가상화 (Type 2 Hypervisor):
   ┌─────────────────────────────────┐
   │  Guest OS                       │
   ├─────────────────────────────────┤
   │  Hypervisor (응용프로그램)       │
   ├─────────────────────────────────┤
   │  Host Operating System          │  ← 기존 OS 위에
   ├─────────────────────────────────┤
   │  Physical Hardware              │
   └─────────────────────────────────┘
   
   특징: 기존 OS 위에서 실행되는 프로그램
   예시: VMware Workstation, VirtualBox, Parallels
```

### **가상화의 실제 동작 과정**

```
가상 머신에서 프로그램 실행 과정:

1. 가상 머신 내부:
   VM 프로그램이 시스템 호출 실행
   ↓

2. Guest OS:
   가상 운영체제가 요청을 받음
   가상 하드웨어에 명령어 전달
   ↓

3. Hypervisor (가상화 계층):
   ⚠️ 가상 하드웨어 요청을 가로채기
   물리 하드웨어 명령어로 변환
   ↓

4. Host OS (Type 2의 경우):
   실제 시스템 호출로 변환
   ↓

5. 물리 하드웨어:
   실제 작업 수행
   ↓ (역순으로 결과 전달)
   
6. 결과 반환:
   물리 HW → Host OS → Hypervisor → Guest OS → VM 프로그램

예시: VM에서 파일 저장
VM 내 텍스트 에디터 → 가상 디스크 쓰기 → 
하이퍼바이저 → 호스트 파일시스템의 .vmdk 파일 수정
```

### **가상화 기술의 활용 분야**

```
1. 서버 가상화:
   목적: 물리 서버 자원 효율적 활용
   방식: 1대 물리 서버에 여러 가상 서버
   효과: 하드웨어 비용 절감, 관리 효율성 증대
   
   예시:
   물리 서버 1대 (32코어, 128GB RAM)
   → 가상 서버 8대 (각 4코어, 16GB RAM)

2. 데스크톱 가상화 (VDI):
   목적: 중앙집중식 데스크톱 환경 제공
   방식: 서버에서 가상 데스크톱 실행, 클라이언트는 원격 접속
   효과: 보안 강화, 관리 용이성, 이동성 향상

3. 클라우드 컴퓨팅:
   목적: 온디맨드 IT 자원 제공
   방식: 거대한 데이터센터의 가상화된 자원을 인터넷으로 제공
   예시: AWS EC2, Azure VM, Google Compute Engine

4. 개발/테스트 환경:
   목적: 다양한 환경에서의 소프트웨어 테스트
   방식: 여러 OS, 버전별 가상 환경 구축
   효과: 개발 효율성 증대, 호환성 테스트 용이

5. 재해 복구 (DR):
   목적: 시스템 장애 시 빠른 복구
   방식: 가상 머신 이미지의 신속한 복제/이동
   효과: 복구 시간 단축, 비용 절감
```

### **컨테이너화: 또 다른 가상화 접근법**

```
가상 머신 vs 컨테이너:

가상 머신 (VM):
┌─────────────────────────────────┐
│  App1 │ App2 │ App3           │
├───────┼──────┼─────────────────┤
│ OS1   │ OS2  │ OS3            │  ← 각각 독립된 OS
├───────┴──────┴─────────────────┤
│        Hypervisor              │
├─────────────────────────────────┤
│         Host OS                │
├─────────────────────────────────┤
│      Physical Hardware         │
└─────────────────────────────────┘

컨테이너:
┌─────────────────────────────────┐
│  App1 │ App2 │ App3           │
├───────┼──────┼─────────────────┤
│    Container Runtime           │  ← OS 커널 공유
├─────────────────────────────────┤
│         Host OS                │
├─────────────────────────────────┤
│      Physical Hardware         │
└─────────────────────────────────┘

차이점:
VM: 하드웨어를 가상화 (무겁지만 강한 격리)
Container: OS를 가상화 (가볍지만 약한 격리)

예시: Docker, Kubernetes, LXC
```

### **가상화의 장단점**

장점:
✅ 자원 효율성: 하나의 물리 서버로 여러 환경 운영
✅ 격리성: 각 VM은 독립적, 한쪽 문제가 다른쪽 영향 없음
✅ 이식성: VM 이미지를 다른 하드웨어로 쉽게 이동
✅ 스냅샷: 특정 시점 상태 저장/복원 가능
✅ 확장성: 필요에 따라 자원 동적 할당/해제

단점:
❌ 성능 오버헤드: 가상화 계층으로 인한 성능 저하 (5-15%)
❌ 메모리 사용량: 각 VM마다 별도 OS 메모리 필요
❌ 복잡성: 관리해야 할 계층 증가
❌ 라이선스 비용: VM별 OS 라이선스 필요
❌ 보안 공격면: 하이퍼바이저도 공격 대상  

### **커널 모드 필터 드라이버의 중요성**

```
왜 커널 모드에서 감시해야 하는가?

User Mode 감시의 한계:
❌ 악성코드가 쉽게 우회 가능
❌ 프로세스 종료로 감시 기능 무력화
❌ 메모리 조작으로 감시 코드 변경 가능
❌ 관리자 권한으로 감시 프로세스 종료

Kernel Mode 감시의 장점:
✅ 모든 파일 I/O 요청 강제 통과
✅ 사용자 모드에서 우회 불가능
✅ 시스템 부팅부터 종료까지 지속 감시
✅ 최고 권한으로 보호되어 조작 어려움

실제 구현:
- Windows: File System Filter Driver
- Linux: LSM (Linux Security Module)
- 파일 시스템과 응용프로그램 사이에 위치
- 모든 I/O 요청을 의무적으로 검사
```

### **시스템 관리자 관점**

권한 관리:
- 사용자별 파일 접근 권한 설정
- 시스템 파일 보호 설정
- 디바이스 접근 권한 제어
- 보안 정책 수립 및 적용

모니터링:
- 시스템 호출 추적
- 파일 접근 로그 분석
- 비정상적인 커널 모드 활동 감지
- 성능 병목 지점 식별

보안 강화:
- 커널 모드 코드 서명 확인
- 루트킷 탐지 도구 활용
- 시스템 무결성 검사
- 정기적인 보안 업데이트

### **개발자 관점**

시스템 프로그래밍:
- 시스템 호출 API 활용
- 디바이스 드라이버 개발
- 커널 모듈 프로그래밍
- 파일 시스템 확장

보안 프로그래밍:
- 권한 최소화 원칙 적용
- 입력 검증 강화
- 버퍼 오버플로우 방지
- 시큐어 코딩 가이드라인 준수

성능 최적화:
- 시스템 호출 횟수 최소화
- 효율적인 I/O 패턴 설계
- 메모리 매핑 활용
- 비동기 I/O 구현

### **일반 사용자 관점**

보안 의식:
- 출처 불명 프로그램 설치 주의
- 관리자 권한 요구 프로그램 신중 검토
- 보안 프로그램 실시간 감시 기능 유지
- 시스템 업데이트 정기 실행

시스템 이해:
- 왜 일부 프로그램이 관리자 권한을 요구하는지 이해
- 커널 모드 프로그램의 위험성 인식
- 파일 권한의 중요성 이해
- 백신 프로그램의 동작 원리 이해

## 🔚 핵심 요약

### **User Mode vs Kernel Mode**

1. **권한 차이**: 제한된 권한 vs 무제한 권한
2. **접근 범위**: 할당된 자원만 vs 모든 시스템 자원
3. **안전성**: 높은 안전성 vs 높은 위험성
4. **목적**: 일반 작업 vs 시스템 제어

### **커널의 핵심 역할**

1. **I/O 제어**: 모든 하드웨어 접근 통제
2. **자원 관리**: CPU, 메모리 등 시스템 자원 관리
3. **접근 통제**: 보안과 안정성 확보

### **시스템 아키텍처**

1. **계층 구조**: Hardware → Driver → Kernel → User Application
2. **플랫폼 의존성**: OS는 하드웨어 아키텍처에 의존
3. **파일 기반 제어**: 모든 것을 파일로 추상화하여 관리

### **보안 메커니즘**

1. **실시간 감시**: 커널 레벨에서 모든 I/O 요청 검사
2. **권한 기반 접근 제어**: 파일 권한으로 시스템 자원 보호
3. **다층 보안**: User Mode와 Kernel Mode의 권한 분리