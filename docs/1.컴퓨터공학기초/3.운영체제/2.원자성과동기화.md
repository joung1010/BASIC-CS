# ì›ìì„±, ë™ê¸°í™”, êµì°©ìƒíƒœ: ì‹œìŠ¤í…œ ì•ˆì •ì„±ì˜ í•µì‹¬

## âš›ï¸ ì›ìì„± (Atomicity) ìƒì„¸ ë¶„ì„

### **ì›ìì„±ì˜ ê¸°ë³¸ ê°œë…**

**ì›ìì„±ì´ë€ ì‘ì—…ì´ "ì „ë¶€ ì„±ê³µí•˜ê±°ë‚˜ ì „ë¶€ ì‹¤íŒ¨í•˜ëŠ”" ì„±ì§ˆì…ë‹ˆë‹¤.**

```
ì›ì(Atom)ì˜ ì–´ì›:
ê·¸ë¦¬ìŠ¤ì–´ "atomos" = ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ëŠ” ê²ƒ

í”„ë¡œê·¸ë˜ë°ì—ì„œ:
ì›ìì  ì—°ì‚° = ì¤‘ê°„ì— ì¤‘ë‹¨ë˜ê±°ë‚˜ ë¶€ë¶„ì ìœ¼ë¡œ ì‹¤í–‰ë  ìˆ˜ ì—†ëŠ” ì—°ì‚°

```

### **ì€í–‰ ì†¡ê¸ˆ ì‹œìŠ¤í…œì—ì„œì˜ ì›ìì„±**

**ì†¡ê¸ˆ ê³¼ì •ì˜ ìƒì„¸ ë¶„ì„:**

```
Aê³„ì¢Œ â†’ Bê³„ì¢Œë¡œ 10ë§Œì› ì†¡ê¸ˆ

ì›ìì  íŠ¸ëœì­ì…˜:
BEGIN TRANSACTION
1. Aê³„ì¢Œ ì”ì•¡ í™•ì¸ (ì”ì•¡ >= 10ë§Œì›?)
2. Aê³„ì¢Œì—ì„œ 10ë§Œì› ì°¨ê°
3. Bê³„ì¢Œì— 10ë§Œì› ì¶”ê°€
4. ê±°ë˜ ë‚´ì—­ ë¡œê·¸ ê¸°ë¡
COMMIT TRANSACTION

ì„±ê³µ ì‹œ: ëª¨ë“  ë‹¨ê³„ ì™„ë£Œ â†’ ê±°ë˜ ì„±ê³µ
ì‹¤íŒ¨ ì‹œ: ì–´ëŠ ë‹¨ê³„ì—ì„œë“  ì‹¤íŒ¨ â†’ ëª¨ë“  ë³€ê²½ì‚¬í•­ ë¡¤ë°±

```

**ì›ìì„±ì´ ê¹¨ì§ˆ ë•Œì˜ ë¬¸ì œ:**

```
ìµœì•…ì˜ ì‹œë‚˜ë¦¬ì˜¤ (ì›ìì„± ë³´ì¥ ì—†ì„ ë•Œ):

ë‹¨ê³„ 1: Aê³„ì¢Œ ì”ì•¡ í™•ì¸ âœ“ (50ë§Œì›)
ë‹¨ê³„ 2: Aê³„ì¢Œì—ì„œ 10ë§Œì› ì°¨ê° âœ“ (40ë§Œì› ë¨)
ë‹¨ê³„ 3: ì‹œìŠ¤í…œ ì¥ì•  ë°œìƒ! âŒ
ë‹¨ê³„ 4: Bê³„ì¢Œ ì…ê¸ˆ ì‹¤íŒ¨ âŒ

ê²°ê³¼: Aê³„ì¢Œì—ì„œëŠ” ëˆì´ ë¹ ì¡Œì§€ë§Œ Bê³„ì¢Œì—ëŠ” ë“¤ì–´ê°€ì§€ ì•ŠìŒ
â†’ 10ë§Œì›ì´ ê³µì¤‘ìœ¼ë¡œ ì‚¬ë¼ì§ (ë°ì´í„° ë¬´ê²°ì„± íŒŒê´´)

```

### **ì›ìì„± êµ¬í˜„ ê¸°ìˆ **

**1. ë°ì´í„°ë² ì´ìŠ¤ íŠ¸ëœì­ì…˜**

```sql
-- SQLì—ì„œì˜ ì›ìì  ì†¡ê¸ˆ
BEGIN TRANSACTION;

UPDATE accounts
SET balance = balance - 100000
WHERE account_id = 'A001';

UPDATE accounts
SET balance = balance + 100000
WHERE account_id = 'B002';

INSERT INTO transfer_log
VALUES ('A001', 'B002', 100000, NOW());

-- ëª¨ë“  ì‘ì—…ì´ ì„±ê³µí•˜ë©´ ì»¤ë°‹
COMMIT;

-- í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ë¡¤ë°±
-- ROLLBACK; (ìë™ ì‹¤í–‰)

```

**2. ìë°”ì—ì„œì˜ ì›ìì  ì—°ì‚°**

```java
// ì›ìì„±ì´ ë³´ì¥ë˜ì§€ ì•ŠëŠ” ì½”ë“œ
class BankAccount {
    private int balance = 1000000;

    // ë¬¸ì œ: ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œ ì ‘ê·¼ ì‹œ ê²°ê³¼ ì˜ˆì¸¡ ë¶ˆê°€
    public void withdraw(int amount) {
        if (balance >= amount) {          // 1ë‹¨ê³„: í™•ì¸
            balance = balance - amount;   // 2ë‹¨ê³„: ì°¨ê°
        }
    }
}

// ì›ìì„± ë³´ì¥ ì½”ë“œ
class SafeBankAccount {
    private AtomicInteger balance = new AtomicInteger(1000000);

    public boolean withdraw(int amount) {
        while (true) {
            int currentBalance = balance.get();
            if (currentBalance < amount) {
                return false; // ì”ì•¡ ë¶€ì¡±
            }

            // compareAndSet: ì›ìì ìœ¼ë¡œ ë¹„êµ í›„ ì„¤ì •
            if (balance.compareAndSet(currentBalance, currentBalance - amount)) {
                return true; // ì„±ê³µ
            }
            // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ê°’ì„ ë³€ê²½í•¨)
        }
    }
}

```

**3. CPU ìˆ˜ì¤€ì˜ ì›ìì  ì—°ì‚°**

```
CPUê°€ ì œê³µí•˜ëŠ” ì›ìì  ëª…ë ¹ì–´:

Compare-And-Swap (CAS):
1. ë©”ëª¨ë¦¬ ê°’ê³¼ ì˜ˆìƒ ê°’ ë¹„êµ
2. ê°™ìœ¼ë©´ ìƒˆ ê°’ìœ¼ë¡œ ì„¤ì •
3. ë‹¤ë¥´ë©´ ì‹¤íŒ¨ ë°˜í™˜
4. ì´ ê³¼ì •ì´ ì›ìì ìœ¼ë¡œ ì‹¤í–‰ë¨

ì–´ì…ˆë¸”ë¦¬ ìˆ˜ì¤€:
LOCK CMPXCHG [memory], newValue
â†’ í•˜ë“œì›¨ì–´ê°€ ë³´ì¥í•˜ëŠ” ì›ìì„±

ì¥ì :
- ë½ ì—†ì´ë„ ì•ˆì „í•œ ë™ì‹œ ì ‘ê·¼
- ë°ë“œë½ ìœ„í—˜ ì—†ìŒ
- ë†’ì€ ì„±ëŠ¥

```

### **ì›ìì„± ìœ„ë°˜ ì‚¬ë¡€ì™€ í•´ê²°**

**ì‹¤ì œ ì‚¬ë¡€ 1: ê²Œì„ ì•„ì´í…œ ë³µì‚¬ ë²„ê·¸**

```
ë¬¸ì œ ìƒí™©:
ê²Œì„ì—ì„œ ì•„ì´í…œ ê±°ë˜ ì‹œ ì›ìì„± ë³´ì¥ ì‹¤íŒ¨

ê±°ë˜ ê³¼ì •:
1. í”Œë ˆì´ì–´A ì•„ì´í…œ ê°œìˆ˜ í™•ì¸
2. í”Œë ˆì´ì–´A ì•„ì´í…œ ê°ì†Œ
3. ë„¤íŠ¸ì›Œí¬ ì§€ì—° ë°œìƒ
4. í”Œë ˆì´ì–´B ì•„ì´í…œ ì¦ê°€ ì‹¤íŒ¨

ê²°ê³¼: ì•„ì´í…œì´ ì‚¬ë¼ì§ ë˜ëŠ” ë³µì‚¬ë¨

í•´ê²°ì±…:
ê²Œì„ ì„œë²„ì—ì„œ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
BEGIN TRANSACTION
    UPDATE player_items SET count = count - 1 WHERE player_id = 'A';
    UPDATE player_items SET count = count + 1 WHERE player_id = 'B';
    INSERT INTO trade_log VALUES (trade_details);
COMMIT;

```

**ì‹¤ì œ ì‚¬ë¡€ 2: ì›¹ì‚¬ì´íŠ¸ ì¡°íšŒìˆ˜ ì˜¤ë¥˜**

```java
// ë¬¸ì œ: ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œì— ê¸€ì„ ë³¼ ë•Œ ì¡°íšŒìˆ˜ ë¶€ì •í™•

// ë¹„ì›ìì  ì½”ë“œ:
public void increaseViewCount(Long postId) {
    Post post = repository.findById(postId);    // 1. í˜„ì¬ ê°’ ì½ê¸°
    int currentViews = post.getViewCount();     // 2. ì¡°íšŒìˆ˜ ê°€ì ¸ì˜¤ê¸°
    post.setViewCount(currentViews + 1);        // 3. +1 ì¦ê°€
    repository.save(post);                      // 4. ì €ì¥
}

// ë¬¸ì œì :
// ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œ ì ‘ê·¼ ì‹œ ê°™ì€ ê°’ì„ ì½ê³  +1 í•˜ì—¬
// ì‹¤ì œë³´ë‹¤ ì ì€ ì¡°íšŒìˆ˜ê°€ ì¹´ìš´íŠ¸ë¨

// ì›ìì  í•´ê²°ì±…:
@Query("UPDATE Post p SET p.viewCount = p.viewCount + 1 WHERE p.id = :id")
@Modifying
void increaseViewCount(@Param("id") Long postId);
// â†’ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì›ìì ìœ¼ë¡œ ì¦ê°€

```

## ğŸ”„ ë™ê¸°í™” (Synchronization) ìƒì„¸ ë¶„ì„

### **ë™ê¸°í™”ì˜ í•„ìš”ì„±**

**ë™ê¸°í™”ë€ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤/ìŠ¤ë ˆë“œê°€ ê³µìœ  ìì›ì— ì ‘ê·¼í•  ë•Œ ë°ì´í„° ì¼ê´€ì„±ì„ ë³´ì¥í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.**

```
ê³µìœ  ìì›ì˜ ì˜ˆ:
- ë©”ëª¨ë¦¬ì˜ íŠ¹ì • ë³€ìˆ˜
- íŒŒì¼
- ë°ì´í„°ë² ì´ìŠ¤ ë ˆì½”ë“œ
- ë„¤íŠ¸ì›Œí¬ ì—°ê²°
- í”„ë¦°í„°, ìŠ¤ìºë„ˆ ë“± í•˜ë“œì›¨ì–´

ë™ê¸°í™”ê°€ ì—†ì„ ë•Œì˜ ë¬¸ì œ:
â†’ ê²½ìŸ ìƒíƒœ (Race Condition)
â†’ ë°ì´í„° ë¶ˆì¼ì¹˜
â†’ ì‹œìŠ¤í…œ ì˜¤ë¥˜

```

### **ë™ê¸°í™”ê°€ í•„ìš”í•˜ì§€ ì•Šì€ ê²½ìš°**

**1. ë‹¨ì¼ ìŠ¤ë ˆë“œ í™˜ê²½**

```java
// ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œëŠ” ë™ê¸°í™” ë¶ˆí•„ìš”
public class SingleThreadExample {
    private int counter = 0;

    public void increment() {
        counter++;  // ì•ˆì „í•¨ - í•œ ë²ˆì— í•˜ë‚˜ì˜ ì‹¤í–‰ë§Œ ë°œìƒ
    }

    public static void main(String[] args) {
        SingleThreadExample example = new SingleThreadExample();
        for (int i = 0; i < 1000; i++) {
            example.increment();
        }
        System.out.println(example.counter); // í•­ìƒ 1000
    }
}

```

**2. ì½ê¸° ì „ìš© ë°ì´í„°**

```java
// ë¶ˆë³€ ê°ì²´ëŠ” ë™ê¸°í™” ë¶ˆí•„ìš”
public final class ImmutableConfig {
    private final String serverUrl;
    private final int timeout;

    public ImmutableConfig(String serverUrl, int timeout) {
        this.serverUrl = serverUrl;
        this.timeout = timeout;
    }

    // getterë§Œ ì œê³µ, setter ì—†ìŒ
    public String getServerUrl() { return serverUrl; }
    public int getTimeout() { return timeout; }
}

// ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ì–´ë„ ì•ˆì „

```

**3. ìŠ¤ë ˆë“œ ë¡œì»¬ ë°ì´í„°**

```java
// ê° ìŠ¤ë ˆë“œê°€ ë…ë¦½ì ì¸ ë°ì´í„° ì‚¬ìš©
public class ThreadLocalExample {
    private static ThreadLocal<Integer> threadLocalValue =
        ThreadLocal.withInitial(() -> 0);

    public void increment() {
        int value = threadLocalValue.get();
        threadLocalValue.set(value + 1);  // ë™ê¸°í™” ë¶ˆí•„ìš”
    }
}

```

### **ë™ê¸°í™”ê°€ í•„ìš”í•œ ê²½ìš°**

**1. ê³µìœ  ë³€ìˆ˜ ìˆ˜ì •**

```java
// ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ (ë™ê¸°í™” ì—†ìŒ)
public class UnsafeCounter {
    private int count = 0;

    public void increment() {
        count++;  // ì›ìì ì´ì§€ ì•ŠìŒ!
        // ì‹¤ì œë¡œëŠ”: temp = count; temp++; count = temp;
    }
}

// ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œ ì‹¤í–‰ ì‹œ:
// ìŠ¤ë ˆë“œA: temp = 0; temp++; (ì¤‘ë‹¨ë¨)
// ìŠ¤ë ˆë“œB: temp = 0; temp++; count = 1;
// ìŠ¤ë ˆë“œA: count = 1; (ê³„ì† ì‹¤í–‰)
// ê²°ê³¼: 2ë²ˆ ì¦ê°€í–ˆì§€ë§Œ countëŠ” 1 (ì†ì‹¤ ë°œìƒ)

```

**2. íŒŒì¼ ì‹œìŠ¤í…œ ì ‘ê·¼**

```java
// ì•ˆì „í•˜ì§€ ì•Šì€ íŒŒì¼ ì“°ê¸°
public class UnsafeFileWriter {
    public void writeToFile(String content) {
        try (FileWriter writer = new FileWriter("shared.txt", true)) {
            writer.write(content + "\n");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œ ì‹¤í–‰ ì‹œ:
// ìŠ¤ë ˆë“œA: "Hello" ì“°ê¸° ì‹œì‘
// ìŠ¤ë ˆë“œB: "World" ì“°ê¸° ì‹œì‘
// ê²°ê³¼: "HWoerlllod" (ê¸€ìê°€ ì„ì„)

// ì•ˆì „í•œ íŒŒì¼ ì“°ê¸°
public class SafeFileWriter {
    private final Object lock = new Object();

    public void writeToFile(String content) {
        synchronized (lock) {  // ë™ê¸°í™” ë¸”ë¡
            try (FileWriter writer = new FileWriter("shared.txt", true)) {
                writer.write(content + "\n");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

```

### **ë™ê¸°í™” êµ¬í˜„ ë°©ë²•ë“¤**

**1. synchronized í‚¤ì›Œë“œ (Java)**

```java
public class SynchronizedCounter {
    private int count = 0;

    // ë©”ì„œë“œ ì „ì²´ ë™ê¸°í™”
    public synchronized void increment() {
        count++;
    }

    // ë¸”ë¡ ë‹¨ìœ„ ë™ê¸°í™”
    public void decrement() {
        synchronized (this) {
            count--;
        }
    }

    // í´ë˜ìŠ¤ ë ˆë²¨ ë™ê¸°í™”
    public static synchronized void staticMethod() {
        // ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•´ ë™ê¸°í™”
    }
}

```

**2. ReentrantLock (ê³ ê¸‰ ë™ê¸°í™”)**

```java
import java.util.concurrent.locks.ReentrantLock;

public class LockCounter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock();  // ë½ íšë“
        try {
            count++;
        } finally {
            lock.unlock();  // ë°˜ë“œì‹œ ì–¸ë½
        }
    }

    // ì‹œë„í•´ë³´ê³  ì‹¤íŒ¨í•˜ë©´ í¬ê¸°
    public boolean tryIncrement() {
        if (lock.tryLock()) {
            try {
                count++;
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;  // ë½ íšë“ ì‹¤íŒ¨
    }
}

```

**3. ì„¸ë§ˆí¬ì–´ (Semaphore)**

```java
import java.util.concurrent.Semaphore;

// ë™ì‹œì— 3ëª…ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ìì›
public class LimitedResource {
    private final Semaphore semaphore = new Semaphore(3);

    public void useResource() {
        try {
            semaphore.acquire();  // í—ˆê°€ íšë“ (ì—†ìœ¼ë©´ ëŒ€ê¸°)
            System.out.println("ìì› ì‚¬ìš© ì¤‘...");
            Thread.sleep(2000);   // ì‘ì—… ìˆ˜í–‰
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            semaphore.release();  // í—ˆê°€ ë°˜ë‚©
        }
    }
}

```

**4. ì¡°ê±´ ë³€ìˆ˜ (Condition Variable)**

```java
import java.util.concurrent.locks.*;

public class ProducerConsumer {
    private final Queue<String> queue = new LinkedList<>();
    private final int capacity = 10;
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    // ìƒì‚°ì
    public void produce(String item) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                notFull.await();  // íê°€ ê°€ë“ ì°¨ë©´ ëŒ€ê¸°
            }
            queue.offer(item);
            notEmpty.signal();    // ì†Œë¹„ìì—ê²Œ ì‹ í˜¸
        } finally {
            lock.unlock();
        }
    }

    // ì†Œë¹„ì
    public String consume() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                notEmpty.await(); // íê°€ ë¹„ì–´ìˆìœ¼ë©´ ëŒ€ê¸°
            }
            String item = queue.poll();
            notFull.signal();    // ìƒì‚°ìì—ê²Œ ì‹ í˜¸
            return item;
        } finally {
            lock.unlock();
        }
    }
}

```

## ğŸ”’ êµì°©ìƒíƒœ (Deadlock) ìƒì„¸ ë¶„ì„

### **êµì°©ìƒíƒœì˜ ê¸°ë³¸ ê°œë…**

**êµì°©ìƒíƒœë€ ë‘ ê°œ ì´ìƒì˜ í”„ë¡œì„¸ìŠ¤ê°€ ì„œë¡œ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì ìœ í•œ ìì›ì„ ë¬´í•œì • ê¸°ë‹¤ë¦¬ëŠ” ìƒí™©ì…ë‹ˆë‹¤.**

```
í™”ì¥ì‹¤ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°:

ìƒí™©:
- í™”ì¥ì‹¤ì— Aì”¨ê°€ ë“¤ì–´ê°€ ìˆìŒ (íœ´ì§€ ì—†ìŒ)
- ë°–ì— Bì”¨ê°€ íœ´ì§€ë¥¼ ë“¤ê³  ëŒ€ê¸° ì¤‘

Aì”¨ì˜ ìƒí™©: íœ´ì§€ê°€ ì—†ì–´ì„œ ë‚˜ê°ˆ ìˆ˜ ì—†ìŒ
Bì”¨ì˜ ìƒí™©: Aì”¨ê°€ ë‚˜ì™€ì•¼ ë“¤ì–´ê°ˆ ìˆ˜ ìˆìŒ

ê²°ê³¼: ë‘˜ ë‹¤ ë¬´í•œì • ëŒ€ê¸° â†’ êµì°©ìƒíƒœ

í•´ê²° ë°©ë²•:
1. ë¯¸ë¦¬ íœ´ì§€ë¥¼ í™•ì¸í•˜ê³  ë“¤ì–´ê°€ê¸° (ì˜ˆë°©)
2. ì¼ì • ì‹œê°„ í›„ ê°•ì œë¡œ ë‚˜ì˜¤ê¸° (íƒ€ì„ì•„ì›ƒ)
3. ê´€ë¦¬ì¸ì´ ìƒí™© íŒŒì•… í›„ í•´ê²° (íƒì§€ ë° íšŒë³µ)

```

### **êµì°©ìƒíƒœ ë°œìƒ ì¡°ê±´ (Coffman ì¡°ê±´)**

**êµì°©ìƒíƒœê°€ ë°œìƒí•˜ë ¤ë©´ ë‹¤ìŒ 4ê°€ì§€ ì¡°ê±´ì´ ëª¨ë‘ ë§Œì¡±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤:**

```
1. ìƒí˜¸ ë°°ì œ (Mutual Exclusion):
   - ìì›ì„ í•œ ë²ˆì— í•˜ë‚˜ì˜ í”„ë¡œì„¸ìŠ¤ë§Œ ì‚¬ìš© ê°€ëŠ¥
   - ì˜ˆ: í”„ë¦°í„°ëŠ” ë™ì‹œì— ì—¬ëŸ¬ ë¬¸ì„œ ì¸ì‡„ ë¶ˆê°€

2. ì ìœ ì™€ ëŒ€ê¸° (Hold and Wait):
   - í”„ë¡œì„¸ìŠ¤ê°€ ìì›ì„ ì ìœ í•œ ìƒíƒœì—ì„œ ë‹¤ë¥¸ ìì›ì„ ëŒ€ê¸°
   - ì˜ˆ: Aê°€ í”„ë¦°í„°ë¥¼ ì“°ë©´ì„œ ìŠ¤ìºë„ˆë„ ê¸°ë‹¤ë¦¼

3. ë¹„ì„ ì  (Non-preemption):
   - ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì ìœ í•œ ìì›ì„ ê°•ì œë¡œ ë¹¼ì•—ì„ ìˆ˜ ì—†ìŒ
   - ì˜ˆ: ì‚¬ìš© ì¤‘ì¸ íŒŒì¼ì„ ê°•ì œë¡œ ëºì„ ìˆ˜ ì—†ìŒ

4. ìˆœí™˜ ëŒ€ê¸° (Circular Wait):
   - í”„ë¡œì„¸ìŠ¤ë“¤ì´ ì›í˜•ìœ¼ë¡œ ì„œë¡œì˜ ìì›ì„ ê¸°ë‹¤ë¦¼
   - ì˜ˆ: Aâ†’Bâ†’Câ†’A ìˆœì„œë¡œ ëŒ€ê¸°

```

### **êµì°©ìƒíƒœ ì˜ˆì‹œ ì½”ë“œ**

**1. ê°„ë‹¨í•œ êµì°©ìƒíƒœ**

```java
public class SimpleDeadlock {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread1: lock1 íšë“");
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                synchronized (lock2) {  // lock2 ëŒ€ê¸°
                    System.out.println("Thread1: lock2 íšë“");
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread2: lock2 íšë“");
                try { Thread.sleep(100); } catch (InterruptedException e) {}

                synchronized (lock1) {  // lock1 ëŒ€ê¸°
                    System.out.println("Thread2: lock1 íšë“");
                }
            }
        });

        thread1.start();
        thread2.start();
        // ê²°ê³¼: êµì°©ìƒíƒœ ë°œìƒ, í”„ë¡œê·¸ë¨ ë©ˆì¶¤
    }
}

```

**2. ì€í–‰ ê³„ì¢Œ êµì°©ìƒíƒœ**

```java
public class BankDeadlock {
    static class Account {
        private int balance;
        private final int id;

        public Account(int id, int balance) {
            this.id = id;
            this.balance = balance;
        }

        public synchronized void withdraw(int amount) {
            balance -= amount;
        }

        public synchronized void deposit(int amount) {
            balance += amount;
        }
    }

    // êµì°©ìƒíƒœë¥¼ ì¼ìœ¼í‚¤ëŠ” ì†¡ê¸ˆ ë©”ì„œë“œ
    public static void transfer(Account from, Account to, int amount) {
        synchronized (from) {
            System.out.println("ê³„ì¢Œ " + from.id + " ë½ íšë“");
            try { Thread.sleep(100); } catch (InterruptedException e) {}

            synchronized (to) {  // ë‹¤ë¥¸ ê³„ì¢Œ ë½ ëŒ€ê¸°
                from.withdraw(amount);
                to.deposit(amount);
                System.out.println(amount + "ì› ì†¡ê¸ˆ ì™„ë£Œ");
            }
        }
    }

    public static void main(String[] args) {
        Account account1 = new Account(1, 1000);
        Account account2 = new Account(2, 1000);

        // Aâ†’B ì†¡ê¸ˆê³¼ Bâ†’A ì†¡ê¸ˆì´ ë™ì‹œì— ë°œìƒ
        new Thread(() -> transfer(account1, account2, 100)).start();
        new Thread(() -> transfer(account2, account1, 200)).start();
        // êµì°©ìƒíƒœ ë°œìƒ!
    }
}

```

### **êµì°©ìƒíƒœ í•´ê²° ë°©ë²•**

**1. ì˜ˆë°© (Prevention)**

```java
// ë°©ë²• 1: ìì› ìˆœì„œ ì •í•˜ê¸°
public static void safeTransfer(Account from, Account to, int amount) {
    // ê³„ì¢Œ ID ìˆœì„œë¡œ ë½ íšë“ (ìˆœí™˜ ëŒ€ê¸° ë°©ì§€)
    Account firstLock = from.id < to.id ? from : to;
    Account secondLock = from.id < to.id ? to : from;

    synchronized (firstLock) {
        synchronized (secondLock) {
            from.withdraw(amount);
            to.deposit(amount);
        }
    }
}

// ë°©ë²• 2: ëª¨ë“  ìì›ì„ í•œ ë²ˆì— íšë“
public static void atomicTransfer(Account from, Account to, int amount) {
    synchronized (globalLock) {  // ì „ì—­ ë½ ì‚¬ìš©
        from.withdraw(amount);
        to.deposit(amount);
    }
    // ë‹¨ì : ë™ì‹œì„± ì„±ëŠ¥ ì €í•˜
}

```

**2. íšŒí”¼ (Avoidance) - ì€í–‰ì› ì•Œê³ ë¦¬ì¦˜**

```java
public class BankersAlgorithm {
    private int[][] allocation;    // í˜„ì¬ í• ë‹¹ëœ ìì›
    private int[][] max;          // ìµœëŒ€ í•„ìš” ìì›
    private int[] available;      // ì‚¬ìš© ê°€ëŠ¥í•œ ìì›

    public boolean isSafeState() {
        int[] work = available.clone();
        boolean[] finished = new boolean[processes];

        for (int count = 0; count < processes; count++) {
            int found = -1;
            for (int p = 0; p < processes; p++) {
                if (!finished[p]) {
                    int j;
                    for (j = 0; j < resources; j++) {
                        if (max[p][j] - allocation[p][j] > work[j]) {
                            break;
                        }
                    }

                    if (j == resources) {
                        found = p;
                        break;
                    }
                }
            }

            if (found == -1) {
                return false;  // ì•ˆì „í•˜ì§€ ì•Šì€ ìƒíƒœ
            }

            finished[found] = true;
            for (int j = 0; j < resources; j++) {
                work[j] += allocation[found][j];
            }
        }
        return true;  // ì•ˆì „í•œ ìƒíƒœ
    }
}

```

**3. íƒì§€ ë° íšŒë³µ (Detection and Recovery)**

```java
public class DeadlockDetector {
    private static final int TIMEOUT_MS = 5000;

    public static boolean tryTransferWithTimeout(Account from, Account to, int amount) {
        long startTime = System.currentTimeMillis();

        while (System.currentTimeMillis() - startTime < TIMEOUT_MS) {
            if (from.tryLock()) {
                try {
                    if (to.tryLock()) {
                        try {
                            // ì†¡ê¸ˆ ì‹¤í–‰
                            from.withdraw(amount);
                            to.deposit(amount);
                            return true;
                        } finally {
                            to.unlock();
                        }
                    }
                } finally {
                    from.unlock();
                }
            }

            // ì ì‹œ ëŒ€ê¸° í›„ ì¬ì‹œë„
            try { Thread.sleep(10); } catch (InterruptedException e) {}
        }

        return false;  // íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ì‹¤íŒ¨
    }
}

```

**4. ë¬´ì‹œ (Ostrich Algorithm)**

```
íƒ€ì¡° ì•Œê³ ë¦¬ì¦˜:
- êµì°©ìƒíƒœê°€ ë°œìƒí•  í™•ë¥ ì´ ë§¤ìš° ë‚®ì„ ë•Œ ì‚¬ìš©
- ë°œìƒ ì‹œ ì‹œìŠ¤í…œ ì¬ì‹œì‘ìœ¼ë¡œ í•´ê²°
- ì˜ˆë°©/íšŒí”¼/íƒì§€ ë¹„ìš©ì´ êµì°©ìƒíƒœ ì†ì‹¤ë³´ë‹¤ í´ ë•Œ

í˜„ì‹¤ì  ì„ íƒ:
- ëŒ€ë¶€ë¶„ì˜ ìš´ì˜ì²´ì œê°€ ì±„íƒ
- ì‚¬ìš©ìê°€ í”„ë¡œê·¸ë¨ ê°•ì œ ì¢…ë£Œ
- ì‹œìŠ¤í…œ ì•ˆì •ì„±ë³´ë‹¤ ì„±ëŠ¥ ìš°ì„ 

```

### **ì‹¤ì œ êµì°©ìƒíƒœ ì‚¬ë¡€**

**1. ì›¹ ì„œë²„ì—ì„œì˜ êµì°©ìƒíƒœ**

```java
// ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œ
public class WebServerDeadlock {
    private final Map<String, User> userCache = new ConcurrentHashMap<>();
    private final Map<String, Session> sessionCache = new ConcurrentHashMap<>();

    public void loginUser(String userId, String sessionId) {
        synchronized (userCache) {
            User user = userCache.get(userId);
            synchronized (sessionCache) {  // ìˆœì„œ: user â†’ session
                sessionCache.put(sessionId, new Session(user));
            }
        }
    }

    public void logoutUser(String sessionId) {
        synchronized (sessionCache) {
            Session session = sessionCache.get(sessionId);
            synchronized (userCache) {  // ìˆœì„œ: session â†’ user
                userCache.remove(session.getUserId());
            }
        }
    }
    // ë¡œê·¸ì¸ê³¼ ë¡œê·¸ì•„ì›ƒì´ ë™ì‹œì— ë°œìƒí•˜ë©´ êµì°©ìƒíƒœ!
}

// í•´ê²°ëœ ì½”ë“œ
public class SafeWebServer {
    private final Object globalLock = new Object();

    public void loginUser(String userId, String sessionId) {
        synchronized (globalLock) {  // í•­ìƒ ê°™ì€ ë½ ì‚¬ìš©
            User user = userCache.get(userId);
            sessionCache.put(sessionId, new Session(user));
        }
    }

    public void logoutUser(String sessionId) {
        synchronized (globalLock) {  // í•­ìƒ ê°™ì€ ë½ ì‚¬ìš©
            Session session = sessionCache.get(sessionId);
            userCache.remove(session.getUserId());
        }
    }
}

```

**2. ë°ì´í„°ë² ì´ìŠ¤ êµì°©ìƒíƒœ**

```sql
-- íŠ¸ëœì­ì…˜ 1
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- (ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ì‹¤í–‰ë¨)
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

-- íŠ¸ëœì­ì…˜ 2 (ë™ì‹œ ì‹¤í–‰)
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
-- (íŠ¸ëœì­ì…˜ 1ì´ id=2ë¥¼ ê¸°ë‹¤ë¦¼)
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
-- êµì°©ìƒíƒœ ë°œìƒ!
COMMIT;

-- ë°ì´í„°ë² ì´ìŠ¤ê°€ ìë™ìœ¼ë¡œ í•˜ë‚˜ë¥¼ ë¡¤ë°±í•¨

```

## ğŸ› ï¸ ì¢…í•© ì˜ˆì œ: ì•ˆì „í•œ ì€í–‰ ì‹œìŠ¤í…œ

```java
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

public class SafeBankSystem {

    static class Account {
        private final int id;
        private int balance;
        private final ReentrantLock lock = new ReentrantLock();

        public Account(int id, int balance) {
            this.id = id;
            this.balance = balance;
        }

        public boolean tryLock(long timeout, TimeUnit unit) {
            try {
                return lock.tryLock(timeout, unit);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return false;
            }
        }

        public void unlock() {
            lock.unlock();
        }

        public void withdraw(int amount) {
            if (balance >= amount) {
                balance -= amount;
            } else {
                throw new IllegalStateException("ì”ì•¡ ë¶€ì¡±");
            }
        }

        public void deposit(int amount) {
            balance += amount;
        }

        public int getBalance() {
            return balance;
        }
    }

    // ì›ìì„±, ë™ê¸°í™”, êµì°©ìƒíƒœ ë°©ì§€ë¥¼ ëª¨ë‘ ê³ ë ¤í•œ ì†¡ê¸ˆ
    public static boolean atomicTransfer(Account from, Account to, int amount) {
        // êµì°©ìƒíƒœ ë°©ì§€: ID ìˆœì„œë¡œ ë½ íšë“
        Account firstLock = from.id < to.id ? from : to;
        Account secondLock = from.id < to.id ? to : from;

        // íƒ€ì„ì•„ì›ƒìœ¼ë¡œ êµì°©ìƒíƒœ íšŒí”¼
        if (firstLock.tryLock(1, TimeUnit.SECONDS)) {
            try {
                if (secondLock.tryLock(1, TimeUnit.SECONDS)) {
                    try {
                        // ì›ìì  íŠ¸ëœì­ì…˜ ì‹¤í–‰
                        if (from.getBalance() >= amount) {
                            from.withdraw(amount);
                            to.deposit(amount);
                            System.out.println(
                                String.format("ì†¡ê¸ˆ ì„±ê³µ: %dì› (%dâ†’%d)",
                                amount, from.id, to.id)
                            );
                            return true;
                        } else {
                            System.out.println("ì†¡ê¸ˆ ì‹¤íŒ¨: ì”ì•¡ ë¶€ì¡±");
                            return false;
                        }
                    } finally {
                        secondLock.unlock();
                    }
                } else {
                    System.out.println("ì†¡ê¸ˆ ì‹¤íŒ¨: ë½ íšë“ íƒ€ì„ì•„ì›ƒ");
                    return false;
                }
            } finally {
                firstLock.unlock();
            }
        } else {
            System.out.println("ì†¡ê¸ˆ ì‹¤íŒ¨: ë½ íšë“ íƒ€ì„ì•„ì›ƒ");
            return false;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Account account1 = new Account(1, 1000);
        Account account2 = new Account(2, 1000);

        // ë™ì‹œ ì†¡ê¸ˆ í…ŒìŠ¤íŠ¸
        Thread t1 = new Thread(() ->
            atomicTransfer(account1, account2, 100)
        );
        Thread t2 = new Thread(() ->
            atomicTransfer(account2, account1, 200)
        );

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("ìµœì¢… ì”ì•¡:");
        System.out.println("ê³„ì¢Œ1: " + account1.getBalance());
        System.out.println("ê³„ì¢Œ2: " + account2.getBalance());
        System.out.println("ì´í•©: " + (account1.getBalance() + account2.getBalance()));
        // ì›ìì„± ë³´ì¥ìœ¼ë¡œ ì´í•©ì€ í•­ìƒ 2000ì› ìœ ì§€
    }
}

```

## ğŸ¯ ì„±ëŠ¥ ìµœì í™”ì™€ íŠ¸ë ˆì´ë“œì˜¤í”„

### **ë™ê¸°í™” ì„±ëŠ¥ ë¹„êµ**

```java
// ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì½”ë“œ
public class SynchronizationPerformance {
    private static final int ITERATIONS = 10_000_000;
    private int counter = 0;
    private final AtomicInteger atomicCounter = new AtomicInteger(0);
    private final ReentrantLock lock = new ReentrantLock();

    // 1. synchronized ë°©ì‹
    public synchronized void synchronizedIncrement() {
        counter++;
    }

    // 2. ReentrantLock ë°©ì‹
    public void lockIncrement() {
        lock.lock();
        try {
            counter++;
        } finally {
            lock.unlock();
        }
    }

    // 3. AtomicInteger ë°©ì‹ (lock-free)
    public void atomicIncrement() {
        atomicCounter.incrementAndGet();
    }

    // 4. ë™ê¸°í™” ì—†ìŒ (ê¸°ì¤€ì )
    public void unsafeIncrement() {
        counter++;  // ê²°ê³¼ëŠ” ë¶€ì •í™•í•˜ì§€ë§Œ ê°€ì¥ ë¹ ë¦„
    }

    public static void benchmarkSynchronization() {
        SynchronizationPerformance perf = new SynchronizationPerformance();

        // synchronized ì„±ëŠ¥ ì¸¡ì •
        long startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            perf.synchronizedIncrement();
        }
        long syncTime = System.nanoTime() - startTime;

        // AtomicInteger ì„±ëŠ¥ ì¸¡ì •
        startTime = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            perf.atomicIncrement();
        }
        long atomicTime = System.nanoTime() - startTime;

        System.out.println("ì„±ëŠ¥ ë¹„êµ (1000ë§Œ íšŒ ì¦ê°€):");
        System.out.printf("synchronized: %.2fì´ˆ\n", syncTime / 1e9);
        System.out.printf("AtomicInteger: %.2fì´ˆ\n", atomicTime / 1e9);
        System.out.printf("ì„±ëŠ¥ ì°¨ì´: %.1fë°°\n", (double)syncTime / atomicTime);
    }
}

// ì¼ë°˜ì ì¸ ê²°ê³¼:
// synchronized: 0.85ì´ˆ
// AtomicInteger: 0.23ì´ˆ (ì•½ 3.7ë°° ë¹ ë¦„)
// ReentrantLock: 0.92ì´ˆ
// ë™ê¸°í™” ì—†ìŒ: 0.05ì´ˆ (ë¶€ì •í™•í•œ ê²°ê³¼)

```

### **ë½ ê²½í•©ê³¼ í™•ì¥ì„±**

```java
public class LockContentionAnalysis {
    private final Object singleLock = new Object();
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    // ì‹¬í•œ ë½ ê²½í•© (ë³‘ëª© í˜„ìƒ)
    public void heavyContention() {
        synchronized (singleLock) {
            // ëª¨ë“  ìŠ¤ë ˆë“œê°€ í•˜ë‚˜ì˜ ë½ì„ ë‘ê³  ê²½ìŸ
            expensiveOperation();
        }
    }

    // ì½ê¸°-ì“°ê¸° ë½ìœ¼ë¡œ ê°œì„ 
    public Object readData() {
        rwLock.readLock().lock();
        try {
            // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ê¸° ê°€ëŠ¥
            return fetchData();
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void writeData(Object data) {
        rwLock.writeLock().lock();
        try {
            // ì“°ê¸°ëŠ” ë°°íƒ€ì  ì‹¤í–‰
            updateData(data);
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    // ë½ ë¶„í• ë¡œ ê²½í•© ê°ì†Œ
    private final Object[] lockArray = new Object[16];
    {
        for (int i = 0; i < lockArray.length; i++) {
            lockArray[i] = new Object();
        }
    }

    public void distributedLocking(int key) {
        int lockIndex = key % lockArray.length;
        synchronized (lockArray[lockIndex]) {
            // í‚¤ì— ë”°ë¼ ë‹¤ë¥¸ ë½ ì‚¬ìš©ìœ¼ë¡œ ê²½í•© ë¶„ì‚°
            processKey(key);
        }
    }
}

```

## ğŸŒ ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œì˜ ë™ê¸°í™”

### **ë¶„ì‚° ë½ (Distributed Lock)**

```java
// Redisë¥¼ ì´ìš©í•œ ë¶„ì‚° ë½
public class RedisDistributedLock {
    private final RedisTemplate<String, String> redisTemplate;
    private final String lockKey;
    private final int expireTime;

    public boolean tryLock(String requestId) {
        String result = redisTemplate.execute(
            (RedisCallback<String>) connection -> {
                Jedis jedis = (Jedis) connection.getNativeConnection();
                return jedis.set(lockKey, requestId, "NX", "PX", expireTime);
            }
        );
        return "OK".equals(result);
    }

    public boolean releaseLock(String requestId) {
        String luaScript =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";

        Long result = redisTemplate.execute(
            (RedisCallback<Long>) connection -> {
                Jedis jedis = (Jedis) connection.getNativeConnection();
                return (Long) jedis.eval(luaScript, 1, lockKey, requestId);
            }
        );
        return result != null && result == 1L;
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
public class DistributedService {
    private final RedisDistributedLock distributedLock;

    public void processGlobalResource() {
        String requestId = UUID.randomUUID().toString();

        if (distributedLock.tryLock(requestId)) {
            try {
                // ì „ì—­ ìì›ì— ëŒ€í•œ ì•ˆì „í•œ ì ‘ê·¼
                updateGlobalCounter();
                generateUniqueId();
            } finally {
                distributedLock.releaseLock(requestId);
            }
        } else {
            // ë½ íšë“ ì‹¤íŒ¨ ì²˜ë¦¬
            handleLockFailure();
        }
    }
}

```

### **ë¶„ì‚° ì‹œìŠ¤í…œì˜ êµì°©ìƒíƒœ**

```
ë¶„ì‚° êµì°©ìƒíƒœ ì‹œë‚˜ë¦¬ì˜¤:

ì„œë²„A: ë°ì´í„°ë² ì´ìŠ¤1 ë½ ë³´ìœ  â†’ ë°ì´í„°ë² ì´ìŠ¤2 ë½ ëŒ€ê¸°
ì„œë²„B: ë°ì´í„°ë² ì´ìŠ¤2 ë½ ë³´ìœ  â†’ ë°ì´í„°ë² ì´ìŠ¤1 ë½ ëŒ€ê¸°

ë„¤íŠ¸ì›Œí¬ ì§€ì—°ìœ¼ë¡œ ì¸í•œ ë³µì¡ì„±:
- ë½ ìƒíƒœ ì •ë³´ ì „íŒŒ ì§€ì—°
- ë„¤íŠ¸ì›Œí¬ ë¶„í• ë¡œ ì¸í•œ ì˜ëª»ëœ íŒë‹¨
- íƒ€ì„ì•„ì›ƒ ì„¤ì •ì˜ ì–´ë ¤ì›€

í•´ê²° ë°©ì•ˆ:
1. ê¸€ë¡œë²Œ ë½ ìˆœì„œ ì •ì˜
2. ë¶„ì‚° êµì°©ìƒíƒœ íƒì§€ ì•Œê³ ë¦¬ì¦˜
3. ìƒ¤ë”©ìœ¼ë¡œ ë½ ì˜ì¡´ì„± ìµœì†Œí™”

```

## ğŸ” ê³ ê¸‰ ë™ê¸°í™” íŒ¨í„´

### **Producer-Consumer íŒ¨í„´**

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class ProducerConsumerExample {
    private final BlockingQueue<Task> taskQueue = new LinkedBlockingQueue<>(100);

    // ìƒì‚°ì: ì‘ì—…ì„ íì— ì¶”ê°€
    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                for (int i = 0; i < 100; i++) {
                    Task task = new Task("Task-" + i);
                    taskQueue.put(task);  // íê°€ ê°€ë“ ì°¨ë©´ ìë™ ëŒ€ê¸°
                    System.out.println("ìƒì‚°: " + task.getName());
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    // ì†Œë¹„ì: ì‘ì—…ì„ íì—ì„œ ê°€ì ¸ì™€ ì²˜ë¦¬
    class Consumer implements Runnable {
        private final String name;

        public Consumer(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            try {
                while (true) {
                    Task task = taskQueue.take();  // íê°€ ë¹„ì–´ìˆìœ¼ë©´ ìë™ ëŒ€ê¸°
                    System.out.println(name + " ì²˜ë¦¬: " + task.getName());
                    Thread.sleep(200);  // ì‘ì—… ì²˜ë¦¬ ì‹œê°„
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    public void startSystem() {
        // 1ê°œ ìƒì‚°ì, 3ê°œ ì†Œë¹„ìë¡œ ì‹œì‘
        new Thread(new Producer()).start();
        new Thread(new Consumer("ì†Œë¹„ì1")).start();
        new Thread(new Consumer("ì†Œë¹„ì2")).start();
        new Thread(new Consumer("ì†Œë¹„ì3")).start();
    }
}

```

### **Reader-Writer íŒ¨í„´**

```java
public class DatabaseCache {
    private final Map<String, Object> cache = new HashMap<>();
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();

    // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ê¸° ê°€ëŠ¥
    public Object read(String key) {
        readLock.lock();
        try {
            System.out.println("ì½ê¸° ìˆ˜í–‰: " + Thread.currentThread().getName());
            Thread.sleep(100);  // ì½ê¸° ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
            return cache.get(key);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        } finally {
            readLock.unlock();
        }
    }

    // ì“°ê¸°ëŠ” ë°°íƒ€ì ìœ¼ë¡œ ì‹¤í–‰
    public void write(String key, Object value) {
        writeLock.lock();
        try {
            System.out.println("ì“°ê¸° ìˆ˜í–‰: " + Thread.currentThread().getName());
            Thread.sleep(200);  // ì“°ê¸° ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
            cache.put(key, value);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            writeLock.unlock();
        }
    }

    public static void main(String[] args) {
        DatabaseCache cache = new DatabaseCache();

        // ì—¬ëŸ¬ ì½ê¸° ìŠ¤ë ˆë“œ (ë™ì‹œ ì‹¤í–‰ ê°€ëŠ¥)
        for (int i = 0; i < 5; i++) {
            new Thread(() -> cache.read("key1"), "Reader-" + i).start();
        }

        // ì“°ê¸° ìŠ¤ë ˆë“œ (ë°°íƒ€ì  ì‹¤í–‰)
        new Thread(() -> cache.write("key1", "new value"), "Writer").start();
    }
}

```

### **Barrier íŒ¨í„´ (ë™ê¸°í™” ì¥ë²½)**

```java
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.BrokenBarrierException;

public class ParallelMatrixMultiplication {
    private final int[][] matrixA;
    private final int[][] matrixB;
    private final int[][] result;
    private final int numThreads;
    private final CyclicBarrier barrier;

    public ParallelMatrixMultiplication(int[][] a, int[][] b, int numThreads) {
        this.matrixA = a;
        this.matrixB = b;
        this.result = new int[a.length][b[0].length];
        this.numThreads = numThreads;

        // ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì™„ë£Œë˜ë©´ ê²°ê³¼ ì¶œë ¥
        this.barrier = new CyclicBarrier(numThreads, () -> {
            System.out.println("ëª¨ë“  ìŠ¤ë ˆë“œ ì‘ì—… ì™„ë£Œ!");
            printMatrix(result);
        });
    }

    class WorkerThread implements Runnable {
        private final int threadId;

        public WorkerThread(int threadId) {
            this.threadId = threadId;
        }

        @Override
        public void run() {
            int rows = matrixA.length;
            int rowsPerThread = rows / numThreads;
            int startRow = threadId * rowsPerThread;
            int endRow = (threadId == numThreads - 1) ? rows : startRow + rowsPerThread;

            // í• ë‹¹ëœ í–‰ ë²”ìœ„ì—ì„œ í–‰ë ¬ ê³±ì…ˆ ìˆ˜í–‰
            for (int i = startRow; i < endRow; i++) {
                for (int j = 0; j < matrixB[0].length; j++) {
                    for (int k = 0; k < matrixB.length; k++) {
                        result[i][j] += matrixA[i][k] * matrixB[k][j];
                    }
                }
            }

            System.out.println("ìŠ¤ë ˆë“œ " + threadId + " ì‘ì—… ì™„ë£Œ");

            try {
                barrier.await();  // ë‹¤ë¥¸ ìŠ¤ë ˆë“œë“¤ ëŒ€ê¸°
            } catch (InterruptedException | BrokenBarrierException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    public void multiply() {
        for (int i = 0; i < numThreads; i++) {
            new Thread(new WorkerThread(i)).start();
        }
    }
}

```

## ğŸ“Š ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ê³¼ ë””ë²„ê¹…

### **êµì°©ìƒíƒœ íƒì§€ ë„êµ¬**

```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.lang.management.ThreadInfo;

public class DeadlockDetector {
    private final ThreadMXBean threadBean;

    public DeadlockDetector() {
        this.threadBean = ManagementFactory.getThreadMXBean();
    }

    public void detectDeadlock() {
        long[] deadlockedThreadIds = threadBean.findDeadlockedThreads();

        if (deadlockedThreadIds != null) {
            System.out.println("êµì°©ìƒíƒœ ê°ì§€ë¨!");
            ThreadInfo[] threadInfos = threadBean.getThreadInfo(deadlockedThreadIds);

            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("ìŠ¤ë ˆë“œ: " + threadInfo.getThreadName());
                System.out.println("ìƒíƒœ: " + threadInfo.getThreadState());
                System.out.println("ë½ ì´ë¦„: " + threadInfo.getLockName());
                System.out.println("ë½ ì†Œìœ ì: " + threadInfo.getLockOwnerName());
                System.out.println("ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:");

                for (StackTraceElement element : threadInfo.getStackTrace()) {
                    System.out.println("  " + element);
                }
                System.out.println();
            }
        } else {
            System.out.println("êµì°©ìƒíƒœ ì—†ìŒ");
        }
    }

    // ì£¼ê¸°ì ìœ¼ë¡œ êµì°©ìƒíƒœ ëª¨ë‹ˆí„°ë§
    public void startMonitoring() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(this::detectDeadlock, 0, 5, TimeUnit.SECONDS);
    }
}

```

### **ë™ê¸°í™” ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§**

```java
public class SynchronizationProfiler {
    private static final AtomicLong lockWaitTime = new AtomicLong(0);
    private static final AtomicLong lockHoldTime = new AtomicLong(0);
    private static final AtomicInteger lockContention = new AtomicInteger(0);

    public static class ProfiledLock {
        private final ReentrantLock lock = new ReentrantLock();

        public void lock() {
            long startWait = System.nanoTime();

            if (!lock.tryLock()) {
                lockContention.incrementAndGet();
                lock.lock();
            }

            long waitTime = System.nanoTime() - startWait;
            lockWaitTime.addAndGet(waitTime);
        }

        public void unlock() {
            lock.unlock();
        }
    }

    public static void printStatistics() {
        System.out.println("ë™ê¸°í™” ì„±ëŠ¥ í†µê³„:");
        System.out.printf("ì´ ëŒ€ê¸° ì‹œê°„: %.2f ms\n", lockWaitTime.get() / 1e6);
        System.out.printf("ë½ ê²½í•© íšŸìˆ˜: %d\n", lockContention.get());
        System.out.printf("í‰ê·  ëŒ€ê¸° ì‹œê°„: %.2f Î¼s\n",
            lockWaitTime.get() / (double)lockContention.get() / 1000);
    }
}

```

## ğŸ¯ ì‹¤ë¬´ ê°€ì´ë“œë¼ì¸

### **ë™ê¸°í™” ì „ëµ ì„ íƒ ê°€ì´ë“œ**

```java
// 1. ê°„ë‹¨í•œ ì¹´ìš´í„°: AtomicInteger ì‚¬ìš©
private final AtomicInteger counter = new AtomicInteger(0);
public void increment() { counter.incrementAndGet(); }

// 2. ë³µì¡í•œ ìƒíƒœ ë³€ê²½: synchronized ì‚¬ìš©
private final Map<String, User> userMap = new HashMap<>();
public synchronized void updateUser(String id, User user) {
    userMap.put(id, user);
    notifyObservers(user);
}

// 3. ì½ê¸° ë¹ˆë„ê°€ ë†’ì€ ê²½ìš°: ReadWriteLock ì‚¬ìš©
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
public User getUser(String id) {
    rwLock.readLock().lock();
    try { return userMap.get(id); }
    finally { rwLock.readLock().unlock(); }
}

// 4. ê³ ì„±ëŠ¥ì´ í•„ìš”í•œ ê²½ìš°: lock-free ìë£Œêµ¬ì¡°
private final ConcurrentHashMap<String, User> concurrentMap =
    new ConcurrentHashMap<>();
public void updateUser(String id, User user) {
    concurrentMap.put(id, user);  // ë‚´ë¶€ì ìœ¼ë¡œ ìµœì í™”ëœ ë™ê¸°í™”
}

// 5. ë³µì¡í•œ ì¡°ê±´ ëŒ€ê¸°: Condition ì‚¬ìš©
private final Lock lock = new ReentrantLock();
private final Condition notEmpty = lock.newCondition();
private boolean dataReady = false;

public void waitForData() throws InterruptedException {
    lock.lock();
    try {
        while (!dataReady) {
            notEmpty.await();
        }
        processData();
    } finally {
        lock.unlock();
    }
}

```

### **êµì°©ìƒíƒœ ë°©ì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸**

```
âœ… ë½ ìˆœì„œ ì¼ê´€ì„±
   - ëª¨ë“  ì½”ë“œì—ì„œ ë™ì¼í•œ ìˆœì„œë¡œ ë½ íšë“
   - ìì› ID ê¸°ë°˜ ì •ë ¬ ë“± ëª…í™•í•œ ê·œì¹™ ì ìš©

âœ… íƒ€ì„ì•„ì›ƒ ì„¤ì •
   - tryLock(timeout) ì‚¬ìš©ìœ¼ë¡œ ë¬´í•œ ëŒ€ê¸° ë°©ì§€
   - ì ì ˆí•œ íƒ€ì„ì•„ì›ƒ ê°’ ì„¤ì • (ë³´í†µ 1-10ì´ˆ)

âœ… ì¤‘ì²© ë½ ìµœì†Œí™”
   - ê°€ëŠ¥í•œ í•œ ë‹¨ì¼ ë½ ì‚¬ìš©
   - ë½ ë²”ìœ„ë¥¼ ìµœì†Œí•œìœ¼ë¡œ ì œí•œ

âœ… ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…
   - ë½ ëŒ€ê¸° ì‹œê°„ ì¸¡ì •
   - êµì°©ìƒíƒœ ìë™ íƒì§€ ì‹œìŠ¤í…œ êµ¬ì¶•

âœ… ì½”ë“œ ë¦¬ë·°
   - ë™ê¸°í™” ì½”ë“œëŠ” ë°˜ë“œì‹œ ë™ë£Œ ê²€í† 
   - ì ì¬ì  ê²½ìŸ ìƒíƒœ ë¶„ì„

```

## ğŸ”š í•µì‹¬ ìš”ì•½

### **ì›ìì„± (Atomicity)**

1. **ì •ì˜**: ì—°ì‚°ì´ ì™„ì „íˆ ì„±ê³µí•˜ê±°ë‚˜ ì™„ì „íˆ ì‹¤íŒ¨í•˜ëŠ” ì„±ì§ˆ
2. **êµ¬í˜„**: íŠ¸ëœì­ì…˜, AtomicInteger, CAS ì—°ì‚°
3. **ì¤‘ìš”ì„±**: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥, ì¼ê´€ëœ ìƒíƒœ ìœ ì§€
4. **ì ìš© ë¶„ì•¼**: ê¸ˆìœµ ì‹œìŠ¤í…œ, ë°ì´í„°ë² ì´ìŠ¤, ê²Œì„ ì•„ì´í…œ ê±°ë˜

### **ë™ê¸°í™” (Synchronization)**

1. **ëª©ì **: ê³µìœ  ìì›ì— ëŒ€í•œ ì•ˆì „í•œ ë™ì‹œ ì ‘ê·¼
2. **í•„ìš” ì¡°ê±´**: ì—¬ëŸ¬ ìŠ¤ë ˆë“œ/í”„ë¡œì„¸ìŠ¤ê°€ ê°™ì€ ìì› ìˆ˜ì •
3. **êµ¬í˜„ ë°©ë²•**: synchronized, Lock, Semaphore, Atomic í´ë˜ìŠ¤
4. **ì„±ëŠ¥ ê³ ë ¤**: ë½ ê²½í•© ìµœì†Œí™”, ì ì ˆí•œ ë™ê¸°í™” ìˆ˜ì¤€ ì„ íƒ

### **êµì°©ìƒíƒœ (Deadlock)**

1. **ë°œìƒ ì¡°ê±´**: ìƒí˜¸ë°°ì œ + ì ìœ ëŒ€ê¸° + ë¹„ì„ ì  + ìˆœí™˜ëŒ€ê¸°
2. **í•´ê²° ì „ëµ**: ì˜ˆë°©, íšŒí”¼, íƒì§€ ë° íšŒë³µ, ë¬´ì‹œ
3. **ì‹¤ë¬´ ì ‘ê·¼**: ë½ ìˆœì„œ í†µì¼, íƒ€ì„ì•„ì›ƒ ì„¤ì •, ëª¨ë‹ˆí„°ë§
4. **í˜„ëŒ€ì  í•´ë²•**: lock-free ì•Œê³ ë¦¬ì¦˜, ì•¡í„° ëª¨ë¸, CSP