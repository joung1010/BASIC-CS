## 동시성과 병렬성

# 동시성과 병렬성: 컴퓨터 시스템의 멀티태스킹

## 🔄 기본 개념 정의

### **동시성 (Concurrency)**

**여러 가지 서로 다른 일이 동시에 진행되는 것처럼 보이는 상황**

### **병렬성 (Parallelism)**

**같은 종류의 일을 여러 주체가 실제로 동시에 처리하는 것**

**핵심 차이점:**

`동시성 (Concurrency):
- 서로 다른 작업들
- 시간 분할로 번갈아 실행
- 단일 CPU로도 가능
- 예: 음악 재생 + 웹 브라우징 + 파일 다운로드

병렬성 (Parallelism):
- 같은 작업의 분할
- 실제로 동시 실행
- 여러 CPU/코어 필요
- 예: 대용량 데이터 정렬을 4개 코어가 분담`

## 🎵 동시성 (Concurrency) 상세 분석

### **동시성의 작동 원리**

**동시성은 실제로는 "매우 빠른 순차 실행"입니다.**

`시간 분할 실행 (Time Slicing):

시간축: 0ms   5ms   10ms  15ms  20ms  25ms
│     │     │     │     │     │
작업A: ███   ─     ███   ─     ███   ─     (유튜브 재생)
작업B: ─     ███   ─     ███   ─     ███   (파일 다운로드)

실제: 순차적으로 번갈아 실행
사용자 관점: 동시에 실행되는 것처럼 보임`

### **운영체제의 스케줄링**

**운영체제가 CPU 시간을 나누어 배분하는 방식:**

`프로세스 스케줄링 과정:

1단계: 프로세스 목록 확인
- Chrome.exe (우선순위: 높음)
- Download.exe (우선순위: 보통)
- MusicPlayer.exe (우선순위: 보통)

2단계: 시간 할당 (라운드 로빈 방식)
각 프로세스에 10ms씩 CPU 시간 할당

3단계: 컨텍스트 스위칭
CPU 레지스터 상태 저장 → 다음 프로세스 로드

4단계: 반복 실행
모든 프로세스가 공평하게 CPU 시간 확보`

**컨텍스트 스위칭 상세 과정:**

`Chrome 실행 중 → Download로 전환:

1. Chrome 상태 저장:
    - RAX = 0x12345678
    - RBX = 0x87654321
    - RIP = 0x00401234 (다음 실행 주소)
    - 스택 포인터, 플래그 등

2. Download 상태 복원:
    - 이전에 저장된 레지스터 값들 로드
    - 메모리 페이지 테이블 전환
    - 캐시 플러시 (필요시)

3. Download 실행 재개:
    - 중단되었던 지점부터 계속 실행

오버헤드: 컨텍스트 스위칭 자체에 소요되는 시간`

### **동시성의 실제 예시들**

**1. 웹 브라우저에서 유튜브 시청 + 파일 다운로드**

`Chrome 프로세스 내부:

UI 스레드:
- 사용자 클릭 처리
- 화면 렌더링 업데이트
- 스크롤, 버튼 반응

Video 스레드:
- 비디오 디코딩
- 오디오 디코딩
- 화면 출력 동기화

Network 스레드:
- 비디오 스트림 다운로드
- 별도 파일 다운로드
- HTTP 요청 처리

각 스레드가 번갈아 실행되어 동시성 구현`

**2. 운영체제 수준의 동시성**

`Windows 시스템에서 동시 실행:

백그라운드 서비스:
- Windows Update (자동 업데이트)
- Antivirus Scanner (실시간 검사)
- Indexing Service (파일 인덱싱)

사용자 프로그램:
- 게임 실행
- 음악 재생
- 채팅 프로그램

시스템 프로세스:
- Explorer.exe (바탕화면, 파일 탐색기)
- svchost.exe (시스템 서비스들)
- winlogon.exe (로그인 관리)

총 100개 이상의 프로세스가 동시성으로 실행`

### **동시성 구현 기술**

**1. 멀티스레딩 (Multi-threading)**

`스레드 vs 프로세스:

프로세스:
- 독립적인 메모리 공간
- 생성/전환 비용 높음
- 안정성 높음 (한 프로세스 오류가 다른 프로세스에 영향 없음)

스레드:
- 메모리 공간 공유
- 생성/전환 비용 낮음
- 빠른 데이터 교환 가능
- 동기화 문제 발생 가능

Java 멀티스레딩 예시:
class DownloadThread extends Thread {
public void run() {
// 파일 다운로드 로직
while(downloading) {
downloadChunk();
Thread.sleep(10); // 다른 스레드에게 CPU 양보
}
}
}

class UIThread extends Thread {
public void run() {
// UI 업데이트 로직
while(running) {
updateProgress();
repaintScreen();
Thread.sleep(16); // 60 FPS를 위한 16ms 간격
}
}
}`

**2. 비동기 프로그래밍 (Asynchronous Programming)**

`동기 방식 (문제점):
파일 다운로드 시작 → 완료까지 대기 → UI 응답 불가

비동기 방식 (해결책):
파일 다운로드 시작 → 즉시 다음 코드 실행 → UI 계속 반응

JavaScript 비동기 예시:
// 동기 방식 (블로킹)
const data = downloadFile("large-file.zip"); // 10초 대기
updateUI(); // 10초 후에야 실행

// 비동기 방식 (논블로킹)
downloadFile("large-file.zip")
.then(data => processFile(data))
.catch(error => handleError(error));
updateUI(); // 즉시 실행`

## ⚡ 병렬성 (Parallelism) 상세 분석

### **병렬성의 작동 원리**

**실제로 여러 처리 장치가 동시에 같은 작업을 수행합니다.**

`병렬 처리 예시 - 1000만 개 숫자 정렬:

단일 코어 (순차 처리):
CPU1: [1~1000만] 정렬 → 10초 소요

4코어 병렬 처리:
CPU1: [1~250만] 정렬    ┐
CPU2: [250만~500만] 정렬 ├─ 동시 실행 → 2.5초 소요
CPU3: [500만~750만] 정렬 ┤
CPU4: [750만~1000만] 정렬┘
합병: 4개 결과 합치기 → 0.5초 소요

총 시간: 3초 (약 3.3배 향상)`

### **병렬성의 하드웨어 기반**

**1. 멀티코어 CPU**

`Intel Core i7-12700K 구조:

Performance Cores (P-Core): 8개
- 고성능 작업용
- 하이퍼스레딩 지원 (16 스레드)
- 복잡한 연산 처리

Efficiency Cores (E-Core): 4개
- 전력 효율적 작업용
- 백그라운드 작업 처리

총 처리 능력: 20개 스레드 동시 실행`

**2. GPU 병렬 처리**

`NVIDIA RTX 4080 구조:

CUDA 코어: 9728개
각 코어가 동시에 연산 수행

이미지 처리 예시:
4K 이미지 (3840×2160 = 830만 픽셀)
각 픽셀을 개별 코어가 동시 처리
→ 매우 빠른 이미지/비디오 처리

CPU vs GPU:
CPU: 8~16개 코어, 복잡한 연산
GPU: 수천 개 코어, 단순 반복 연산`

### **병렬성 구현 방법들**

**1. 데이터 병렬성 (Data Parallelism)**

`같은 연산을 다른 데이터에 적용:

예시: 100만 개 이미지에 필터 적용

분할:
코어1: 이미지 1~25만개 필터 적용
코어2: 이미지 25~50만개 필터 적용
코어3: 이미지 50~75만개 필터 적용
코어4: 이미지 75~100만개 필터 적용

Java 병렬 스트림 예시:
List<Image> images = loadImages();
images.parallelStream()
.map(img -> applyFilter(img))
.collect(Collectors.toList());
// 자동으로 사용 가능한 코어 수만큼 병렬 처리`

**2. 작업 병렬성 (Task Parallelism)**

`서로 다른 작업을 다른 코어에서 실행:

웹 서버 예시:
코어1: 사용자 A의 요청 처리
코어2: 사용자 B의 요청 처리
코어3: 데이터베이스 백업
코어4: 로그 파일 정리

각각 다른 종류의 작업이지만 동시 실행`

**3. 파이프라인 병렬성 (Pipeline Parallelism)**

`작업을 단계별로 나누어 각 단계를 병렬 처리:

동영상 인코딩 파이프라인:
단계1 (코어1): 원본 영상 읽기
단계2 (코어2): 프레임 디코딩
단계3 (코어3): 필터/효과 적용
단계4 (코어4): 새로운 형식으로 인코딩

시간: 0ms  100ms 200ms 300ms 400ms
코어1: [R1]  [R2]  [R3]  [R4]  [R5]
코어2:  ─   [D1]  [D2]  [D3]  [D4]
코어3:  ─    ─   [F1]  [F2]  [F3]
코어4:  ─    ─    ─   [E1]  [E2]

각 코어가 다른 프레임을 동시에 처리`

## 🎭 실제 사례 분석

### **동시성 사례: 게임 + 스트리밍**

`게임 스트리머의 컴퓨터에서 일어나는 일:

게임 프로세스:
- 게임 로직 계산
- 그래픽 렌더링
- 사운드 처리
- 네트워크 통신

스트리밍 프로그램 (OBS):
- 화면 캡처
- 비디오 인코딩
- 오디오 믹싱
- 스트리밍 서버 전송

채팅 프로그램:
- 메시지 수신/발신
- 알림 처리

운영체제가 이 모든 프로세스에 CPU 시간 할당
사용자는 모든 것이 동시에 실행되는 것으로 인식`

### **병렬성 사례: 대용량 데이터 처리**

`Netflix의 추천 시스템:

문제: 1억 명 사용자 × 1만 개 영화 = 1조 개 조합 분석

병렬 처리 방식:
1. 데이터 분할: 사용자를 1000개 그룹으로 분할
2. 분산 처리: 1000개 서버가 각각 10만 명씩 담당
3. 알고리즘 병렬화: 각 서버에서 다시 CPU 코어별로 분할
4. 결과 취합: 모든 계산 결과를 하나로 합침

처리 시간:
순차 처리: 100시간
병렬 처리: 6분 (1000배 향상)`

## 🔧 동시성과 병렬성의 문제점과 해결책

### **동시성의 문제점**

**1. 경쟁 상태 (Race Condition)**

`문제 상황:
두 스레드가 같은 변수에 동시 접근

int balance = 1000;

스레드A (출금):           스레드B (입금):
1. temp = balance (1000)  1. temp = balance (1000)
2. temp = temp - 500      2. temp = temp + 200
3. balance = temp (500)   3. balance = temp (1200)

결과: 최종 balance = 1200 (잘못된 결과)
정답: 1000 - 500 + 200 = 700이어야 함

해결책: 동기화 (Synchronization)
synchronized (lockObject) {
balance = balance - amount;
}`

**2. 교착상태 (Deadlock)**

`문제 상황:
두 스레드가 서로 다른 자원을 점유하고 상대방 자원을 기다림

스레드A: 자원1 점유 → 자원2 대기
스레드B: 자원2 점유 → 자원1 대기
→ 서로 무한 대기

해결책:
1. 자원 순서 정하기 (항상 자원1 → 자원2 순으로 요청)
2. 타임아웃 설정 (일정 시간 후 포기)
3. 데드락 감지 및 회복 알고리즘`

### **병렬성의 문제점**

**1. 오버헤드**

`병렬 처리의 추가 비용:

작업 분할 시간: 데이터를 여러 부분으로 나누는 시간
통신 비용: 프로세서 간 데이터 교환 시간
동기화 비용: 작업 완료 대기 및 조율 시간
결과 합병 시간: 개별 결과를 합치는 시간

Amdahl의 법칙:
전체 성능 향상 = 1 / (순차부분 + 병렬부분/프로세서수)

예시: 90% 병렬화 가능한 작업
4코어 사용 시 최대 성능 향상: 1/(0.1 + 0.9/4) = 3.08배`

**2. 로드 밸런싱**

`문제: 작업량이 고르지 않을 때

불균등 분할:
코어1: 1초 소요 작업
코어2: 5초 소요 작업  ← 병목
코어3: 1초 소요 작업
코어4: 1초 소요 작업

전체 시간: 5초 (코어2에 의해 제한됨)

해결책:
1. 동적 로드 밸런싱: 작업 완료한 코어에 새 작업 할당
2. Work Stealing: 일 끝난 코어가 다른 코어의 작업 가져옴
3. 작업 세분화: 큰 작업을 더 작은 단위로 분할`

## 🚀 최신 기술 동향

### **비동기 프로그래밍의 발전**

`기존 방식 → 최신 방식:

콜백 지옥:
getData(function(a) {
getMoreData(a, function(b) {
getEvenMoreData(b, function(c) {
// 중첩이 깊어짐
});
});
});

Promise 체이닝:
getData()
.then(a => getMoreData(a))
.then(b => getEvenMoreData(b))
.then(c => processData(c));

async/await (최신):
async function processAllData() {
const a = await getData();
const b = await getMoreData(a);
const c = await getEvenMoreData(b);
return processData(c);
}`

### **분산 병렬 처리**

`클라우드 기반 병렬 처리:

Apache Spark:
- 여러 서버에 작업 분산
- 메모리 기반 처리로 속도 향상
- 자동 장애 복구

예시: 100TB 데이터 분석
단일 서버: 100일
100대 서버 클러스터: 1일

Kubernetes + 마이크로서비스:
- 서비스별로 독립적 확장
- 자동 로드 밸런싱
- 장애 시 자동 복구`

## 📊 성능 측정과 최적화

### **성능 지표**

`동시성 측정:
- 처리량 (Throughput): 단위 시간당 처리된 작업 수
- 응답 시간 (Response Time): 요청부터 완료까지 시간
- 자원 사용률: CPU, 메모리 사용률

병렬성 측정:
- 가속비 (Speedup): 순차 처리 대비 성능 향상
- 효율성 (Efficiency): 가속비 / 프로세서 수
- 확장성 (Scalability): 프로세서 증가에 따른 성능 변화

실제 측정 예시:
순차 처리: 100초
2코어 병렬: 55초 → 가속비: 1.82, 효율성: 91%
4코어 병렬: 30초 → 가속비: 3.33, 효율성: 83%
8코어 병렬: 20초 → 가속비: 5.00, 효율성: 62%`

### **최적화 전략**

`동시성 최적화:
1. 적절한 스레드 수 설정
    - CPU 집약적: 코어 수 + 1
    - I/O 집약적: 코어 수 × 2~4

2. 논블로킹 I/O 사용
    - 파일/네트워크 작업 시 CPU 양보

3. 스레드 풀 사용
    - 스레드 생성/소멸 비용 절약

병렬성 최적화:
1. 캐시 친화적 데이터 접근
    - 메모리 지역성 고려한 분할

2. NUMA 고려 설계
    - 프로세서와 가까운 메모리 사용

3. 벡터화 활용
    - SIMD 명령어로 여러 데이터 동시 처리`

## 🎯 핵심 요약

### **동시성 (Concurrency)**

1. **정의**: 여러 다른 작업이 번갈아 실행되어 동시에 진행되는 것처럼 보이는 것
2. **구현**: 운영체제의 시간 분할, 멀티스레딩, 비동기 프로그래밍
3. **장점**: 사용자 경험 향상, 자원 효율적 사용
4. **단점**: 경쟁 상태, 교착상태 등 동기화 문제

### **병렬성 (Parallelism)**

1. **정의**: 같은 작업을 여러 처리 장치가 실제로 동시에 수행하는 것
2. **구현**: 멀티코어 CPU, GPU, 분산 시스템
3. **장점**: 처리 속도 대폭 향상, 대용량 데이터 처리 가능
4. **단점**: 오버헤드, 로드 밸런싱, 복잡한 설계

### **선택 기준**

- **동시성**: 서로 다른 종류의 작업들을 효율적으로 처리
- **병렬성**: 같은 종류의 대량 작업을 빠르게 처리