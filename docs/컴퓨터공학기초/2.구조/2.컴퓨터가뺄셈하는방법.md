# 컴퓨터가 뺄셈 하는 방법

## 🔢 10진수 보수의 기본 개념

**6에 4를 더하면 10이다. 즉, 4는 6에 대한 10의 보수이다. → 6에서 얼마를 더해야 10이 되는지를 말한다.**

**10의 보수 원리 상세:**

```

10의 보수 정의:
어떤 수 A의 10의 보수 = 10 - A

예시들:
6의 10의 보수 = 10 - 6 = 4
3의 10의 보수 = 10 - 3 = 7
8의 10의 보수 = 10 - 8 = 2
0의 10의 보수 = 10 - 0 = 10 (특수 경우)

확인:
6 + 4 = 10 ✓
3 + 7 = 10 ✓
8 + 2 = 10 ✓

```

**왜 보수를 사용하는가?**

```

뺄셈의 어려움:
- 빌려오기(borrow) 연산 복잡
- 하드웨어 구현 시 추가 회로 필요
- 덧셈보다 느림

보수의 장점:
- 뺄셈을 덧셈으로 변환
- 기존 덧셈 회로 재사용
- 하드웨어 단순화
- 빠른 연산 속도

```

## ➕ 10진수 보수 뺄셈 실습

**13-6은 7이다**

**13에 6에 대한 10의 보수 4를 더하고 10자리에서 1을 빼도 역시 7이다.**

```bash

bash
일반적인 뺄셈:
  13
-  6
----
   7

보수를 이용한 뺄셈:
  13
+ 04  (6의 10의 보수)
----
  17
- 10  (자리 올림 제거)
----
   7  (같은 결과!)

```

**보수 뺄셈의 수학적 원리:**

```

A - B = A + (10-B) - 10

13 - 6 = 13 + (10-6) - 10
       = 13 + 4 - 10
       = 17 - 10
       = 7

자리 올림 발생 시: 그 자리 올림을 제거하면 정답
자리 올림 없을 시: 결과가 음수 (별도 처리 필요)

```

**다양한 예시:**

```

예시 1: 25 - 18
18의 10의 보수 = 10 - 18 = -8 (자리수가 모자람)
→ 100의 보수 사용: 100 - 18 = 82
  25 + 82 = 107 → 100을 빼면 7 ✓

예시 2: 8 - 15 (음수 결과)
15의 10의 보수 = 85 (100-15)
  8 + 85 = 93 (자리 올림 없음)
→ 결과가 음수임을 의미
실제 값: -(100-93) = -7 ✓

```

**보수에 대한 더하기가 곧 뺄셈이다. 이러한 방식으로 뺄셈을 처리하게 된다면 덧셈만으로도 뺄셈을 구현할 수 있다.**

**이 덧셈을 이용할 수 있다는 말은 전가산기를 이용해서 뺄셈을 처리할 수 있다.**

## 💻 2진수의 보수 시스템

**2진수의 뺄셈**

**2진수에서 0은 1로, 1은 0으로 뒤집으면 1의 보수가 된다.(Not 연산)**

**1의 보수와 2의 보수:**

```

원본 수: 0110₂ (6₁₀)

1의 보수 (비트 반전):
0110 → 1001
0→1, 1→0으로 모든 비트 반전

2의 보수 (1의 보수 + 1):
1001 + 0001 = 1010

검증:
0110 + 1010 = 10000₂
자리 올림 제거하면 0000₂ ✓

```

**1의 보수에 1을 더하면 2의 보수이다.**

**2의 보수가 필요한 이유:**

```

1의 보수의 문제점:
6 + (-6의 1의 보수) = 0110 + 1001 = 1111
결과가 0이 아님! (1111은 -0을 의미)

2의 보수로 해결:
6 + (-6의 2의 보수) = 0110 + 1010 = 10000
자리 올림 제거하면 0000 = 0 ✓

2의 보수 장점:
- 유일한 0 표현
- 자동 자리 올림 처리
- 대칭적 수 체계

```

## 🔢 실제 2진수 뺄셈 구현

**어떤 숫자에 2의 보수를 더하면 자동으로 2진수 뺄셈이 된다. 단, 자리올림은 버린다.**

```bash

bash
13₁₀ = 1101₂
6₁₀  = 0110₂

```

**단계별 계산 과정:**

### **1단계: 6의 1의 보수 구하기**

```

원본:     0110
1의 보수:  1001

비트별 반전:
0 → 1
1 → 0
1 → 0
0 → 1

```

**`0110`에 대한 1의 보수는 `1001`이다. 여기다 1을 더하면 2의 보수가 된다.**

### **2단계: 2의 보수 계산**

```bash

bash
  1001  (6의 1의 보수)
+ 0001  (1 더하기)
------
  1010  (6의 2의 보수)

```

**비트별 덧셈 과정:**

```

위치 0: 1 + 1 = 0, Carry = 1
위치 1: 0 + 0 + Carry(1) = 1, Carry = 0
위치 2: 0 + 0 + Carry(0) = 0, Carry = 0
위치 3: 1 + 0 + Carry(0) = 1, Carry = 0

결과: 1010₂

```

### **3단계: 최종 뺄셈 (13 - 6)**

```bash

bash
  1101  (13)
+ 1010  (6의 2의 보수)
------
 10111  (자리 올림 발생)

```

**10111에서 앞에 1은 4비트 범위를 벗어났기 때문에 버린다.→0111 → 7**

**상세한 덧셈 과정:**

```

  1101
+ 1010
------
위치 0: 1 + 0 = 1
위치 1: 0 + 1 = 1
위치 2: 1 + 0 = 1
위치 3: 1 + 1 = 0, Carry = 1
자리 올림: Carry = 1 (4비트 초과, 버림)

최종 결과: 0111₂ = 7₁₀ ✓

```

## ⚙️ 하드웨어 구현: ALU에서의 뺄셈

**실제 CPU ALU 구조:**

```

        A₃ A₂ A₁ A₀     (피감수)
         │  │  │  │
        ┌▼──▼──▼──▼┐
        │   NOT    │    (1의 보수)
        │  GATES   │
        └┬──┬──┬──┬┘
         │  │  │  │
        ┌▼──▼──▼──▼┐
        │  4-BIT   │    (2의 보수 = +1)
        │  ADDER   │◄── Cin = 1
        └┬──┬──┬──┬┘
         │  │  │  │
        B₃ B₂ B₁ B₀     (감수)

ADD/SUB 제어 신호:
- ADD: B를 그대로 전달, Cin = 0
- SUB: B를 NOT으로 반전, Cin = 1

```

**제어 회로:**

```

SUB 신호가 1일 때:
1. B 입력을 모든 XOR 게이트로 반전
2. Carry-In을 1로 설정 (2의 보수 완성)
3. 결과의 최상위 Carry 무시

ADD 신호가 1일 때:
1. B 입력을 그대로 통과
2. Carry-In을 0으로 설정
3. 일반적인 덧셈 수행

```

## ✖️ 곱셈과 나눗셈 구현

**이제 곱셈과 나눗셈이 남았다.**

**사실 곱셈은 특정 값을 몇 번 덧셈하는지, 나눗셈은 여러 번 빼면 된다.**

### **곱셈 = 반복 덧셈**

```

5 × 3 = 5 + 5 + 5 = 15

2진수 예시: 6 × 4
6 × 4 = 6 + 6 + 6 + 6

110₂ (6)를 4번 더하기:
  110
+ 110
-----
 1100  (12)
+ 110
-----
10010  (18)
+ 110
-----
11000₂ (24) ✓

```

**효율적인 곱셈: 시프트 연산 활용**

```

6 × 4 = 6 × (2²) = 6 << 2

110₂ << 2 = 11000₂
(왼쪽으로 2비트 시프트 = 4배)

일반적인 곱셈 알고리즘:
13 × 11 = 13 × (8+2+1)
        = 13×8 + 13×2 + 13×1
        = (13<<3) + (13<<1) + 13

```

### **나눗셈 = 반복 뺄셈**

```

15 ÷ 3 = ?

15에서 3을 몇 번 뺄 수 있나?
15 - 3 = 12  (1번)
12 - 3 = 9   (2번)
9 - 3 = 6    (3번)
6 - 3 = 3    (4번)
3 - 3 = 0    (5번)

답: 5번 = 몫 5

```

**효율적인 나눗셈: 시프트 연산 활용**

```

24 ÷ 4 = 24 ÷ (2²) = 24 >> 2

11000₂ >> 2 = 110₂ = 6 ✓

일반 나눗셈 (긴 나눗셈 알고리즘):
컴퓨터도 사람과 비슷한 방식으로 처리
- 시행착오로 몫의 각 자리 결정
- 뺄셈과 시프트 연산 조합

```

**즉 컴퓨터는 4칙연산 모두를 덧셈으로 처리할 수 있다.(정수)**

**4칙연산의 덧셈 기반 구현:**

```

덧셈: 전가산기로 직접 구현
뺄셈: 2의 보수 + 덧셈
곱셈: 반복 덧셈 또는 시프트+덧셈
나눗셈: 반복 뺄셈 또는 시프트+뺄셈

→ 모든 연산이 결국 전가산기의 조합!

```

## 🌊 실수(부동소수점) 처리

**실수에 대한 간단한 설명:**

### **고정소수점 vs 부동소수점**

```

고정소수점 (Fixed Point):
- 소수점 위치가 고정
- 예: 16.16 형식 (16비트 정수 + 16비트 소수)
- 123.456을 123456으로 저장하고 소수점 위치 기억

부동소수점 (Floating Point):
- 소수점 위치가 변동
- 과학적 표기법과 유사
- IEEE 754 표준 사용

```

### **IEEE 754 부동소수점 구조**

```

32비트 단정밀도:
[Sign|Exponent|Mantissa]
[ 1  |   8    |   23   ]

예시: 12.75₁₀ = 1100.11₂ = 1.10011 × 2³

Sign: 0 (양수)
Exponent: 3 + 127 = 130 = 10000010₂
Mantissa: 10011000000000000000000₂

실제 저장: 01000001010011000000000000000000₂

```

### **부동소수점 연산의 복잡성**

```

부동소수점 덧셈 과정:
1. 지수 정렬 (작은 수의 지수를 큰 수에 맞춤)
2. 가수부 덧셈 (일반적인 정수 덧셈)
3. 정규화 (결과를 1.xxx 형태로 조정)
4. 반올림 처리

예시: 1.25 + 0.375
1.25  = 1.01₂ × 2⁰
0.375 = 1.10₂ × 2⁻¹

지수 정렬: 0.375 = 0.11₂ × 2⁰
덧셈: 1.01₂ + 0.11₂ = 1.625₁₀

```

### **실수 연산의 하드웨어**

```

FPU (Floating Point Unit):
- CPU 내 별도 연산 장치
- 복잡한 정규화 회로
- 반올림 처리 회로
- 예외 상황 처리 (오버플로우, 언더플로우)

현대 CPU:
- SIMD 명령어 (SSE, AVX)
- 벡터 연산 지원
- GPU와 연동한 병렬 처리

```

## 🎯 핵심 요약

1. **보수 원리**: 뺄셈을 덧셈으로 변환하여 하드웨어 단순화
2. **2의 보수**: 1의 보수 + 1, 2진수 뺄셈의 표준 방법
3. **곱셈**: 반복 덧셈 또는 시프트+덧셈으로 구현
4. **나눗셈**: 반복 뺄셈 또는 시프트+뺄셈으로 구현
5. **통합성**: 모든 정수 연산이 전가산기 기반으로 통일
6. **실수**: 부동소수점으로 과학적 표기법을 하드웨어로 구현