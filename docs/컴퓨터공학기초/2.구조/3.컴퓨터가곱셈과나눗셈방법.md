# 컴퓨터가 곱셈과 나눗셈 하는 방법

## ✖️ 곱셈하는 방법 (Shift 왼쪽으로 밀어)

**4비트로 5를 표현하면 `0101`이다.**

**이진수 5의 구조 분석:**

```

5₁₀ = 0101₂

비트별 분해:
0101₂ = 0×2³ + 1×2² + 0×2¹ + 1×2⁰
      = 0×8 + 1×4 + 0×2 + 1×1
      = 0 + 4 + 0 + 1 = 5₁₀

```

**4비트 0101을 왼쪽으로 `한칸씩 밀면(Shift)` `1010`이다 이때 맨 오른쪽에 `0이 채워진다(Padding)`**

```bash

bash
원본:   0101  (5)
시프트: 01010 → 자리 올림은 버린다. 자리를 넘어간 overflow된 값은 버린다.
결과:   1010  → 마지막은 Padding

```

**시프트 연산의 상세 과정:**

```

왼쪽 시프트 (Left Shift) 과정:

단계 1: 모든 비트를 왼쪽으로 1칸 이동
0101 → 1010 (맨 오른쪽에 0 추가)

단계 2: 범위 초과 비트 제거
4비트 시스템에서는 4번째 자리를 넘는 비트 무시

비트별 이동:
위치 3: 0 → 사라짐 (overflow)
위치 2: 1 → 위치 3으로 이동
위치 1: 0 → 위치 2로 이동
위치 0: 1 → 위치 1으로 이동
새 위치 0: 0 (padding)

```

**왼쪽 시프트 = 2배 곱셈:**

```

0101₂ (5) << 1 = 1010₂ (10) = 5 × 2

수학적 증명:
원본: a₃a₂a₁a₀
시프트: a₂a₁a₀0

값 비교:
원본 = a₃×8 + a₂×4 + a₁×2 + a₀×1
시프트 = a₂×8 + a₁×4 + a₀×2 + 0×1
      = (a₂×4 + a₁×2 + a₀×1) × 2
      = 원본 × 2 (a₃ 오버플로우 무시)

```

```bash

bash
1010 → 10
여기다가 0101를 더하면 3을 곱한 15가 된다.

```

**5 × 3 = 15 계산 과정:**

```

방법: 5 × 3 = 5 × (2 + 1) = 5×2 + 5×1

1단계: 5 × 2 (왼쪽 시프트)
0101 << 1 = 1010 (10)

2단계: 5 × 1 (원본 그대로)
0101 (5)

3단계: 두 결과 더하기
  1010  (10)
+ 0101  (5)
------
  1111  (15) ✓

비트별 덧셈:
위치 0: 0+1 = 1
위치 1: 1+0 = 1
위치 2: 0+1 = 1
위치 3: 1+0 = 1

```

**4비트로 표현하는 2진수 `1010`은 10이다. 왼쪽으로 한 칸 밀면 곱하기 2, 2칸 밀면 곱하기 4가 된다.**

**시프트 횟수와 곱셈 배수:**

```

원본 0101 (5):
<< 0: 0101 = 5  (5 × 2⁰ = 5 × 1)
<< 1: 1010 = 10 (5 × 2¹ = 5 × 2)
<< 2: 0100 = 4  (5 × 2² = 5 × 4 = 20, 오버플로우로 4만 남음)
<< 3: 1000 = 8  (5 × 2³ = 5 × 8 = 40, 오버플로우로 8만 남음)

일반 공식: A << n = A × 2ⁿ (오버플로우 무시)

```

**복잡한 곱셈의 시프트 분해:**

```

예시: 5 × 13 (13 = 8+4+1 = 2³+2²+2⁰)

13₁₀ = 1101₂
5 × 13 = 5×(8+4+1) = 5×8 + 5×4 + 5×1

계산:
5 × 8: 0101 << 3 = 1000 (8, 오버플로우)
5 × 4: 0101 << 2 = 0100 (4, 오버플로우)
5 × 1: 0101 << 0 = 0101 (5)

합계: 1000 + 0100 + 0101 = ?
실제로는 8비트로 확장해야 정확한 계산 가능

```

## ➗ 나눗셈 하는 방법(Shift 오른쪽으로 밀어)

**4비트를 6으로 표현 `0110`**

**6의 이진수 구조:**

```

6₁₀ = 0110₂

비트별 분해:
0110₂ = 0×2³ + 1×2² + 1×2¹ + 0×2⁰
      = 0×8 + 1×4 + 1×2 + 0×1
      = 0 + 4 + 2 + 0 = 6₁₀

```

**4비트를 0110을 오른쪽으로 밀면 `0011`이다. 맨 왼쪽에 0이 채워진다(Padding)**

```bash

bash
원본:   0110  (6)
시프트: 00110 → 패딩이 왼쪽에서 발생, 오른쪽에 넘어가는 범위는 제거
결과:   0011  (3)
6 / 2 = 3

```

**오른쪽 시프트의 상세 과정:**

```

오른쪽 시프트 (Right Shift) 과정:

단계 1: 모든 비트를 오른쪽으로 1칸 이동
0110 → 0011 (맨 왼쪽에 0 추가)

비트별 이동:
위치 0: 0 → 사라짐 (버려짐)
위치 1: 1 → 위치 0으로 이동
위치 2: 1 → 위치 1으로 이동
위치 3: 0 → 위치 2로 이동
새 위치 3: 0 (padding)

```

**오른쪽 시프트 = 2로 나눗셈:**

```

0110₂ (6) >> 1 = 0011₂ (3) = 6 ÷ 2

수학적 증명:
원본: a₃a₂a₁a₀ = a₃×8 + a₂×4 + a₁×2 + a₀×1
시프트: 0a₃a₂a₁ = 0×8 + a₃×4 + a₂×2 + a₁×1
                = a₃×4 + a₂×2 + a₁×1
                = (a₃×8 + a₂×4 + a₁×2) ÷ 2
                = (원본 - a₀) ÷ 2

주의: a₀ 비트는 손실됨 (홀수 처리 시 문제)

```

**시프트 횟수와 나눗셈:**

```

원본 1100₂ (12):
>> 0: 1100 = 12 (12 ÷ 2⁰ = 12 ÷ 1)
>> 1: 0110 = 6  (12 ÷ 2¹ = 12 ÷ 2)
>> 2: 0011 = 3  (12 ÷ 2² = 12 ÷ 4)
>> 3: 0001 = 1  (12 ÷ 2³ = 12 ÷ 8)

일반 공식: A >> n = A ÷ 2ⁿ (소수점 이하 버림)

```

**홀수 나눗셈의 문제:**

```

예시: 7 ÷ 2
0111₂ (7) >> 1 = 0011₂ (3)

정확한 값: 7 ÷ 2 = 3.5
시프트 결과: 3 (소수점 버림)

손실된 정보: 맨 오른쪽 비트 (1)
→ 나머지 연산으로 복구 가능

```

## 📏 비트 확장과 오버플로우 처리

**지금은 4비트 최대 15로 계산하지만 이를 넘어가는 범위는 8비트로 늘려서 처리하면 된다.**

**비트 확장 예시:**

```

4비트 한계: 0~15 (2⁴-1)
8비트 확장: 0~255 (2⁸-1)

5 × 13 = 65를 정확히 계산:

4비트에서 (오버플로우):
5 × 13 = 65 → 4비트로는 65-64 = 1만 표현

8비트에서 (정확한 계산):
5 = 00000101
13 = 00001101
5×13 = 01000001 = 65₁₀ ✓

```

**즉 비트수를 늘리거나 여러 번 연산처리해서 처리하면 된다.**

**다중 정밀도 연산:**

```

32비트 × 32비트 = 64비트 결과

방법 1: 하드웨어 확장
- 64비트 레지스터 사용
- 한 번에 처리

방법 2: 소프트웨어 분할
- 상위 16비트, 하위 16비트로 분할
- 부분 곱셈들을 조합
- 자리 올림 처리

예시: ABCD₁₆ × EFGH₁₆
= (AB00₁₆ + CD₁₆) × (EF00₁₆ + GH₁₆)
= AB×EF×10000₁₆ + AB×GH×100₁₆ + CD×EF×100₁₆ + CD×GH

```

## ➖ 반복 뺄셈으로 나눗셈

**즉 나눗셈 역시 뺄셈으로 처리할 수 있게 된다. 그러면 15/5를 예를 들면**

```bash

15-5 = 10
10이 5보다 크면 다시 뺀다
10-5 = 5
5-5 = 0
총 3번 뺀다.
즉 나누려는 수를 0보다 작은 수가 나올 때까지 뺀다.

```

**이진수 반복 뺄셈 예시:**

```

1111₂ (15) ÷ 0101₂ (5):

1단계: 1111 - 0101 = 1010 (10), 몫 = 1
2단계: 1010 - 0101 = 0101 (5),  몫 = 2
3단계: 0101 - 0101 = 0000 (0),  몫 = 3

최종: 15 ÷ 5 = 3, 나머지 = 0

```

**최적화된 나눗셈: 이진 장제법**

```

사람이 하는 긴 나눗셈과 동일:

     11₂ (3)
   ┌─────
101₂│1111₂ (15÷5)
     101↓
     ────
     101
     101
     ───
     000

과정:
1. 15에서 가장 큰 5의 배수 찾기
2. 8 < 15이므로 몫에 1 추가
3. 15-5 = 10, 나머지로 계속
4. 10에서 5를 빼면 5
5. 5에서 5를 빼면 0

결과: 몫 11₂ (3), 나머지 0

```

## ⚠️ 0으로 나눗셈의 위험성

**나눗셈 하는 방법2**

**그러면 7을 0으로 나누면???**

**7에서 0을 빼면 7이고 7은 0보다 크다.**

**7에서 0을 계속 빼면 계속 0보다 크기 때문에 무한하게 작업을 계속하게 된다.**

**0으로 나눗셈의 문제점 상세:**

```

수학적 문제:
7 ÷ 0 = ? (정의되지 않음)

컴퓨터에서 발생하는 문제:
while (remainder >= 0):  // 항상 참
    remainder = remainder - 0  // 값 변화 없음
    quotient = quotient + 1    // 무한 증가

결과:
- 무한 루프 발생
- quotient 오버플로우
- 시스템 응답 정지

```

**그러면 계속해서 전기를 사용하고 그에 따라 열에너지가 올라가서 칩이 폭발할 수도 있다. 그래서 어떤 숫자를 0으로 나누는 작업을 절대 하면 안 된다.**