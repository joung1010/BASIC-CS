# 디지털 회로와 덧셈

## ⚡ 기본 게이트 회로

**게이트 회로**

**진리표 완전 분석:**

| **A(input)** | **B(input)** | **AND (S-결과)** | **OR (S-결과)** | **XOR (S-결과)** | **NOT A (S-결)** |
| --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 1 | - |
| 1 | 1 | 1 | 1 | 0 | - |
|  |  |  |  |  |  |

**각 게이트의 상세 동작:**

### **AND 게이트 (논리곱)**

```

동작 원리: 모든 입력이 1일 때만 출력 1
실생활 비유: 스위치 2개를 직렬 연결
- 둘 다 켜야(1) 전구가 켜짐(1)
- 하나라도 꺼지면(0) 전구가 꺼짐(0)

회로 표현:
A ─┬─── AND ── S
B ─┘

```

### **OR 게이트 (논리합)**

```

동작 원리: 하나 이상의 입력이 1이면 출력 1
실생활 비유: 스위치 2개를 병렬 연결
- 하나라도 켜면(1) 전구가 켜짐(1)
- 둘 다 꺼야(0) 전구가 꺼짐(0)

회로 표현:
A ─┬─── OR ── S
B ─┘

```

### **XOR 게이트 (배타적 논리합)**

```

동작 원리: 두 입력이 서로 다를 때만 출력 1
실생활 비유: 3-way 스위치 (계단 조명)
- 다른 상태(0,1 또는 1,0)면 켜짐(1)
- 같은 상태(0,0 또는 1,1)면 꺼짐(0)

회로 표현:
A ─┬─── XOR ── S
B ─┘

```

**A와 B에 전기 신호를 하나도 보내지 않을 때(0,0) AND, OR, XOR의 경우 전기가 발생하지 않고 NOT만 전기 신호가 발생한다.**

**NOT 게이트 (논리 부정)**

```

동작 원리: 입력을 반전시킴
- 입력 0 → 출력 1 (전기 없음 → 전기 있음)
- 입력 1 → 출력 0 (전기 있음 → 전기 없음)

회로 표현:
A ── NOT ── S (항상 A의 반대)

```

**XOR(exclusive)는 두 값이 다를 때**

**XOR의 특별한 성질:**

```

XOR 연산의 활용:
- 암호화: A ⊕ Key ⊕ Key = A (복호화)
- 패리티 검사: 짝수/홀수 비트 개수 확인
- 덧셈: 자리 올림 없는 이진 덧셈

예시:
1010 ⊕ 1100 = 0110
(다른 비트만 1이 됨)

```

## 🔧 게이트 회로의 물리적 구현

- **AND, OR, XOR는 A와 B 두 입력을 받는 논리 게이트입니다.**
- **NOT은 A 하나만 입력으로 받아서 출력이 반전됩니다.**
- **NOT A의 경우 B 입력이 없으므로 빈 칸으로 표시했습니다.**

**IC 74X4는 4개의 AND 게이트회로로 이루어져 있다.**

**실제 IC(집적회로) 구조:**

```

74HC08 (4개의 AND 게이트):

    14핀 DIP 패키지
     ┌─────────────┐
VCC ─┤14        13├─ 4B
 4Y ─┤13        12├─ 4A
 4B ─┤12        11├─ 4Y
 4A ─┤11        10├─ 3B
 3Y ─┤ 9         9├─ 3A
 3B ─┤ 8         8├─ 3Y
 3A ─┤ 7         7├─ GND
     └─────────────┘

각 AND 게이트:
Gate 1: A1(1핀), B1(2핀) → Y1(3핀)
Gate 2: A2(4핀), B2(5핀) → Y2(6핀)
Gate 3: A3(9핀), B3(10핀) → Y3(8핀)
Gate 4: A4(12핀), B4(13핀) → Y4(11핀)

```

즉  전기 신호를 게이트 회로에 전달해서 어떤 상황에서 전기에 출력되는지를 확인할 수 있는데 이를 `반도체`라고 한다. **전기가 흐르기도 하고 흐르지 않기도 하기 때문이다.**

**반도체의 동작 원리:**

```

순수 실리콘: 전기가 잘 흐르지 않음 (절연체)

N형 반도체: 인(P) 첨가
- 전자(-)가 많음
- 전기가 잘 흐름

P형 반도체: 붕소(B) 첨가
- 정공(+)이 많음
- 전자 부족으로 전기 흡수

PN 접합: N형 + P형
- 전압 방향에 따라 전기 통과/차단
- 이것이 다이오드, 트랜지스터의 기본!

```

## 🖥️ CPU의 본질

**위의 기본 방식을 이용해서 CPU를 제작한다 그러면 CPU는 본질적으로 무엇이냐 단순하게 전자식 계산기(산수)이다.**

**CPU = 고속 전자 계산기:**

```

CPU 내부 구성:
1. ALU (Arithmetic Logic Unit): 산술/논리 연산
   - 덧셈, 뺄셈, 곱셈, 나눗셈
   - AND, OR, XOR, NOT 연산

2. 레지스터: 임시 데이터 저장
   - 연산할 숫자들 보관
   - 연산 결과 임시 저장

3. 제어 유닛: 명령어 해석 및 실행
   - 메모리에서 명령어 가져오기
   - 명령어를 게이트 신호로 변환

모든 것이 결국 0과 1의 전기 신호!

```

**그러면 굳이 전자일 필요가 있냐? 라고 생각했을 때 빛(오티컬)과 물 등 보다 전자식이 효율적이고 빠르기 때문이다.**

**다양한 컴퓨팅 방식 비교:**

```

전자식 (현재 주류):
- 속도: 전자 이동 속도 (광속의 1/100)
- 크기: 나노미터 단위 트랜지스터
- 전력: 상대적으로 낮음
- 안정성: 높음

광학식 (연구 중):
- 속도: 빛의 속도 (매우 빠름)
- 크기: 파장 제한으로 큼
- 전력: 높음 (레이저 필요)
- 간섭: 빛의 간섭 문제

기계식 (역사적):
- 속도: 매우 느림 (기어, 톱니바퀴)
- 크기: 방 크기
- 전력: 높음
- 내구성: 높음 (진공관 시대)

생체 (뇌):
- 속도: 느림 (화학 신호)
- 병렬성: 매우 높음
- 전력: 20W 정도
- 학습능력: 뛰어남

```

## ➕ 사칙연산과 덧셈의 중요성

**이 계산기에 가장 기본적인 기능이 `사칙연산`이다. 보통 가장 먼저 하는 것이 덧셈이다.**

**덧셈이 가장 기본인 이유:**

```

컴퓨터에서 모든 연산의 기초:

뺄셈: A - B = A + (-B) (2의 보수 덧셈)
곱셈: 반복 덧셈 (5 × 3 = 5 + 5 + 5)
나눗셈: 반복 뺄셈 (덧셈의 응용)

따라서 덧셈을 완벽히 구현하면:
→ 모든 산술 연산 가능
→ 논리 연산도 가능
→ 완전한 컴퓨터 완성!

```

## 🔢 2진수 덧셈과 반가산기

**덧셈을 이해하기 위한 간단한 구조 설명**

**컴퓨터가 덧셈하는 방법**

**2진수 1 + 1은 2진수 10(2)이다.**

**2진수 덧셈 규칙:**

```

0 + 0 = 0  (자리올림 없음)
0 + 1 = 1  (자리올림 없음)
1 + 0 = 1  (자리올림 없음)
1 + 1 = 10₂ (자리올림 발생!)

10진수와 비교:
9 + 1 = 10₁₀ (자리올림 발생)
1 + 1 = 10₂  (자리올림 발생)

```

**A가 1, B가 1이면 XOR 연산 결과 S는 0이다 동시에 A가 1, B가 1이면 AND 연산결과 C는 1이다. 이 1은 자리 올림(Carry)이다.**

**반가산기(Half Adder) 회로:**

```

입력: A, B (각각 1비트)
출력: S (Sum, 합), C (Carry, 자리올림)

논리식:
S = A ⊕ B (XOR 연산)
C = A ∧ B (AND 연산)

진리표:
A | B | S | C | 의미
--|---|---|---|----
0 | 0 | 0 | 0 | 0 + 0 = 0
1 | 0 | 1 | 0 | 1 + 0 = 1
0 | 1 | 1 | 0 | 0 + 1 = 1
1 | 1 | 0 | 1 | 1 + 1 = 10₂ (자리올림)

회로 구성:
A ─┬─── XOR ── S (합)
B ─┼─┐
   └─── AND ── C (자리올림)

```

**1+1일 때 2진수는 2값이 존재하지 않기 때문에 10(2) 즉 자리올림이 발생한다 이를 Carry라고 한다.**

**Carry의 실제 의미:**

```

10진수 예시:
  1 9
+ 1 3
-----
  3 2

9 + 3 = 12 → 2를 쓰고 1을 올림 (Carry)

2진수 예시:
  1 1
+ 1 1
-----
1 1 0

1 + 1 = 10₂ → 0을 쓰고 1을 올림 (Carry)

```

**이러한 계산기를 반가산기라고 한다.**

## 전가산기의 필요성

**이때 문제가 발생하는 `'A'`는 65이고 16진수로 0x41이다 이때**

```bash

bash
[0100][0001]

```

**8비트 덧셈의 실제 문제:**

```

문자 'A' = 65₁₀ = 01000001₂

만약 'A' + 'A'를 계산한다면:
  01000001
+ 01000001
-----------
  10000010 = 130₁₀

각 비트별 덧셈:
위치 0: 1 + 1 = 0, Carry = 1
위치 1: 0 + 0 + Carry(1) = 1, Carry = 0
위치 2: 0 + 0 + Carry(0) = 0, Carry = 0
...
위치 7: 0 + 0 + Carry(1) = 1, Carry = 0

```

**8비트에 대한 덧셈을 하게 되면 이러한 반가산기를 8개를 만들어서 처리하면 되는데 이 덧셈을 진행할 때 자리올림(Carry)가 발생하기 때문에 8비트 A,B를 더할 때 자리 올림까지 해서 총 3개의 비트를 합산할 수 있는 로직이 필요하게 된다.**

**전가산기가 필요한 이유:**

```

반가산기의 한계:
- 2개 입력만 처리 (A, B)
- 이전 자리에서 올라온 Carry 처리 불가

8비트 덧셈에서:
비트 0: A₀ + B₀ (반가산기로 충분)
비트 1: A₁ + B₁ + C₀ (3개 입력 필요!)
비트 2: A₂ + B₂ + C₁ (3개 입력 필요!)
...
비트 7: A₇ + B₇ + C₆ (3개 입력 필요!)

→ 3개 입력을 처리할 수 있는 전가산기 필요!

```

## 🔧 전가산기 (Full Adder)

**이러한 가산기를 `전가산기`라 하고 이 전가산기를 병렬로 연결해서 처리한다.**

**전가산기 구조:**

```

입력: A, B, Cin (이전 자리에서 올라온 Carry)
출력: S (Sum), Cout (다음 자리로 보낼 Carry)

논리식:
S = A ⊕ B ⊕ Cin
Cout = (A ∧ B) ∨ (Cin ∧ (A ⊕ B))

진리표:
A | B | Cin | S | Cout | 의미
--|---|-----|---|------|-----
0 | 0 |  0  | 0 |  0   | 0+0+0=0
0 | 0 |  1  | 1 |  0   | 0+0+1=1
0 | 1 |  0  | 1 |  0   | 0+1+0=1
0 | 1 |  1  | 0 |  1   | 0+1+1=10₂
1 | 0 |  0  | 1 |  0   | 1+0+0=1
1 | 0 |  1  | 0 |  1   | 1+0+1=10₂
1 | 1 |  0  | 0 |  1   | 1+1+0=10₂
1 | 1 |  1  | 1 |  1   | 1+1+1=11₂

```

**전가산기 내부 구조:**

```

A ─┬─── XOR ──┬─── XOR ── S
B ─┼─┐        │
   └─── AND ──┼─── OR ─── Cout
Cin ──────────┘
     └─── AND ──┘

실제로는 반가산기 2개 + OR 게이트 1개로 구성

```

**이 전가산기 4개가 연결되어 있으면 4bit 전가산기이다.**

**4비트 전가산기 (Ripple Carry Adder):**

```

        A₃ B₃     A₂ B₂     A₁ B₁     A₀ B₀
         │  │      │  │      │  │      │  │
         ▼  ▼      ▼  ▼      ▼  ▼      ▼  ▼
       ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐
C₃ ◄──┤ FA₃ │◄──┤ FA₂ │◄──┤ FA₁ │◄──┤ FA₀ │◄── C₀=0
       └─────┘   └─────┘   └─────┘   └─────┘
         │         │         │         │
         ▼         ▼         ▼         ▼
        S₃        S₂        S₁        S₀

FA = Full Adder (전가산기)
Carry가 오른쪽에서 왼쪽으로 전파 (Ripple)

```

**8비트 전가산기 동작 예시:**

```

  01000001  (65, 'A')
+ 01000001  (65, 'A')
-----------
  10000010  (130)

비트별 계산:
위치 0: 1+1+0 = 0, Carry=1
위치 1: 0+0+1 = 1, Carry=0
위치 2: 0+0+0 = 0, Carry=0
위치 3: 0+0+0 = 0, Carry=0
위치 4: 0+0+0 = 0, Carry=0
위치 5: 0+0+0 = 0, Carry=0
위치 6: 1+1+0 = 0, Carry=1
위치 7: 0+0+1 = 1, Carry=0 (최종 결과에 영향 없음)

```

## ⚡ 고급 가산기 구조

**Carry 전파 지연 문제와 해결책:**

```

Ripple Carry Adder의 문제:
- Carry가 순차적으로 전파
- 32비트라면 32번의 지연 발생
- 전체 연산 속도 저하

해결책:
1. Carry Look-Ahead Adder
   - Carry를 미리 계산
   - 병렬 처리로 속도 향상

2. Carry Save Adder
   - 여러 수를 동시에 더할 때 사용
   - Carry를 나중에 한 번에 처리

```

**현대 CPU의 ALU:**

```

Intel Core i7 ALU:
- 64비트 정수 연산
- 벡터 연산 (SIMD)
- 부동소수점 연산
- 분기 예측과 결합

모든 것의 기초는 여전히:
→ AND, OR, XOR, NOT 게이트
→ 전가산기의 조합!

```

## 핵심 요약

1. **기본 게이트**: AND, OR, XOR, NOT이 모든 디지털 회로의 기초
2. **CPU 본질**: 고속 전자 계산기, 사칙연산이 모든 연산의 기반
3. **반가산기**: 2개 입력의 1비트 덧셈 (A + B = S, Carry)
4. **전가산기**: 3개 입력의 1비트 덧셈 (A + B + Cin = S, Cout)
5. **다중 비트**: 전가산기를 병렬 연결하여 8/16/32/64비트 연산 구현
6. **반도체**: 전기의 흐름을 제어하여 논리 연산을 물리적으로 구현