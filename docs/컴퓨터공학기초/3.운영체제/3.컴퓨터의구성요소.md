# 컴퓨터 구성요소와 프로세스/스레드

## 💻 컴퓨터의 기본 구성요소

### **하드웨어와 소프트웨어의 관계**

`컴퓨터 시스템 구조:

┌─────────────────────────────────────────┐
│            Computer System             │
├─────────────────┬───────────────────────┤
│   Hardware      │      Software         │
│   (물리적 부품)  │   (논리적 명령어)      │
├─────────────────┼───────────────────────┤
│ • CPU           │ • Application S/W     │
│ • Memory        │   - MS Office         │
│ • Storage       │   - Chrome Browser    │
│ • I/O Devices   │   - Games             │
│                 │                       │
│                 │ • System S/W          │
│                 │   - Operating System  │
│                 │   - Device Drivers    │
│                 │   - Utilities         │
└─────────────────┴───────────────────────┘`

### **소프트웨어 계층 구조**

`소프트웨어 스택:

┌──────────────────────────────────┐  ← 사용자 영역
│        Application S/W           │
│  (Word, Excel, Chrome, Games)    │
├──────────────────────────────────┤
│      Programming Tools           │
│   (컴파일러, IDE, 라이브러리)      │
├──────────────────────────────────┤  ← 시스템 영역
│        System S/W               │
│     (Operating System)          │
├──────────────────────────────────┤
│       Device Drivers            │
│    (하드웨어 제어 소프트웨어)     │
├──────────────────────────────────┤
│          Hardware               │
│    (CPU, Memory, Storage)       │  ← 물리적 영역
└──────────────────────────────────┘`

### **운영체제(OS)의 역할**

**운영체제는 하드웨어와 응용 프로그램 사이의 중재자입니다.**

`운영체제의 주요 기능:

1. 프로세스 관리 (Process Management)
    - 프로그램 실행 및 종료
    - CPU 시간 할당 (스케줄링)
    - 프로세스 간 통신 지원

2. 메모리 관리 (Memory Management)
    - 물리/가상 메모리 할당
    - 메모리 보호 및 최적화
    - 가비지 컬렉션 지원

3. 파일 시스템 관리 (File System)
    - 파일 저장 및 검색
    - 디렉토리 구조 관리
    - 권한 및 보안 제어

4. 입출력 관리 (I/O Management)
    - 키보드, 마우스, 모니터 제어
    - 네트워크 통신 관리
    - 프린터, USB 등 주변장치 관리

5. 보안 및 사용자 관리
    - 사용자 인증 및 권한 관리
    - 악성코드 방지
    - 시스템 자원 보호`

### **대표적인 운영체제들**

`Windows 계열:
- 특징: GUI 친화적, 게임/사무용 강세
- 파일시스템: NTFS
- 쉘: Explorer.exe (탐색기)
- 장점: 직관적 인터페이스, 광범위한 소프트웨어 호환성

Unix/Linux 계열:
- 특징: 서버/개발 환경 강세, 오픈소스
- 파일시스템: ext4, xfs
- 쉘: bash, zsh
- 장점: 강력한 명령줄, 높은 안정성과 보안성

macOS:
- 특징: Unix 기반, 애플 생태계
- 파일시스템: APFS
- 쉘: Finder (파인더)
- 장점: Unix 안정성 + 세련된 UI`

## 🔄 프로그램, 프로세스, 스레드의 관계

### **기본 개념 정리**

`생명주기 관점에서 보는 실행 과정:

1단계: 프로그램 (Program) - 정적 상태
├─ 하드 디스크에 저장된 실행 파일
├─ 예: Excel.exe, Chrome.exe, game.exe
└─ 아직 실행되지 않은 코드와 데이터의 집합

2단계: 프로세스 (Process) - 동적 상태  
├─ 메모리에 로드되어 실행 중인 프로그램
├─ 운영체제가 할당한 고유 PID 보유
└─ 독립적인 메모리 공간 사용

3단계: 스레드 (Thread) - 실행 단위
├─ 프로세스 내부의 실제 실행 흐름
├─ CPU가 실제로 처리하는 최소 단위
└─ 프로세스의 자원을 공유하며 실행`

### **Excel 프로그램의 실행 과정 예시**

`1단계: 프로그램 상태 (설치만 된 상태)
위치: C:\Program Files\Microsoft Office\Excel.exe
크기: 50MB
상태: 디스크에 저장된 파일, 실행되지 않음

2단계: 프로세스 상태 (실행 버튼 클릭 후)
- 운영체제가 Excel.exe를 메모리에 로드
- PID 할당 (예: 1234)
- 독립적인 메모리 공간 할당 (150MB RAM 사용)
- 프로세스 이름: EXCEL.EXE

3단계: 스레드들 (실제 작업 수행)
- 메인 UI 스레드: 사용자 인터페이스 관리
- 계산 스레드: 수식 계산 처리
- 자동 저장 스레드: 5분마다 문서 자동 저장
- 인쇄 스레드: 인쇄 작업 처리`

### **프로세스와 스레드의 차이점**

`프로세스 (관리 단위):
┌─────────────────────────────────┐
│         Process 1234            │  ← 운영체제가 관리
│  (Excel.exe)                    │
├─────────────────────────────────┤
│ • 독립된 메모리 공간            │
│ • 고유한 PID (1234)             │
│ • 파일 핸들, 네트워크 연결 등   │
│ • 보안 컨텍스트                 │
├─────────────────────────────────┤
│   Thread 1  │  Thread 2  │...  │  ← CPU가 실행
│  (UI 담당)  │ (계산 담당) │     │
└─────────────────────────────────┘

스레드 (실행 단위):
- 실제로 CPU에서 실행되는 코드 흐름
- 프로세스의 메모리와 자원을 공유
- 각자 독립적인 스택 영역 보유
- 프로세스보다 생성/전환 비용이 낮음`

### **PID(Process ID)의 이해**

`PID의 특성:
- 운영체제가 각 프로세스에 부여하는 고유 번호
- 프로세스 생성 시 자동 할당
- 프로세스 종료 시 반납되어 재사용 가능
- 시스템 전체에서 중복되지 않음

PID 확인 방법:
Windows: 작업 관리자, tasklist 명령
Linux/macOS: ps 명령, top 명령

예시:
PID 1: init (Linux) / System Idle Process (Windows)
PID 1000: explorer.exe (Windows 탐색기)
PID 2345: chrome.exe (크롬 브라우저)`

## 🏠 메모리 구조: 집과 같은 공간 분할

### **집 비유로 이해하는 메모리 구조**

`가족 (프로세스)이 사는 집 (메모리 공간):

┌─────────────────────────────────────┐
│              집 (Process)           │
├─────────────────────────────────────┤
│  개인 방들 (Stack) - 각자 전용      │
│  ┌──────┐ ┌──────┐ ┌──────┐       │
│  │아빠방│ │엄마방│ │아이방│       │  ← 각 스레드 전용
│  │Thread│ │Thread│ │Thread│       │
│  │  1   │ │  2   │ │  3   │       │
│  └──────┘ └──────┘ └──────┘       │
├─────────────────────────────────────┤
│     공용 공간들 (Heap) - 공유       │
│  ┌──────────────────────────────┐  │
│  │        거실 (공유 객체)       │  │  ← 모든 스레드 공유
│  │        부엌 (공유 데이터)     │  │
│  │        욕실 (공유 리소스)     │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘`

### **Stack과 Heap의 특성**

`Stack 영역 (개인 방):
┌─────────────────────────────────┐
│         Thread Stack            │
├─────────────────────────────────┤
│  최근 함수 호출                  │  ← 스택 톱
│  ┌─────────────────────────┐   │
│  │ method3()               │   │
│  │ - int param = 5         │   │
│  │ - String local = "abc"  │   │
│  └─────────────────────────┘   │
│  ┌─────────────────────────┐   │
│  │ method2()               │   │
│  │ - double value = 3.14   │   │
│  └─────────────────────────┘   │
│  ┌─────────────────────────┐   │
│  │ main()                  │   │
│  │ - int[] array           │   │  ← 스택 바텀
│  └─────────────────────────┘   │
└─────────────────────────────────┘

특징:
- LIFO (Last In, First Out) 구조
- 함수 호출/리턴과 함께 자동 관리
- 빠른 할당/해제
- 크기 제한 있음 (보통 1-8MB)
- 각 스레드마다 독립적

Heap 영역 (공용 공간):
┌─────────────────────────────────┐
│         Shared Heap             │
├─────────────────────────────────┤
│  ┌─────────┐ ┌─────────────┐   │
│  │ Object1 │ │ ArrayList   │   │  ← 동적 할당
│  └─────────┘ └─────────────┘   │
│  ┌─────────────────────────┐   │
│  │ Large Array             │   │
│  └─────────────────────────┘   │
│  ┌───────┐ ┌───────┐ ┌────┐   │
│  │Object2│ │String │ │... │   │
│  └───────┘ └───────┘ └────┘   │
└─────────────────────────────────┘

특징:
- 동적 메모리 할당
- 가비지 컬렉션으로 관리 (언어별 차이)
- 상대적으로 느린 할당/해제
- 큰 용량 사용 가능
- 모든 스레드가 공유`

### **실제 메모리 사용 예시**

`Excel 실행 시 메모리 사용 패턴:

스레드별 Stack 사용:
UI 스레드 Stack:
- 이벤트 처리 함수들
- 화면 그리기 관련 지역 변수
- 사용자 입력 처리 변수

계산 스레드 Stack:
- 수식 계산 함수들
- 임시 계산 결과 변수
- 반복문 카운터 등

공유 Heap 사용:
- 워크시트 데이터 (셀 내용들)
- 차트 객체들
- 이미지, 그래프 데이터
- 사용자 설정 정보`

## 🔍 프로세스의 깊이 있는 이해

### **컴퓨터 세상에서의 정체성**

**프로세스는 컴퓨터 세상에서의 "존재" 그 자체입니다.**

`인간 세계 vs 컴퓨터 세계:

인간 세계:
- 유전자 (DNA) → 개인의 특성 결정
- 사람 → 사회에서 활동하는 개체
- 주민등록번호 → 고유 식별자
- 집 → 개인 공간

컴퓨터 세계:
- 프로그램 (Code) → 프로세스의 특성 결정
- 프로세스 → 시스템에서 활동하는 개체
- PID → 고유 식별자
- 메모리 공간 → 프로세스 공간

철학적 관점:
프로그램 = 가능성 (Potential)
프로세스 = 현실화된 존재 (Actualized Being)`

### **Shell/탐색기: 컴퓨터 세상의 "나"**

**Shell은 컴퓨터 세상에서 사용자를 대표하는 "나"의 역할을 합니다.**

`Windows의 "나" - Explorer.exe:
역할: 윈도우 데스크탑 환경의 주인
담당 업무:
- 바탕화면 관리 (아이콘, 배경화면)
- 작업 표시줄 표시 (시작 메뉴, 알림 영역)
- 파일 탐색기 제공
- 다른 프로그램 실행 관리
- 창 관리 및 전환

특징:
- Windows 부팅과 함께 자동 시작
- 종료하면 바탕화면이 사라짐
- 사용자와 시스템 간 주요 인터페이스

Linux의 "나" - Shell (bash, zsh 등):
역할: 명령행 인터페이스의 주인
담당 업무:
- 사용자 명령어 해석 및 실행
- 환경 변수 관리
- 쉘 스크립트 실행
- 프로세스 제어 (background/foreground)
- 파이프라인, 리다이렉션 처리

특징:
- 텍스트 기반 상호작용
- 강력한 자동화 기능
- 원격 접속 시 주요 인터페이스`

### **프로세스의 생명주기**

`프로세스 상태 전이:

NEW → READY → RUNNING → TERMINATED
↑      ↕         ↓
└────WAITING─────┘

상태별 설명:

NEW (생성됨):
- 프로그램이 메모리에 로드됨
- PID 할당됨
- 아직 실행 준비 안됨

READY (실행 준비됨):
- 실행할 준비 완료
- CPU 할당을 기다리는 상태
- 스케줄러의 선택을 대기

RUNNING (실행 중):
- CPU를 할당받아 실제 실행 중
- 명령어들이 순차적으로 처리됨
- 시간 할당량 소진 시 READY로 복귀

WAITING (대기 중):
- I/O 작업 대기 (파일 읽기, 네트워크 등)
- 사용자 입력 대기
- 다른 프로세스의 신호 대기

TERMINATED (종료됨):
- 정상 종료 또는 오류로 인한 종료
- 할당된 자원들이 시스템으로 반납
- PID 반납되어 재사용 가능`

### **프로세스 생성 과정**

`프로세스 생성 단계:

1. 프로그램 로딩:
    - 실행 파일을 디스크에서 읽음
    - 코드, 데이터 영역을 메모리에 로드
    - 동적 라이브러리 링킹

2. 메모리 공간 할당:
    - 가상 메모리 주소 공간 생성
    - Stack, Heap 영역 초기화
    - 세그먼트별 권한 설정 (읽기/쓰기/실행)

3. 프로세스 제어 블록 (PCB) 생성:
    - PID 할당
    - 상태 정보 초기화
    - 레지스터 컨텍스트 설정
    - 파일 디스크립터 테이블 생성

4. 실행 시작:
    - main() 함수 (또는 진입점) 호출
    - 최소 하나의 메인 스레드 생성
    - READY 상태로 전환`

## 🔀 프로세스 간 통신과 관리

### **프로세스 간 통신 (IPC - Inter-Process Communication)**

**프로세스들은 독립적인 메모리 공간을 가지므로, 서로 통신하려면 특별한 메커니즘이 필요합니다.**

`IPC 방식들:

1. 파이프 (Pipe):
    - 한 프로세스의 출력을 다른 프로세스의 입력으로 연결
    - 예: Linux 명령어 "ls | grep txt"
    - 단방향 통신, 부모-자식 프로세스 간 주로 사용

2. 명명된 파이프 (Named Pipe/FIFO):
    - 파일 시스템에 이름을 가진 파이프
    - 관련 없는 프로세스들도 통신 가능
    - 양방향 통신 지원

3. 공유 메모리 (Shared Memory):
    - 여러 프로세스가 같은 메모리 영역을 공유
    - 가장 빠른 IPC 방식
    - 동기화 문제 해결 필요

4. 메시지 큐 (Message Queue):
    - 프로세스 간 메시지를 큐에 저장하여 전달
    - 비동기 통신 가능
    - 메시지 우선순위 지원

5. 소켓 (Socket):
    - 네트워크 통신뿐만 아니라 로컬 통신도 가능
    - TCP/UDP 소켓, Unix 도메인 소켓
    - 가장 범용적인 IPC 방식

6. 시그널 (Signal):
    - 프로세스에게 이벤트 발생을 알리는 방식
    - 예: Ctrl+C (SIGINT), 종료 요청 (SIGTERM)
    - 단순한 알림 용도`

### **실제 IPC 사용 예시**

`웹 브라우저의 다중 프로세스 아키텍처:

브라우저 메인 프로세스 (chrome.exe PID: 1000):
- 사용자 인터페이스 관리
- 탭 관리, 북마크, 설정

렌더러 프로세스들:
- 탭1 프로세스 (chrome.exe PID: 1001): 네이버 페이지
- 탭2 프로세스 (chrome.exe PID: 1002): 유튜브 페이지
- 탭3 프로세스 (chrome.exe PID: 1003): 구글 검색

통신 방식:
- 메인 ↔ 렌더러: 소켓 기반 IPC
- 메시지 내용: 페이지 로드 요청, 스크롤 위치, 클릭 이벤트
- 이점: 한 탭 크래시가 다른 탭에 영향 없음`

### **프로세스 스케줄링**

**운영체제는 여러 프로세스 중 어떤 것을 먼저 실행할지 결정해야 합니다.**

`스케줄링 알고리즘들:

1. FCFS (First Come, First Served):
    - 도착 순서대로 실행
    - 구현 간단하지만 대기 시간 길어질 수 있음

2. SJF (Shortest Job First):
    - 실행 시간이 짧은 작업부터 실행
    - 평균 대기 시간 최소화
    - 긴 작업의 기아 상태 발생 가능

3. Round Robin:
    - 모든 프로세스에 동일한 시간 할당량 부여
    - 시간 다 쓰면 다음 프로세스로 교체
    - 대화형 시스템에 적합

4. Priority Scheduling:
    - 우선순위가 높은 프로세스부터 실행
    - 우선순위 동적 조정 가능
    - 낮은 우선순위 작업의 기아 상태 주의

5. Multi-Level Queue:
    - 프로세스를 여러 큐로 분류
    - 시스템 프로세스, 대화형, 배치 작업 등
    - 각 큐마다 다른 스케줄링 정책 적용`

### **프로세스 우선순위**

`Windows 우선순위 클래스:
- Realtime: 실시간 처리 (위험함, 시스템 멈출 수 있음)
- High: 높은 우선순위
- Above Normal: 보통보다 높음
- Normal: 일반적인 우선순위 (기본값)
- Below Normal: 보통보다 낮음
- Idle: 시스템이 한가할 때만 실행

Linux Nice 값:
- 범위: -20 (가장 높음) ~ +19 (가장 낮음)
- 0: 기본 우선순위
- root만 음수 값 설정 가능
- 명령어: nice -n 10 command`

## 📊 시스템 모니터링과 관리

### **프로세스 모니터링 도구들**

`Windows:
- 작업 관리자 (Task Manager): 기본 프로세스 관리
- 리소스 모니터: 상세한 시스템 자원 사용률
- 성능 모니터: 시간별 성능 추적
- Process Explorer: 고급 프로세스 분석

Linux/macOS:
- ps: 현재 실행 중인 프로세스 목록
- top/htop: 실시간 프로세스 모니터링
- vmstat: 가상 메모리 통계
- iostat: I/O 통계
- sar: 시스템 활동 리포터

명령어 예시:
ps aux                    # 모든 프로세스 상세 정보
ps -ef | grep chrome     # Chrome 관련 프로세스만
top -p 1234              # 특정 PID 모니터링
kill -TERM 1234          # 정상 종료 요청
kill -KILL 1234          # 강제 종료`

### **메모리 관리**

`메모리 사용 패턴:

물리 메모리 (RAM):
- 프로세스가 실제로 사용하는 메모리
- 부족할 경우 스왑 파일 사용
- 자주 사용되는 데이터 우선 유지

가상 메모리:
- 각 프로세스마다 독립적인 주소 공간
- 물리 메모리보다 큰 공간 사용 가능
- 페이지 단위로 관리 (보통 4KB)

메모리 누수 (Memory Leak):
- 사용하지 않는 메모리를 해제하지 않는 문제
- 시간이 지날수록 메모리 사용량 증가
- 시스템 성능 저하 및 불안정 야기

메모리 최적화:
- 불필요한 프로그램 종료
- 메모리 사용량 모니터링
- 정기적인 시스템 재시작`

### **성능 최적화**

`프로세스 성능 최적화 방법:

1. 프로세스 우선순위 조정:
    - 중요한 작업의 우선순위 높임
    - 배경 작업의 우선순위 낮춤

2. CPU 친화도 (Affinity) 설정:
    - 특정 프로세스를 특정 CPU 코어에 고정
    - 캐시 효율성 향상
    - 멀티코어 시스템에서 유용

3. 메모리 최적화:
    - 작업 세트 크기 조정
    - 페이지 파일 설정 최적화
    - 메모리 압축 기능 활용

4. I/O 최적화:
    - SSD 사용으로 디스크 I/O 향상
    - 파일 시스템 최적화
    - 네트워크 대역폭 관리

5. 프로세스 분리:
    - 독립적인 기능을 별도 프로세스로 분리
    - 안정성 향상 (한 부분 오류가 전체에 영향 X)
    - 확장성 개선`