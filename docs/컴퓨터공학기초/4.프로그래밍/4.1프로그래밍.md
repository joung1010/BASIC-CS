# 프로그래밍: 일하는 절차에 대한 글쓰기

## 📝 프로그래밍의 본질

### **프로그래밍 = 절차적 글쓰기**

프로그래밍의 정의:
"어떤 일들의 진행 순서를 정의하는 것"
"일하는 절차에 대한 글쓰기"

핵심 개념:
1. 순서 (Sequence): 어떤 순서로 진행할 것인가?
2. 절차 (Procedure): 각 단계에서 무엇을 할 것인가?
3. 조건 (Condition): 어떤 상황에서 어떻게 대응할 것인가?
4. 자동화 (Automation): 사람이 아닌 컴퓨터가 수행하도록

### **프로그래밍 언어: 절차를 표현하는 도구**

프로그래밍 언어들:
Java, Python, C, JavaScript, Go, Rust...

이들의 공통점:
- 절차를 체계적으로 기술하는 문법 제공
- 조건과 반복을 표현하는 구조 제공
- 컴퓨터가 이해할 수 있는 형태로 변환 가능

차이점:
- 표현 방식의 차이 (문법)
- 실행 환경의 차이 (컴파일/인터프리터)
- 특화 분야의 차이 (웹/시스템/데이터분석)

하지만 본질은 같음: "절차적 글쓰기"

## 🥜 실생활 예시: 땅콩버터 샌드위치 만들기

### **상세한 절차 기술의 중요성**

일반인의 설명:
"땅콩버터를 식빵에 발라서 샌드위치를 만든다."

프로그래머의 설명 (절차적 글쓰기):
1. 필요한 재료와 도구 확인
    - 식빵 2장 있는지 확인
    - 땅콩버터 용기 있는지 확인
    - 나이프 있는지 확인
    - 접시 있는지 확인

2. 전처리 작업
    - 손을 깨끗이 씻는다
    - 작업 공간을 정리한다
    - 재료들을 작업대에 배치한다

3. 땅콩버터 준비
    - 땅콩버터 용기 뚜껑이 있는지 확인
    - 뚜껑이 있다면 시계방향으로 돌려서 연다
    - 뚜껑이 없다면 다음 단계로

4. 버터 발라내기
    - 나이프를 땅콩버터에 2cm 깊이로 삽입
    - 나이프를 시계방향으로 한 바퀴 돌려서 버터를 묻힌다
    - 용기 가장자리에서 excess 버터를 제거한다

5. 식빵에 발라내기
    - 식빵 1장을 접시 위에 놓는다
    - 나이프로 버터를 식빵 표면에 고르게 펴바른다
    - 가장자리 1cm는 여백을 둔다

6. 샌드위치 완성
    - 나머지 식빵 1장을 위에 덮는다
    - 가볍게 눌러서 고정한다

7. 정리 작업
    - 사용한 나이프를 설거지통에 넣는다
    - 땅콩버터 용기 뚜껑을 닫는다
    - 작업대를 정리한다

### **조건 분석의 중요성**

조건 분석 (전제 조건 체크):

IF 식빵이 2장 미만이라면:
→ 추가 식빵 구매 필요
→ 또는 작업 중단

IF 땅콩버터가 없다면:
→ 대체재 찾기 (잼, 치즈 등)
→ 또는 땅콩버터 구매

IF 나이프가 없다면:
→ 대체 도구 찾기 (숟가락, 포크)
→ 또는 손가락 사용 (비추천)

IF 땅콩 알레르기가 있다면:
→ 전체 계획 변경 필요
→ 다른 샌드위치 레시피 선택

예외 상황 처리:
- 땅콩버터가 너무 딱딱하다면?
- 식빵이 곰팡이 났다면?
- 나이프가 더럽다면?

## 💻 프로그래밍에서의 절차적 사고

실제 프로그래밍 예시: 사용자 로그인 시스템

```java
// 절차적 글쓰기로 표현한 로그인 시스템

public class LoginService {
    private DatabaseConnection database;
    private Logger logger;
    
    /**
     * 사용자 로그인 절차를 정의
     */
    public LoginResult loginProcess() {
        // 1. 전제 조건 확인
        if (!isDatabaseConnectionAvailable()) {
            return new LoginResult(false, "시스템 오류: 데이터베이스 연결 불가");
        }
        
        if (!isLoginFormDisplayed()) {
            displayLoginForm();
        }
        
        // 2. 사용자 입력 받기
        String username = getUserInput("사용자명을 입력하세요: ");
        String password = getUserInput("비밀번호를 입력하세요: ");
        
        // 3. 입력값 유효성 검사
        if (!validateUsername(username)) {
            return new LoginResult(false, "오류: 사용자명 형식이 올바르지 않습니다");
        }
        
        if (!validatePasswordFormat(password)) {
            return new LoginResult(false, "오류: 비밀번호 형식이 올바르지 않습니다");
        }
        
        // 4. 데이터베이스 조회
        UserRecord userRecord = database.query(
            "SELECT * FROM users WHERE username = ?", username);
        
        // 5. 사용자 존재 여부 확인
        if (userRecord == null) {
            logger.logFailedAttempt(username, "사용자 없음");
            return new LoginResult(false, 
                "로그인 실패: 사용자명 또는 비밀번호가 올바르지 않습니다");
        }
        
        // 6. 비밀번호 검증
        if (!verifyPassword(password, userRecord.getHashedPassword())) {
            logger.logFailedAttempt(username, "비밀번호 불일치");
            return new LoginResult(false, 
                "로그인 실패: 사용자명 또는 비밀번호가 올바르지 않습니다");
        }
        
        // 7. 계정 상태 확인
        if (userRecord.isLocked()) {
            return new LoginResult(false, 
                "로그인 실패: 계정이 잠겨있습니다. 관리자에게 문의하세요");
        }
        
        if (userRecord.isExpired()) {
            return new LoginResult(false, "로그인 실패: 계정이 만료되었습니다");
        }
        
        // 8. 로그인 성공 처리
        createUserSession(userRecord.getUserId());
        updateLastLoginTime(userRecord.getUserId());
        logger.logSuccessfulLogin(username);
        
        return new LoginResult(true, "로그인 성공");
    }
    
    /**
     * 사용자명 유효성 검사 절차
     */
    private boolean validateUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return false;
        }
        
        if (username.length() < 3 || username.length() > 20) {
            return false;
        }
        
        // 영숫자만 허용
        if (!username.matches("^[a-zA-Z0-9]+$")) {
            return false;
        }
        
        return true;
    }
    
    // 로그인 결과를 담는 클래스
    public static class LoginResult {
        private boolean success;
        private String message;
        
        public LoginResult(boolean success, String message) {
            this.success = success;
            this.message = message;
        }
        
        // getter methods
        public boolean isSuccess() { return success; }
        public String getMessage() { return message; }
    }
}
```

조건부 실행과 분기 처리

```java
// 조건에 따른 다양한 처리 절차

public class PaymentProcessor {
    
    /**
     * 결제 처리 절차 - 조건별 분기
     */
    public PaymentResult processPayment(BigDecimal amount, 
                                      PaymentMethod paymentMethod, 
                                      UserAccount userAccount) {
        
        // 1. 기본 유효성 검사
        if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            return new PaymentResult(false, "결제 금액이 올바르지 않습니다", null);
        }
        
        if (userAccount.getBalance().compareTo(amount) < 0) {
            return new PaymentResult(false, "잔액이 부족합니다", null);
        }
        
        String transactionId = null;
        
        // 2. 결제 방법별 처리 절차
        switch (paymentMethod) {
            case CREDIT_CARD:
                // 신용카드 결제 절차
                CreditCard cardInfo = getCardInfo(userAccount);
                
                if (!validateCard(cardInfo)) {
                    return new PaymentResult(false, "카드 정보가 유효하지 않습니다", null);
                }
                
                // 카드사 승인 요청
                ApprovalResult approvalResult = requestCardApproval(cardInfo, amount);
                
                if (!approvalResult.isApproved()) {
                    return new PaymentResult(false, "카드 승인이 거부되었습니다", null);
                }
                
                // 결제 완료 처리
                transactionId = processCardPayment(cardInfo, amount);
                break;
                
            case BANK_TRANSFER:
                // 계좌이체 절차
                BankAccount bankAccount = getBankAccount(userAccount);
                
                if (!validateBankAccount(bankAccount)) {
                    return new PaymentResult(false, "계좌 정보가 유효하지 않습니다", null);
                }
                
                // 은행 시스템 연동
                TransferResult transferResult = initiateBankTransfer(bankAccount, amount);
                
                if (!transferResult.isSuccess()) {
                    return new PaymentResult(false, "계좌이체가 실패했습니다", null);
                }
                
                transactionId = transferResult.getTransactionId();
                break;
                
            case DIGITAL_WALLET:
                // 디지털 지갑 결제 절차
                DigitalWallet wallet = getDigitalWallet(userAccount);
                
                if (wallet.getBalance().compareTo(amount) < 0) {
                    return new PaymentResult(false, "지갑 잔액이 부족합니다", null);
                }
                
                // 지갑에서 차감
                wallet.setBalance(wallet.getBalance().subtract(amount));
                updateWalletBalance(wallet);
                
                transactionId = generateTransactionId();
                break;
                
            default:
                return new PaymentResult(false, "지원하지 않는 결제 방법입니다", null);
        }
        
        // 3. 공통 후처리 절차
        updateUserBalance(userAccount, amount.negate());
        recordTransaction(userAccount.getId(), amount, paymentMethod, transactionId);
        sendPaymentConfirmation(userAccount.getEmail(), amount, transactionId);
        
        return new PaymentResult(true, "결제가 완료되었습니다", transactionId);
    }
    
    // 결제 방법 열거형
    public enum PaymentMethod {
        CREDIT_CARD, BANK_TRANSFER, DIGITAL_WALLET
    }
    
    // 결제 결과 클래스
    public static class PaymentResult {
        private boolean success;
        private String message;
        private String transactionId;
        
        public PaymentResult(boolean success, String message, String transactionId) {
            this.success = success;
            this.message = message;
            this.transactionId = transactionId;
        }
        
        // getter methods
        public boolean isSuccess() { return success; }
        public String getMessage() { return message; }
        public String getTransactionId() { return transactionId; }
    }
}
```

## 🔄 실행과 고유한 흐름

### **프로그램 실행의 의미**

실행 (Execution)의 정의:
글로 작성된 "해야 할 일"을 정한 순서대로 수행하는 것

실행의 특성:

1. 순차성: 위에서 아래로, 하나씩 차례대로
2. 조건부: IF-ELSE에 따라 다른 경로 선택
3. 반복성: LOOP을 통한 같은 작업 반복
4. 고유성: 매번 실행할 때마다 독특한 상황과 결과

예시: 같은 프로그램, 다른 실행 흐름

```java
// 같은 코드, 다른 실행 흐름 예시

public class GreetingService {
    
    public void greetUser() {
        LocalTime currentTime = LocalTime.now();
        String userName = getUserName();
        
        String greeting;
        
        if (currentTime.getHour() < 12) {
            greeting = String.format("좋은 아침이에요, %s님!", userName);
        } else if (currentTime.getHour() < 18) {
            greeting = String.format("안녕하세요, %s님!", userName);
        } else {
            greeting = String.format("좋은 저녁이에요, %s님!", userName);
        }
        
        System.out.println(greeting);
    }
    
    private String getUserName() {
        // 사용자 이름을 가져오는 로직
        Scanner scanner = new Scanner(System.in);
        System.out.print("이름을 입력하세요: ");
        return scanner.nextLine();
    }
}

// 실행 시나리오 1 (오전 9시, 사용자: 김철수)
// 실행 흐름: 첫 번째 if 조건 만족
// 결과: "좋은 아침이에요, 김철수님!"

// 실행 시나리오 2 (오후 3시, 사용자: 이영희)  
// 실행 흐름: 두 번째 else if 조건 만족
// 결과: "안녕하세요, 이영희님!"

// 실행 시나리오 3 (저녁 8시, 사용자: 박민수)
// 실행 흐름: else 조건 실행
// 결과: "좋은 저녁이에요, 박민수님!"
```

### 고유한 실행 흐름의 예시

```java
// 복잡한 실행 흐름 예시: 게임 캐릭터 전투 시스템

public class BattleSystem {
    private Random random = new Random();
    private Scanner scanner = new Scanner(System.in);
    
    /**
     * 전투 시스템 - 매번 다른 흐름을 갖는 실행
     */
    public BattleResult battle(Player player, Enemy enemy) {
        List<String> battleLog = new ArrayList<>();
        int turnCount = 1;
        
        while (player.getHp() > 0 && enemy.getHp() > 0) {
            battleLog.add(String.format("=== 턴 %d ===", turnCount));
            
            // 플레이어 턴
            if (player.getSpeed() >= enemy.getSpeed()) {
                PlayerAction action = getPlayerAction();
                
                switch (action) {
                    case ATTACK:
                        int damage = calculateDamage(player.getAttack(), enemy.getDefense());
                        
                        // 크리티컬 히트 확률 (20%)
                        if (random.nextDouble() < 0.2) {
                            damage *= 2;
                            battleLog.add(String.format("크리티컬 히트! %s이 %d 데미지!", 
                                player.getName(), damage));
                        } else {
                            battleLog.add(String.format("%s이 %d 데미지!", 
                                player.getName(), damage));
                        }
                        
                        enemy.setHp(enemy.getHp() - damage);
                        break;
                        
                    case HEAL:
                        if (player.getPotions() > 0) {
                            int healAmount = 50;
                            player.setHp(Math.min(player.getMaxHp(), 
                                player.getHp() + healAmount));
                            player.setPotions(player.getPotions() - 1);
                            battleLog.add(String.format("%s이 %d 회복!", 
                                player.getName(), healAmount));
                        } else {
                            battleLog.add("포션이 없습니다!");
                        }
                        break;
                        
                    case SPECIAL:
                        if (player.getMp() >= 20) {
                            int specialDamage = (int)(player.getAttack() * 1.5);
                            player.setMp(player.getMp() - 20);
                            battleLog.add(String.format("%s의 필살기! %d 데미지!", 
                                player.getName(), specialDamage));
                            enemy.setHp(enemy.getHp() - specialDamage);
                        } else {
                            battleLog.add("MP가 부족합니다!");
                        }
                        break;
                }
            }
            
            // 적이 아직 살아있다면 적 턴
            if (enemy.getHp() > 0) {
                // AI 행동 결정 (확률 기반)
                double actionChance = random.nextDouble();
                
                if (actionChance < 0.7) {  // 70% 확률로 공격
                    int damage = calculateDamage(enemy.getAttack(), player.getDefense());
                    player.setHp(player.getHp() - damage);
                    battleLog.add(String.format("%s이 %d 데미지!", 
                        enemy.getName(), damage));
                    
                } else if (actionChance < 0.9) {  // 20% 확률로 방어
                    enemy.setDefenseBoost(true);
                    battleLog.add(String.format("%s이 방어 자세!", enemy.getName()));
                    
                } else {  // 10% 확률로 특수 공격
                    int damage = (int)(enemy.getAttack() * 1.3);
                    player.setHp(player.getHp() - damage);
                    battleLog.add(String.format("%s의 특수 공격! %d 데미지!", 
                        enemy.getName(), damage));
                }
            }
            
            turnCount++;
            
            // 매 턴마다 다른 상황, 다른 선택, 다른 결과
            // 같은 코드라도 실행할 때마다 완전히 다른 흐름
        }
        
        // 전투 결과 판정
        if (player.getHp() <= 0) {
            battleLog.add(String.format("%s 패배...", player.getName()));
            return new BattleResult("enemy", battleLog);
        } else {
            battleLog.add(String.format("%s 처치! 승리!", enemy.getName()));
            return new BattleResult("player", battleLog);
        }
    }
    
    // 플레이어 행동 선택
    private PlayerAction getPlayerAction() {
        System.out.println("행동을 선택하세요: 1)공격 2)회복 3)필살기");
        int choice = scanner.nextInt();
        
        switch (choice) {
            case 1: return PlayerAction.ATTACK;
            case 2: return PlayerAction.HEAL;
            case 3: return PlayerAction.SPECIAL;
            default: return PlayerAction.ATTACK;
        }
    }
    
    private int calculateDamage(int attack, int defense) {
        return Math.max(1, attack - defense);
    }
    
    // 플레이어 행동 열거형
    public enum PlayerAction {
        ATTACK, HEAL, SPECIAL
    }
    
    // 전투 결과 클래스
    public static class BattleResult {
        private String winner;
        private List<String> log;
        
        public BattleResult(String winner, List<String> log) {
            this.winner = winner;
            this.log = log;
        }
        
        // getter methods
        public String getWinner() { return winner; }
        public List<String> getLog() { return log; }
    }
}

// 같은 코드지만 매번 실행할 때마다:
// - 사용자의 선택이 다름
// - 랜덤 요소들이 다름
// - 크리티컬 히트 발생 여부가 다름
// - AI의 행동 패턴이 다름
// → 결과적으로 완전히 다른 실행 흐름과 결과
```

## 🎯 자동화: 프로그래밍의 궁극적 목표

### **자동화의 본질**

자동화 (Automation)의 정의:
사람이 반복적으로 수행하던 작업을
컴퓨터가 대신 수행하도록 하는 것

자동화의 가치:

1. 효율성: 빠른 속도로 처리
2. 정확성: 실수 없는 일관된 결과
3. 반복성: 지치지 않고 같은 작업 반복
4. 확장성: 대량의 작업도 동일하게 처리
5. 비용 절감: 인력 비용 절약

자동화 대상:

- 계산 작업 (급여 계산, 세금 계산)
- 데이터 처리 (파일 정리, 정보 분류)
- 의사소통 (이메일 발송, 알림 전송)
- 의사결정 (규칙 기반 판단)

### 자동화를 위한 절차적 사고

자동화 성공을 위한 핵심 요소:

1. 명확한 절차 정의:
    - 모든 단계를 빠짐없이 기술
    - 각 단계의 입력과 출력 명시
    - 예외 상황에 대한 처리 방법 정의
2. 조건 분석의 철저함:
    - 모든 가능한 경우의 수 고려
    - 예외 상황과 오류 처리 방안
    - 입력 데이터의 유효성 검증
3. 반복 패턴의 식별:
    - 어떤 작업이 반복되는가?
    - 반복의 조건과 종료 조건은?
    - 반복 중 변하는 것과 변하지 않는 것은?
4. 사람의 판단 영역과 기계의 처리 영역 구분:
    - 규칙으로 정의할 수 있는 것 → 자동화
    - 창의성이나 감정이 필요한 것 → 사람
    - 복잡한 판단이 필요한 것 → 사람 + 시스템

## 🎓 프로그래밍 학습의 핵심

### **글쓰기 능력이 프로그래밍 능력**

좋은 프로그래머의 특징:

1. 명확한 사고: 모호함 없이 정확한 절차 정의
2. 체계적 분석: 복잡한 문제를 단순한 단계로 분해
3. 논리적 구성: 순서와 조건을 명확히 정리
4. 예외 처리: 예상치 못한 상황에 대한 대비
5. 지속적 개선: 더 효율적인 절차 탐구

프로그래밍 학습 방법:

1. 일상의 절차들을 글로 써보기
    - 라면 끓이는 방법
    - 지하철 타는 방법
    - 온라인 쇼핑하는 방법
2. 조건들을 빠짐없이 나열하기
    - "만약 ~라면"
    - "~가 없다면"
    - "~인 경우에는"
3. 반복되는 패턴 찾기
    - "~할 때까지 반복"
    - "각각에 대해"
    - "~인 동안"

### **프로그래밍의 본질**

1. **절차적 글쓰기**: 일하는 순서를 체계적으로 기술
2. **조건 분석**: 모든 상황에 대한 대응 방안 마련
3. **자동화 목표**: 사람의 반복 작업을 컴퓨터가 대신 수행
4. **고유한 실행**: 같은 코드라도 매번 다른 흐름과 결과

### **성공적인 프로그래밍을 위한 핵심 요소**

1. **명확성**: 모호함 없는 정확한 절차 정의
2. **완전성**: 모든 경우의 수와 예외 상황 고려
3. **논리성**: 순서와 조건의 체계적 구성
4. **효율성**: 더 간단하고 빠른 방법 탐구