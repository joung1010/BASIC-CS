# 컴퓨터에서 글자를 다루는 방법 완전 가이드

## 🔤 기본 개념: 숫자에서 문자로

### **컴퓨터는 왜 숫자만 인식하나?**

```

컴퓨터의 기본 원리:
- 전기 신호: ON(1) / OFF(0)
- 모든 정보: 2진수 조합
- 문자라는 개념 자체가 존재하지 않음

따라서 문자 표현 = 숫자와 문자의 매핑 규약 필요

```

### **문자 매핑의 탄생**

```

초기 컴퓨터 시대 (1960년대):
각 회사마다 서로 다른 매핑 규칙 사용
→ IBM: A=193, B=194, C=195
→ 다른 회사: A=65, B=66, C=67
→ 호환성 문제 심각!

해결책: 표준 코드 체계 필요 → ASCII 탄생

```

## 📊 ASCII (American Standard Code for Information Interchange)

### **ASCII 코드 체계 상세**

```

ASCII 구조:
- 7비트 사용 (0~127, 총 128개 문자)
- 나중에 8비트로 확장 (0~255, 확장 ASCII)
- 미국 영어 중심 설계

```

### **ASCII 코드표 (주요 부분)**

| 범위 | 10진수 | 16진수 | 문자 | 설명 |
| --- | --- | --- | --- | --- |
| **제어문자** | 0-31 | 0x00-0x1F | - | 화면 제어, 통신 제어 |
| **공백/기호** | 32-47 | 0x20-0x2F | 공백, !, ", #, $ 등 | 특수 문자 |
| **숫자** | 48-57 | 0x30-0x39 | '0'~'9' | 문자로서의 숫자 |
| **기호** | 58-64 | 0x3A-0x40 | :, ;, <, =, >, ?, @ | 구두점, 연산자 |
| **대문자** | 65-90 | 0x41-0x5A | 'A'~'Z' | 영문 대문자 |
| **기호** | 91-96 | 0x5B-0x60 | [, , ], ^, _, ` | 특수 기호 |
| **소문자** | 97-122 | 0x61-0x7A | 'a'~'z' | 영문 소문자 |
| **기호** | 123-127 | 0x7B-0x7F | {, | , }, ~, DEL |

## 숫자 vs 문자의 명확한 구분

### **숫자 1 vs 문자 '1'**

```

숫자 1:
- 값: 1₁₀ = 0x01₁₆ = 00000001₂
- 의미: 수학적 값 1
- 용도: 계산, 연산

문자 '1':
- 값: 49₁₀ = 0x31₁₆ = 00110001₂
- 의미: 숫자 모양의 문자
- 용도: 화면 출력, 텍스트 표시

```

### **실제 메모리 저장 비교**

```c

// C 언어 예시
int number = 1;// 메모리: 01 00 00 00 (4바이트, 리틀 엔디안)
char character = '1';// 메모리: 31 (1바이트)

printf("%d\n", number);// 출력: 1
printf("%c\n", character);// 출력: 1 (모양은 같지만 완전히 다름!)

```

## 제어 문자 (Control Characters)

### **중요한 제어 문자들**

| 이름 | 10진수 | 16진수 | 표기 | 설명 |
| --- | --- | --- | --- | --- |
| **NULL** | 0 | 0x00 | \0 | 문자열 끝 표시 |
| **TAB** | 9 | 0x09 | \t | 탭 (8칸 이동) |
| **LF** | 10 | 0x0A | \n | 줄바꿈 (Line Feed) |
| **CR** | 13 | 0x0D | \r | 커서를 줄 맨 앞으로 (Carriage Return) |
| **ESC** | 27 | 0x1B | \e | 이스케이프 (터미널 제어) |
| **SPACE** | 32 | 0x20 |  | 공백 |
| **DEL** | 127 | 0x7F |  | 삭제 |

### **줄바꿈의 운영체제별 차이**

```

Windows: CR + LF = 0x0D 0x0A = \r\n
Unix/Linux: LF = 0x0A = \n
Mac (구버전): CR = 0x0D = \r

예시의 "Hello World!\r\n"는 Windows 스타일

```

## 🔍 헥스 덤프 상세 분석

### **헥스 덤프 구조 해석**

```

offset(h) 00 01 02 03 04 05 06 07   ASCII
00000000  48 65 6C 6C 6F 20 57 6F   Hello Wo
00000008  72 6C 64 21 0D 0A 48 49   rld!..Hi
00000010  2E 0D 0A 0D 0A            .....

```

## 바이너리 vs 텍스트

### **바이너리 (Binary) 데이터**

```

정의: 모든 디지털 정보 (0과 1의 조합)
특징:
- 문자 인코딩과 무관한 순수 데이터
- 실행 파일, 이미지, 동영상, 압축 파일 등
- 텍스트 에디터로 열면 깨져 보임

예시:
실행파일 .exe: 4D 5A 90 00 03 00 00 00...
JPEG 이미지: FF D8 FF E0 00 10 4A 46...

```

### **텍스트 (Text) 데이터**

```

정의: 문자 인코딩으로 해석 가능한 바이너리
특징:
- ASCII, UTF-8 등으로 문자로 변환 가능
- 사람이 읽을 수 있는 형태
- 소스 코드, 문서, 설정 파일 등

예시:
"Hello" = 48 65 6C 6C 6F (ASCII)

```

## 🔧 프로그래밍에서의 활용

### **문자열 저장 방식**

```c

// C 스타일 문자열 (Null-terminated)
char message[] = "Hello";
// 메모리: 48 65 6C 6C 6F 00//         H  e  l  l  o  \0// 배열 크기: 6바이트 (문자 5개 + null terminator)

```

### **문자 변환 테크닉**

```c

// 대문자 ↔ 소문자 변환
char upper = 'A';// 0x41
char lower = upper + 32;// 0x61 = 'a'// 또는 비트 연산 사용
char lower2 = upper | 0x20;// 0x41 | 0x20 = 0x61// 숫자 문자 → 숫자 값
char digit = '7';// 0x37 = 55
int number = digit - '0';// 55 - 48 = 7

```

### **인코딩 확인 방법**

```bash

# Linux/Unix에서 파일 인코딩 확인
file -i filename.txt
# 출력: filename.txt: text/plain; charset=utf-8# 헥스 덤프로 내용 확인
hexdump -C filename.txt
xxd filename.txt

```

## 핵심 정리

1. **컴퓨터는 숫자만 인식** → 문자는 숫자와의 매핑 규약
2. **ASCII**: 미국 표준, 7비트, 128개 문자
3. **숫자 1 ≠ 문자 '1'**: 완전히 다른 값 (0x01 vs 0x31)
4. **제어 문자**: 화면/통신 제어용 특수 문자들
5. **바이너리**: 모든 디지털 데이터, **텍스트**: 문자로 해석 가능한 바이너리
6. **헥스 덤프**: 바이너리 데이터를 16진수로 표시하는 도구