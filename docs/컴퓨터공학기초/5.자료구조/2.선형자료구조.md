# 선형 자료구조: Stack과 Queue

## 📚 Stack: 쌓아 올리는 구조

### **Stack의 기본 개념**

Stack의 정의:

- 1차원적 선형 구조
- 입출력 지점이 1개뿐인 자료구조
- LIFO (Last In, First Out) 구조

시각적 표현:
↑ push/pop (입구이자 출구)
┌─────┐
│  5  │ ← top (맨 위)
├─────┤
│  4  │
├─────┤
│  3  │
├─────┤
│  2  │
├─────┤
│  1  │ ← bottom (맨 아래)
└─────┘

특징:

- 위에서만 데이터 추가/제거 가능
- 중간 데이터에 직접 접근 불가능
- 나중에 들어온 것이 먼저 나감

### 뚜껑형 김치냉장고 비유

김치냉장고 Stack:

뚜껑을 열고 김치통을 넣는 상황:

1단계: 첫 번째 김치통 넣기
┌─────┐
│ 배추 │ ← 첫 번째로 넣은 김치 (바닥)
└─────┘

2단계: 두 번째 김치통 넣기

┌─────┐
│ 깍두기│ ← 두 번째로 넣은 김치
├─────┤
│ 배추 │
└─────┘

3단계: 세 번째 김치통 넣기
┌─────┐
│ 열무 │ ← 세 번째로 넣은 김치 (top)
├─────┤
│ 깍두기│
├─────┤
│ 배추 │
└─────┘

김치를 꺼낼 때:

1. 열무 꺼내기 (가장 위에 있음)
2. 깍두기 꺼내기 (그 다음 위에 있음)
3. 배추 꺼내기 (맨 아래 있었음)

결과: 넣은 순서의 반대로 나옴!
넣은 순서: 배추 → 깍두기 → 열무
나오는 순서: 열무 → 깍두기 → 배추

### 왜 이런 구조가 필요할까?

Stack이 필요한 상황들:

1. 정보의 뒤집기:
   입력: A B C D E
   스택 처리 후: E D C B A

   활용 예시:

    - 문자열 뒤집기
    - 수식의 역순 처리
    - 후위 표기법 변환
2. 되돌아가기 (Undo):
   Ctrl + Z의 동작 원리

   사용자 행동 기록:
   push("텍스트 입력")
   push("글꼴 변경")
   push("색상 변경")
   push("크기 변경")

   Ctrl + Z 실행:
   pop() → "크기 변경" 취소
   pop() → "색상 변경" 취소

   pop() → "글꼴 변경" 취소
   pop() → "텍스트 입력" 취소

3. 함수 호출 관리:
   프로그램에서 함수 A가 함수 B를 호출하고,
   함수 B가 함수 C를 호출할 때:

   push("함수 A 실행 정보")
   push("함수 B 실행 정보")
   push("함수 C 실행 정보")

   함수 완료 순서:
   pop() → 함수 C 완료 후 B로 돌아감
   pop() → 함수 B 완료 후 A로 돌아감
   pop() → 함수 A 완료

4. 웹 브라우저 뒤로가기:
   방문한 페이지들이 스택에 저장됨
   push("페이지1")
   push("페이지2")
   push("페이지3")

   뒤로가기 버튼 클릭:
   pop() → 페이지2로 돌아감
   pop() → 페이지1로 돌아감


## Queue: 줄서기 구조

### **Queue의 기본 개념**

Queue = 1차원적 선형구조의 자료구조
핵심 특징: 입출력 지점이 2개 (앞과 뒤가 다름)

구조 모습:
출구 ← [데이터1][데이터2][데이터3][데이터4][데이터5] ← 입구
Front                                                Rear

FIFO (First In, First Out) 구조:

- 먼저 넣은 것이 먼저 나옴
- 뒤에서 넣고 앞에서 뺌
- 은행 대기표, 버스 줄서기와 동일

기본 연산:

- Enqueue: 뒤쪽(Rear)에서 데이터 삽입
- Dequeue: 앞쪽(Front)에서 데이터 제거

### 은행 대기표 시스템

은행에서 업무를 보는 과정:

1. 고객이 대기표 뽑기:
   enqueue("고객1") → [고객1]
   enqueue("고객2") → [고객1][고객2]

   enqueue("고객3") → [고객1][고객2][고객3]
   enqueue("고객4") → [고객1][고객2][고객3][고객4]

2. 은행 직원이 고객 호출:
   dequeue() → "고객1" 호출 → [고객2][고객3][고객4]
   dequeue() → "고객2" 호출 → [고객3][고객4]
   dequeue() → "고객3" 호출 → [고객4]
   dequeue() → "고객4" 호출 → []

특징:

- 먼저 온 고객이 먼저 서비스 받음
- 공정한 순서 보장
- 뒤에서 들어와서 앞에서 나감

버스 줄서기도 동일:

- 먼저 온 사람이 먼저 탑승
- 새로 온 사람은 줄 맨 뒤에 서기
- 버스가 오면 맨 앞사람부터 탑승

### 왜 이런 구조가 필요할까?

Queue가 필요한 상황들:

1. 공정한 순서 처리:
    - 은행 업무 대기
    - 프린터 인쇄 대기
    - 전화 상담 대기
    - 온라인 게임 매칭 대기
2. 자료의 동기화 (핵심!):
   멀티스레딩 환경에서 매우 중요

   은행 시스템 예시:

    - 고객들 = 요청(Request)들
    - 은행 직원들 = 스레드(Thread)들
    - 대기 줄 = Queue

   동작 과정:
   여러 고객이 동시에 요청 → Queue에 순서대로 저장
   여러 직원이 → Queue에서 하나씩 가져와서 처리

   장점:

    - 요청이 순서대로 처리됨
    - 직원들이 동시에 일할 수 있음
    - 요청이 유실되지 않음
3. 데이터 스트리밍:
    - 영상 버퍼링: 데이터가 순서대로 재생되어야 함
    - 음악 재생: 순서가 바뀌면 이상해짐
    - 네트워크 패킷: 순서가 중요함
4. 작업 스케줄링:
   CPU 스케줄러에서 프로세스 관리:
   enqueue("프로세스A")
   enqueue("프로세스B")
   enqueue("프로세스C")

   CPU가 처리:
   dequeue() → 프로세스A 실행
   dequeue() → 프로세스B 실행
   dequeue() → 프로세스C 실행

5. BFS(너비 우선 탐색):
   그래프나 트리에서 레벨 순으로 탐색할 때 사용

## Stack vs Queue 비교

### **구조적 차이점**

Stack (스택):
입출력 지점: 1개 (Top만 사용)
┌─────────────────┐
│    데이터 3     │ ← Top (입구이자 출구)
├─────────────────┤
│    데이터 2     │
├─────────────────┤
│    데이터 1     │
└─────────────────┘

Queue (큐):
입출력 지점: 2개 (Front와 Rear)
Front ← [데이터1][데이터2][데이터3] ← Rear
(출구)                              (입구)

동작 차이:
Stack: push/pop 모두 같은 위치(Top)
Queue: enqueue(Rear), dequeue(Front) 다른 위치

### 사용 목적의 차이

Stack의 용도:

- 순서 뒤집기
- 되돌아가기 (Undo)
- 함수 호출 스택
- 괄호 검사
- 계산기 구현

Queue의 용도:

- 순서 유지하기
- 공정한 처리
- 멀티스레딩 동기화
- 스케줄링
- 버퍼링

핵심 차이점:
Stack = "가장 최근 것을 먼저" (역순 처리)
Queue = "가장 오래된 것을 먼저" (순서 유지)

## 핵심 정리

### **Stack (스택)**

1. **구조**: 입출력 지점 1개, LIFO 방식
2. **연산**: Push(넣기), Pop(꺼내기)
3. **용도**: 뒤집기, 되돌아가기, 함수 호출 관리
4. **비유**: 뚜껑형 김치냉장고, 책 더미

### **Queue (큐)**

1. **구조**: 입출력 지점 2개, FIFO 방식
2. **연산**: Enqueue(넣기), Dequeue(꺼내기)
3. **용도**: 순서 처리, 동기화, 스케줄링
4. **비유**: 은행 대기줄, 버스 줄서기

### **핵심 차이점**

- **Stack**: 최근 것을 먼저 (역순)
- **Queue**: 오래된 것을 먼저 (순서 유지)